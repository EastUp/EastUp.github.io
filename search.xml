<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C基础：01.基本数据类型和指针入门</title>
    <url>/01.C%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%8C%87%E9%92%88%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1. 基本数据类型"></a>1. 基本数据类型</h1><p><code>&amp;i</code>地址的占位符为<code>p</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;    <span class="comment">// 占位符d</span></span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">200</span>; <span class="comment">// 占位符lf</span></span><br><span class="line">    <span class="keyword">float</span> f = <span class="number">200</span>;  <span class="comment">// 占位符f</span></span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">100</span>;  <span class="comment">// 占位符ld</span></span><br><span class="line">    short s = <span class="number">100</span>; <span class="comment">// 占位符d</span></span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'D'</span>;  <span class="comment">// 占位符c</span></span><br><span class="line">    <span class="comment">// 字符串 char*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出打印 ， 要用占位符</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i 的值是：%d\n"</span>,i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"d 的值是：%lf\n"</span>,d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"f 的值是：%f\n"</span>,f);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"l 的值是：%ld\n"</span>,l);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s 的值是：%d\n"</span>,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c 的值是：%c\n"</span>,c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"c 的地址是：%p\n"</span>,&amp;c);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i 的值是：100</span><br><span class="line">d 的值是：200.000000</span><br><span class="line">f 的值是：200.000000</span><br><span class="line">l 的值是：100</span><br><span class="line">s 的值是：100</span><br><span class="line">c 的值是：D</span><br></pre></td></tr></table></figure>

<h1 id="2-变量的地址：任何的数据（变量）都会有地址（住址门牌号）"><a href="#2-变量的地址：任何的数据（变量）都会有地址（住址门牌号）" class="headerlink" title="2. 变量的地址：任何的数据（变量）都会有地址（住址门牌号）"></a>2. 变量的地址：任何的数据（变量）都会有地址（住址门牌号）</h1><ul>
<li>int占4个字节</li>
<li>double占8个字节</li>
<li>char占一个字节</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// &amp;i &amp; 代表变量的地址</span></span><br><span class="line">    <span class="comment">// 通过 debug 的调试，我们可以根据地址去查下该地址的数据 int 4 字节 sizeof() 获取数据类型所占的字节数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i 的地址是：%p"</span>,&amp;i); <span class="comment">// i 的地址是：000000000060FE1C</span></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"int 数据类型所占的字节数：%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">// int 数据类型所占的字节数：4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"double 数据类型所占的字节数：%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">double</span>));<span class="comment">// double 数据类型所占的字节数：8</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"char 数据类型所占的字节数：%d\n"</span>,<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">// char 数据类型所占的字节数：1</span></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-指针变量和获取地址的值"><a href="#3-指针变量和获取地址的值" class="headerlink" title="3. 指针变量和获取地址的值"></a>3. 指针变量和获取地址的值</h1><p>通过 <code>*</code> 例如<code>*(&amp;i)</code>获取地址的值</p>
<p><code>指针（地址）变量</code>：指针存放（指向）的就是变量的地址。注意<strong>指针变量是一个变量</strong></p>
<p><font color="red"><strong>一个指针的大小始终是32位系统占4个字节，64位系统占8字节</strong></font></p>
<p>指针为什么要有类型：</p>
<ol>
<li>为了地址增量的方便：例如double型的地址增量为8，而int型指针的地址增量为4</li>
<li>为了类型安全：帮助编译器发现你是否用了错误的类型</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">double</span> d = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i的值是：%d\n"</span>,i); <span class="comment">// i的值是：100</span></span><br><span class="line">    <span class="comment">// 通过 * 获取地址的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i的值是：%d\n"</span>,*(&amp;i)); <span class="comment">// i的值是：100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针（地址）变量 指针存放（指向）的就是变量的地址</span></span><br><span class="line">    <span class="comment">// int* 代表的是 int 类型的指针 （地址）</span></span><br><span class="line">    <span class="keyword">int</span>* p = &amp;i;</span><br><span class="line">    <span class="comment">// double* p1 = &amp;d;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i的值是：%d\n"</span>,*p); <span class="comment">// i的值是：100</span></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-通过指针修改值"><a href="#4-通过指针修改值" class="headerlink" title="4. 通过指针修改值"></a>4. 通过指针修改值</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* p = &amp;i;</span><br><span class="line"></span><br><span class="line">	i = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i的值是：%d\n"</span>,i); <span class="comment">// i的值是：200</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还有一种方式：获取指针的值进行间接的修改</span></span><br><span class="line">	*p = <span class="number">300</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"i的值是：%d"</span>, i); <span class="comment">// i的值是：300</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-题目：写个方法对两个值进行交换"><a href="#5-题目：写个方法对两个值进行交换" class="headerlink" title="5. 题目：写个方法对两个值进行交换"></a>5. 题目：写个方法对两个值进行交换</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">// 这个 i 是另外一个</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"change 中i的地址是：%p\n"</span>,&amp;i);</span><br><span class="line">	i = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过地址来修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>* p)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"change中i的地址是：%p\n"</span>,p);</span><br><span class="line">	*p = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span>* b)</span></span>&#123; <span class="comment">// 2 面试题：对 a,b 两个值进行交换，但是不开辟额外的内存（不能用中间变量）</span></span><br><span class="line">    <span class="comment">// 大家在这里面写</span></span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line"></span><br><span class="line">    *a = *b;<span class="comment">// a的值 = b 的值</span></span><br><span class="line"></span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-题目：不开辟新的内存对两个值进行交换"><a href="#6-题目：不开辟新的内存对两个值进行交换" class="headerlink" title="6. 题目：不开辟新的内存对两个值进行交换"></a>6. 题目：不开辟新的内存对两个值进行交换</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    <span class="comment">// change(&amp;a,&amp;b);</span></span><br><span class="line"></span><br><span class="line">    a = a + b;<span class="comment">// a = 300</span></span><br><span class="line">    <span class="comment">//a = a - b;</span></span><br><span class="line">    b = a - b;<span class="comment">// b = 200</span></span><br><span class="line">    a = a - b;<span class="comment">// a = 100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"交换后ab的值分别是：%d,%d"</span>,a,b); <span class="comment">// 交换后ab的值分别是：200,100</span></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-指针变量的加深理解"><a href="#7-指针变量的加深理解" class="headerlink" title="7.指针变量的加深理解"></a>7.指针变量的加深理解</h1><p>指针变量只是一个<code>变量</code>它指向了地址值，<strong>修改指针变量并不会修改指向对象的地址值</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// a = b 把b变量的值复制给a</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a,b的地址分别是：%p,%p\n"</span>,&amp;a,&amp;b); <span class="comment">// a,b的地址分别是：000000000060FE0C,000000000060FE08</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>* p1 = &amp;a;<span class="comment">// p1 是一个变量而已</span></span><br><span class="line">	<span class="keyword">int</span>* p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// p1 = p2 是什么意思，有点类似于 a = b ；p1 和 p2 只是一个变量而已；</span></span><br><span class="line">	p1 = p2;<span class="comment">// 只是p1 的变量指向改成了指向b的地址，并没有改动 a 的地址</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"a,b的地址分别是：%p,%p\n"</span>, &amp;a, &amp;b); <span class="comment">// a,b的地址分别是：000000000060FE0C,000000000060FE08</span></span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础：05.结构体联合体和枚举以及大小计算</title>
    <url>/05.C%E5%9F%BA%E7%A1%80-%E7%BB%93%E6%9E%84%E4%BD%93%E8%81%94%E5%90%88%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE%E4%BB%A5%E5%8F%8A%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="1-结构体的定义和使用"><a href="#1-结构体的定义和使用" class="headerlink" title="1.结构体的定义和使用"></a>1.结构体的定义和使用</h1><h2 id="1-1-结构体的定义"><a href="#1-1-结构体的定义" class="headerlink" title="1.1.结构体的定义"></a>1.1.结构体的定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span> <span class="comment">// 定义一个结构体， 相当于 java 的 class struct Worker worker; // 初始化，没有初始化的情况下，那么里面所有的属性都是没有初始值的，salary</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">&#125;;*/</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式，可以直接取名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span> <span class="comment">// 定义一个结构体， 相当于 java 的 class</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">&#125;eastrise = &#123;<span class="string">"Eastrise"</span>,<span class="number">25</span>,<span class="number">1000</span>&#125;,jack; <span class="comment">// 这种方式会有一个默认的初始值,jack会有默认初始值</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Work</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">char</span> grade[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方式，结构体嵌套</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span><span class="comment">// 定义一个结构体，相当于 java 的 class</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 工作， name grade</span></span><br><span class="line">	Work work;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种方式，结构体嵌套</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span><span class="comment">// 定义一个结构体，相当于 java 的 class</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Work</span>&#123;</span></span><br><span class="line">		<span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">char</span> grade[<span class="number">10</span>];</span><br><span class="line">	&#125;work;</span><br><span class="line">	<span class="comment">// 工作， name grade</span></span><br><span class="line">	<span class="comment">// Work work;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-结构体的使用"><a href="#1-2-结构体的使用" class="headerlink" title="1.2.结构体的使用"></a>1.2.结构体的使用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span> <span class="comment">// 定义一个结构体， 相当于 java 的 class</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">&#125;eastrise = &#123;<span class="string">"Eastrise"</span>,<span class="number">25</span>,<span class="number">1000</span>&#125;,jack; <span class="comment">// 这种方式会有一个默认的初始值,jack会有默认初始值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 结构体的定义和使用</span></span><br><span class="line"><span class="comment">// char* 不算基本数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Worker</span> <span class="title">worker</span>;</span> <span class="comment">// 初始化，没有初始化的情况下，那么里面所有的属性都是没有初始值的，salary</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 赋值</span></span><br><span class="line">    worker.age = <span class="number">24</span>;</span><br><span class="line">    <span class="comment">// worker.name = "Eastrise";</span></span><br><span class="line">    <span class="built_in">strcpy</span>(worker.name,<span class="string">"JACK"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// jack.name = "Jack";</span></span><br><span class="line">    <span class="built_in">strcpy</span>(jack.name,<span class="string">"JACK"</span>);</span><br><span class="line">    jack.age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name = %s, age = %d, salary = %lf"</span>,eastrise.name,eastrise.age,eastrise.salary);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; Eastrise, age &#x3D; 25, salary &#x3D; 1000.000000</span><br></pre></td></tr></table></figure>

<h1 id="2-结构体指针和动态内存开辟"><a href="#2-结构体指针和动态内存开辟" class="headerlink" title="2.结构体指针和动态内存开辟"></a>2.结构体指针和动态内存开辟</h1><h2 id="2-1-通过指针取操作数据"><a href="#2-1-通过指针取操作数据" class="headerlink" title="2.1.通过指针取操作数据"></a>2.1.<strong>通过指针取操作数据</strong></h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Worker</span> <span class="title">worker</span> = &#123;</span><span class="string">"eastrise"</span>,<span class="number">25</span>&#125;;</span><br><span class="line">    Worker* worker_p = &amp;worker;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过结构体指针去操控数据</span></span><br><span class="line">    <span class="comment">// worker.age = 24;</span></span><br><span class="line">    worker_p -&gt; age = <span class="number">24</span>; <span class="comment">// 结构体操作的另外一种方式， 一般这种比较常用</span></span><br><span class="line">    <span class="built_in">strcpy</span>(worker_p-&gt;name,<span class="string">"Jack"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name = %s, age = %d"</span>,worker_p-&gt;name,worker_p-&gt;age);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; Jack, age &#x3D; 24</span><br></pre></td></tr></table></figure>

<h2 id="2-2-动态开辟结构体内存"><a href="#2-2-动态开辟结构体内存" class="headerlink" title="2.2.动态开辟结构体内存"></a>2.2.<strong>动态开辟结构体内存</strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span> <span class="comment">// 定义一个结构体， 相当于 java 的 class</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作, name gradle</span></span><br><span class="line">    <span class="comment">// Work work;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Worker* worker;// 创建了一个结构体指针， 指针没有初始化？</span></span><br><span class="line">    Worker* worker = (Worker*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Worker));</span><br><span class="line">    worker-&gt;age = <span class="number">26</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(worker-&gt;name,<span class="string">"Jamin"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name = %s, age = %d"</span>,worker-&gt;name,worker-&gt;age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">if</span>(worker)&#123;</span><br><span class="line">        <span class="built_in">free</span>(worker);</span><br><span class="line">        worker = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; Jamin, age &#x3D; 26</span><br></pre></td></tr></table></figure>

<p><strong>结构体的数组</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span> <span class="comment">// 定义一个结构体， 相当于 java 的 class</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 插件结构体数组，第一种</span></span><br><span class="line"><span class="comment">//    Worker worker[10] = &#123;&#123;"Eastrise",25,1000&#125;,&#123;&#125;,&#123;&#125;,&#123;&#125;&#125;; // 创建了 10 个，静态开辟</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    worker[9] = &#123;"Eastrise",26,1000&#125;;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    printf("name = %s ,age = %d\n",worker[9].name,worker[9].age);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态内存开辟 Worker* 结构体的指针</span></span><br><span class="line">    Worker* worker = (Worker*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Worker)*<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(worker-&gt;name,<span class="string">"Eastrise"</span>);</span><br><span class="line">    worker-&gt;age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对第十个数据进行操作</span></span><br><span class="line">    worker += <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(worker-&gt;name,<span class="string">"Eastrise9"</span>);</span><br><span class="line">    worker-&gt;age = <span class="number">9</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name = %s，age = %d"</span>,worker-&gt;name,worker-&gt;age);</span><br><span class="line">    <span class="built_in">free</span>(worker);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; Eastrise9，age &#x3D; 9</span><br></pre></td></tr></table></figure>

<h1 id="3-结构体大小计算（字节对齐）"><a href="#3-结构体大小计算（字节对齐）" class="headerlink" title="3.结构体大小计算（字节对齐）"></a>3.结构体大小计算（字节对齐）</h1><p>计算的规则：</p>
<ol>
<li>按照最大的字节去计算 </li>
<li>算得时候只会按照基本数据类型去算</li>
<li>首先会把所有字节数加起来， 是否能够整除最大属性(有其它结构体就按照其它结构体中所有的基本类型数据总和跟本身最大的基本数据类型比较大小)的字节数，如果不够会往上累加，一直加到能整除的位置</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Worker</span>&#123;</span> <span class="comment">// 定义一个结构体， 相当于 java 的 class</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>]; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">double</span> salary; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char name[10] 24, char name[18] 32</span></span><br><span class="line">    <span class="comment">// 32 怎么来的？ 18 + 4 + 8 = 30, 按照能整除最大的基本数据类型来算：32/8=4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(Worker); <span class="comment">// 24字节</span></span><br><span class="line">    <span class="comment">// 计算的规则：</span></span><br><span class="line">    <span class="comment">// 1. 按照最大的字节去计算</span></span><br><span class="line">    <span class="comment">// 2. 算得时候只会按照基本数据类型去算</span></span><br><span class="line">    <span class="comment">// 3. 首先会把所有字节数加起来， 是否能够整除最大属性(有其它结构体就按照其它结构体中所有的基本类型数据总和跟本身最大的基本数据类型比较大小)的字节数，如果不够会往上累加，一直加到能整除的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size = %d \n"</span>,<span class="built_in">size</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">date</span>&#123;</span> <span class="comment">// 12</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">char</span> sex; <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>]; <span class="comment">// 10</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> <span class="title">birthday</span>;</span> <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 31%4  32%4 32个字节？</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(student); <span class="comment">// 36字节</span></span><br><span class="line">    <span class="comment">// 计算的规则：</span></span><br><span class="line">    <span class="comment">// 1. 按照最大的字节去计算</span></span><br><span class="line">    <span class="comment">// 2. 算得时候只会按照基本数据类型去算</span></span><br><span class="line">    <span class="comment">// 3. 首先会把所有字节数加起来， 是否能够整除最大属性(有其它结构体就按照其它结构体中所有的基本类型数据总和跟本身最大的基本数据类型比较大小)的字节数的字节数，如果不够会往上累加，一直加到能整除的位置</span></span><br><span class="line">    <span class="comment">// 4. 进阶，留下一个思考</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size = %d \n"</span>,<span class="built_in">size</span>);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24</span><br><span class="line"></span><br><span class="line">36</span><br></pre></td></tr></table></figure>

<h1 id="4-结构体和结构体指针取别名"><a href="#4-结构体和结构体指针取别名" class="headerlink" title="4.结构体和结构体指针取别名"></a>4.结构体和结构体指针取别名</h1><p>关键词：<strong>typedef</strong></p>
<p><code>typedef Worker_ Worker_;</code> :好处<strong><code>初始化时可以不用带 struct 关键字了</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Worker_ Worker_;</span><br><span class="line"><span class="comment">// 对结构体的指针取别名</span></span><br><span class="line"><span class="keyword">typedef</span> Worker_* Worker;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Worker worker = (Worker_*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Worker_));</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s,%d,%lf"</span>,worker-&gt;name,worker-&gt;age,worker-&gt;salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">,--&gt; 0,---&gt; 0.000000</span><br></pre></td></tr></table></figure>

<h1 id="5-联合体的定义和使用"><a href="#5-联合体的定义和使用" class="headerlink" title="5.联合体的定义和使用"></a>5.联合体的定义和使用</h1><p><strong>联合体(共用体)</strong> 是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。</p>
<p><code>联合体因为是在相同的内存位置存储，所以下面代码中只能存在一个，要么是 age ，要么是 name</code> , 后定义的才存在</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> Person</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 最能出现一个 ，不用累加，找最大值 10，12字节</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">10</span>]; <span class="comment">// 10 </span></span><br><span class="line">	<span class="keyword">int</span> age; <span class="comment">// 4 </span></span><br><span class="line">	<span class="keyword">double</span> salary;<span class="comment">// 8</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// Person person = &#123;"Darren"&#125;;</span></span><br><span class="line">	 Person person;</span><br><span class="line">	 strcpy_s(person.name,<span class="string">"Darren"</span>);</span><br><span class="line">	 person.age = <span class="number">24</span>;</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"name = %s,age = %d"</span>,person.name,person.age); <span class="comment">// 只有 age 才有值，因为他是后定义的 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="keyword">sizeof</span>(Person)); <span class="comment">// 12</span></span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name &#x3D; ,age &#x3D; 25</span><br><span class="line">16</span><br></pre></td></tr></table></figure>

<h1 id="6-联合体大小计算"><a href="#6-联合体大小计算" class="headerlink" title="6. 联合体大小计算"></a>6. 联合体大小计算</h1><p><code>不用累加，取的最大值，最终是否够基本数据类型整除</code></p>
<h1 id="7-枚举的定义和使用"><a href="#7-枚举的定义和使用" class="headerlink" title="7.枚举的定义和使用"></a>7.枚举的定义和使用</h1><p><code>枚举有点类似于 int</code>，没有指定的依照前面的数值累加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> CommentType</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 后面的 = 只能是int类型,否则报错：Integral constant expression must have integral or unscoped enumeration type, not 'const char [4]</span></span><br><span class="line">	TEXT = <span class="number">10</span>,TEXT_IMAGE =<span class="number">13</span>,IMAGE</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	CommentType commentType = TEXT;</span><br><span class="line">	CommentType commentType1 = TEXT_IMAGE;</span><br><span class="line">	CommentType commentType2 = IMAGE;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d,%d,%d"</span>, commentType, commentType1, commentType2); <span class="comment">// 10,13,14</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础：04.字符串常见操作和指针练习</title>
    <url>/04.C%E5%9F%BA%E7%A1%80-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E5%92%8C%E6%8C%87%E9%92%88%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="1-字符串定义"><a href="#1-字符串定义" class="headerlink" title="1.字符串定义"></a>1.字符串定义</h1><p><strong>字符串以 <code>\0</code> 结尾，动态开辟内存的时候也需要多考虑一位</strong></p>
<p>定义方式有两种：</p>
<ol>
<li><code>char str[] = {&#39;E&#39;,&#39;a&#39;,&#39;s&#39;,&#39;t&#39;,&#39;r&#39;,&#39;i&#39;,&#39;s&#39;,&#39;e&#39;,&#39;\0&#39;};</code> : 可以修改</li>
<li><code>const char *str1 = &quot;Eastrise&quot;;</code>：不能修改，字符串常量存放再全局的const内存区</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 第一种 字符串数组</span></span><br><span class="line">    <span class="keyword">char</span> str[] = &#123;<span class="string">'E'</span>,<span class="string">'a'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>,<span class="string">'r'</span>,<span class="string">'i'</span>,<span class="string">'s'</span>,<span class="string">'e'</span>,<span class="string">'\0'</span>&#125;;</span><br><span class="line"></span><br><span class="line">    str[<span class="number">2</span>] = <span class="string">'y'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str); <span class="comment">// 字符串结尾必须是 '\0'，开辟内存也需要多开辟一个</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二种 不加 const 会警告：deprecated conversion from string constant to 'char*'</span></span><br><span class="line">    <span class="comment">// 原因：</span></span><br><span class="line">    <span class="comment">//      "Eastrise"是字符串常量, 内存分配在全局的const内存区</span></span><br><span class="line">    <span class="comment">//       char * 声明了一个指针，而这个指针指向的是全局的const内存区，const内存区当然不会让你想改就改的。所以，如果你一定要写这块内存的话，那就是一个非常严重的内存错误。</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str1 = <span class="string">"Eastrise"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    str1[2] = 'y';</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两种定义的区别：一个能修改，一个不能修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-字符串长度获取"><a href="#2-字符串长度获取" class="headerlink" title="2.字符串长度获取"></a>2.字符串长度获取</h1><ol>
<li><p><code>strlen(name)</code></p>
</li>
<li><p>通过sizeof 进行计算（不好使）,不对</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char str[] &#x3D; &#123;&#39;E&#39;,&#39;a&#39;,&#39;s&#39;,&#39;t&#39;,&#39;r&#39;,&#39;i&#39;,&#39;s&#39;,&#39;e&#39;,&#39;\0&#39;,&#39;i&#39;,&#39;s&#39;&#125;;</span><br><span class="line">    </span><br><span class="line">&#x2F;&#x2F; 怎么获取长度？有一种方式计算（不好使）</span><br><span class="line">printf(&quot;length is %d&quot;,sizeof(str)&#x2F;sizeof(char)); &#x2F;&#x2F; 打印出来 11，实际结果应该是 8</span><br></pre></td></tr></table></figure>
</li>
<li><p>写一个方法读取字符串的长度</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int strlen_(char *str)&#123;</span><br><span class="line">    &#x2F;&#x2F; 怎么获取字符串的长度？ 不断读取字符，判断末尾 &#39;\0&#39;</span><br><span class="line"></span><br><span class="line">    int len &#x3D; 0;</span><br><span class="line">    while (*str !&#x3D; &#39;\0&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        str++;</span><br><span class="line">    &#125;</span><br><span class="line">    return len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="3-字符串与基本数据类型的转换"><a href="#3-字符串与基本数据类型的转换" class="headerlink" title="3.字符串与基本数据类型的转换"></a>3.字符串与基本数据类型的转换</h1><ul>
<li><code>atoi(num_str);</code> // <code>str 转 int</code>如果不能转换就是 0 ，后面如果有其他不是数字的就会被剔除 12xxx -&gt; 12</li>
<li><code>atof(num_str);</code> // <code>str 转 float</code> // 如果不能转换返回的是默认值 0.000000 </li>
<li><code>strtod(num_str, NULL);</code> // <code>str 转 double</code> // 如果不能转换返回的是默认值 0.000000 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>* num1 = <span class="string">"1"</span>; <span class="comment">// -&gt; int float double</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>* num_str1 = <span class="string">"12.0xxx"</span>;</span><br><span class="line">     <span class="keyword">int</span> number1 = atoi(num_str1); <span class="comment">// 如果不能转换就是 0 ，后面如果有其他不适数字的就会被剔除 12xxx -&gt; 12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"number1 is %d\n"</span>,number1);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span>* num_str2 = <span class="string">"12.5f"</span>;</span><br><span class="line">     <span class="keyword">float</span> number2 = atof(num_str2); <span class="comment">// 如果不能转换返回的是默认值 0.0000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"number2 is %f\n"</span>,number2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *num_str3 = <span class="string">"12.5xx"</span>;</span><br><span class="line">    <span class="keyword">double</span> number3 = strtod(num_str3,<span class="literal">NULL</span>);<span class="comment">// 如果不能转换就是 0.000 ，后面如果有其他不适数字的就会被剔除 12.5xxx -&gt; 12.5000</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"number3 is %lf\n"</span>,number3);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">number1 is 12</span><br><span class="line">number2 is 12.500000</span><br><span class="line">number3 is 12.500000</span><br></pre></td></tr></table></figure>

<h1 id="4-字符串的比较"><a href="#4-字符串的比较" class="headerlink" title="4.字符串的比较"></a>4.字符串的比较</h1><ul>
<li><code>int rc = strcmp(str1, str2);</code>  // <code>区分大小写</code>比较，rc == 0代表相等，rc &gt; 0 str1 比 str2 大</li>
<li><code>int rc = strcmpi(str1, str2);</code>  // <code>不区分大小写</code>比较，rc == 0代表相等，反之不相等</li>
<li><code>int rc = strncmp(str1, str2,7);</code> // <code>区分大小写</code>比较， count 代表的是比较字符串前几个是否相等</li>
<li><code>int rc = strnicmp(str1, str2,7);</code> // <code>不区分大小写</code>比较， count 代表的是比较字符串前几个是否相等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str1 = <span class="string">"Eastrise"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str2 = <span class="string">"eastrise"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大于小于等于</span></span><br><span class="line">    <span class="comment">// int rc = strcmp(str1,str2); // 区分大小写比较</span></span><br><span class="line">    <span class="comment">// int rc = _strcmpi(str1,str2); // 不区分大小写比较 c strcmpi c++ _strcmpi , android ndk strcasecmp;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较前几个</span></span><br><span class="line"><span class="comment">//     int rc = strncmp(str1,str2,7); // count 达标的是比较字符串前几个是否相等</span></span><br><span class="line">    <span class="keyword">int</span> rc = _strnicmp(str1,str2,<span class="number">6</span>); <span class="comment">// 不区分大小写的比较</span></span><br><span class="line">    <span class="keyword">if</span>(rc == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"相等"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"不相等"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="5-字符串查找，包含"><a href="#5-字符串查找，包含" class="headerlink" title="5.字符串查找，包含"></a>5.字符串查找，包含</h1><ul>
<li><p><code>char* pos = strstr(str, substr);</code> // 返回的是<code>字符串</code>第一次出现的位置（位置指针）, 如果没有找到返回的是空  </p>
<p>  获取位置: <code>int position = pos - str;</code></p>
</li>
<li><p><code>char* pos =  strchr(name,&#39;n&#39;);</code> // 返回的是<code>字符</code>第一次出现的位置（位置指针）, 如果没有找到返回的是空</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">"name not Eastrise"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *substr = <span class="string">"E"</span>;</span><br><span class="line">    <span class="keyword">char</span> *pos = <span class="built_in">strstr</span>(str, substr); <span class="comment">//  返回的是字符串第一次出现的位置（位置指针），如果没有找到返回的是空</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, pos); <span class="comment">// Eastrise;</span></span><br><span class="line">    <span class="comment">// 求一下位置 int 怎么办？ strstr</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">position</span> = pos - str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"第一次出现的位置是：%d\n"</span>, <span class="built_in">position</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含？ pos 是不是空就可以了</span></span><br><span class="line">    <span class="keyword">if</span> (pos)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"包含"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, <span class="string">"不包含"</span>);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Eastrise</span><br><span class="line">第一次出现的位置是：9</span><br><span class="line">包含</span><br></pre></td></tr></table></figure>

<h1 id="6-字符串复制和拼接"><a href="#6-字符串复制和拼接" class="headerlink" title="6.字符串复制和拼接"></a>6.字符串复制和拼接</h1><ul>
<li><strong><code>strcpy(dst, src);</code></strong> // 复制</li>
<li><strong><code>strcat(dst,src);</code></strong> // 拼接</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//strcopy; copy进来</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"eastrise"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str1 = <span class="string">" is"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// char* str1 = "is";</span></span><br><span class="line">    <span class="keyword">char</span> cpy[<span class="built_in">strlen</span>(str)+<span class="built_in">strlen</span>(str1)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// str 会 copy 到 cpy 里面</span></span><br><span class="line">    <span class="built_in">strcpy</span>(cpy,str);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,cpy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拼接</span></span><br><span class="line">    <span class="built_in">strcat</span>(cpy,str1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,cpy);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eastrise</span><br><span class="line">eastrise is</span><br></pre></td></tr></table></figure>

<h1 id="7-手写字符串截取"><a href="#7-手写字符串截取" class="headerlink" title="7.手写字符串截取"></a>7.手写字符串截取</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 截取</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">substr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span> start ,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 开辟一个字符串去存储我们的数据，开辟多大计算</span></span><br><span class="line">    <span class="comment">// char sub[end -start];</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">end</span> - start;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* sub = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*(len+<span class="number">1</span>));<span class="comment">// 记得+1，因为还有一个\0，在 NDK 一般会采用静态的数组存储 char sub[len]</span></span><br><span class="line">    <span class="comment">// malloc 一定要 free</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; len; i++)&#123;</span><br><span class="line">        sub[i] = str[start+i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记字符串结尾，否则 print 无法判断结尾</span></span><br><span class="line">    sub[len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,sub);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free(sub);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串的截取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"Eastrise is"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取第三个位置到第五个位置 3,5</span></span><br><span class="line">    <span class="keyword">char</span>* sub = substr(str,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,sub);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,sub);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要free ，因为你的 substr 有动态开辟内存，但是真正开发中并不会这么做，自己的方法尽量要自己处理好内存</span></span><br><span class="line">    <span class="built_in">free</span>(sub);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000B61440</span><br><span class="line">0000000000B61440</span><br><span class="line">Eastr</span><br></pre></td></tr></table></figure>

<h1 id="8-手写字符串小写转换"><a href="#8-手写字符串小写转换" class="headerlink" title="8.手写字符串小写转换"></a>8.手写字符串小写转换</h1><p>字符大小写转换</p>
<ul>
<li><code>tolower(ch);</code> // A-&gt;a</li>
<li><code>toupper(ch);</code> // a-&gt;A</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="comment">// dest 用来存放结果， 大小自己指定</span></span><br><span class="line"><span class="comment">// source 需要转换的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lower</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* source)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*source != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="comment">// 拿当前字符</span></span><br><span class="line">        <span class="keyword">char</span> ch = *source;</span><br><span class="line">        <span class="comment">// 转换完成后赋值给 dest</span></span><br><span class="line">        *dest = <span class="built_in">tolower</span>(ch); <span class="comment">// a-&gt;a A-&gt;a</span></span><br><span class="line">        source++;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记字符串结尾</span></span><br><span class="line">    *dest = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upper</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* source)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*source != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = *source;</span><br><span class="line">        *dest = <span class="built_in">toupper</span>(ch);</span><br><span class="line">        source ++;</span><br><span class="line">        dest ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *dest = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-手写字符串的替换"><a href="#9-手写字符串的替换" class="headerlink" title="9. 手写字符串的替换"></a>9. 手写字符串的替换</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">substr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">int</span> start, <span class="keyword">int</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开辟一个字符串去存储我们的数据，开辟多大计算</span></span><br><span class="line">    <span class="comment">// char sub[end -start];</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">end</span> - start;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *sub = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>) * (len + <span class="number">1</span>));<span class="comment">// 记得+1，因为还有一个\0，在 NDK 一般会采用静态的数组存储 char sub[len]</span></span><br><span class="line">    <span class="comment">// malloc 一定要 free</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        sub[i] = str[start + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记字符串结尾，否则 print 无法判断结尾</span></span><br><span class="line">    sub[len] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, sub);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free(sub);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sub;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">str_replace</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">const</span> <span class="keyword">char</span> *dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pos = <span class="built_in">strstr</span>(str, src);</span><br><span class="line">    <span class="keyword">if</span> (!pos)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt;(str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 计算新的数组大小</span></span><br><span class="line">    <span class="keyword">char</span> result[<span class="built_in">strlen</span>(str) - <span class="built_in">strlen</span>(src) + <span class="built_in">strlen</span>(dst)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截取替换</span></span><br><span class="line">    <span class="keyword">int</span> start_position = pos - str;</span><br><span class="line">    <span class="keyword">char</span> *start = substr(str, <span class="number">0</span>, start_position);</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">end</span> = substr(str, start_position + <span class="built_in">strlen</span>(src), <span class="built_in">strlen</span>(str));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拼接</span></span><br><span class="line">    <span class="keyword">if</span> (start)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(result, start);</span><br><span class="line">        <span class="built_in">strcat</span>(result, dst);</span><br><span class="line">        <span class="built_in">free</span>(start);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">end</span>)&#123;</span><br><span class="line">            <span class="built_in">strcat</span>(result, <span class="built_in">end</span>);</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">end</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(result, dst);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">end</span>)&#123;</span><br><span class="line">            <span class="built_in">strcat</span>(result, <span class="built_in">end</span>);</span><br><span class="line">            <span class="built_in">free</span>(<span class="built_in">end</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str_replace(result, src, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串替换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = str_replace(<span class="string">"aabbaabbfffaa"</span>, <span class="string">"aa"</span>, <span class="string">"ccc"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000006D1840</span><br><span class="line">00000000006D1860</span><br><span class="line">00000000006D1880</span><br><span class="line">00000000006D18A0</span><br><span class="line">cccbbcccbbfffccc</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础：02.指针运算和函数指针</title>
    <url>/02.C%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="1-二级指针和多级指针"><a href="#1-二级指针和多级指针" class="headerlink" title="1.二级指针和多级指针"></a>1.二级指针和多级指针</h1><p><img src="/images/02%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88.png" alt></p>
<p>二级指针：<strong>对一级指针取地址</strong></p>
<p>n级指针：<strong>对（n-1）指针取对峙</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">// int* 指针  &amp; 取地址</span></span><br><span class="line">    <span class="keyword">int</span>* p = &amp;num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>** s_p = &amp;p; <span class="comment">// 对一级指针取地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    int*** s_s_p = &amp;s_p; // 多级指针</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p 的值是：%p, s_p 的值是：%p\n"</span>,p,s_p);</span><br><span class="line">    <span class="comment">// p的地址是000000000060FE14 里面存的值为 12</span></span><br><span class="line">    <span class="comment">// s_p的地址是000000000060FE08 ，里面存的值是 000000000060FE14</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过二级指针获取值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"获取最终的值是：%d"</span>,**s_p);</span><br><span class="line"></span><br><span class="line">    getchar();<span class="comment">// 暂停</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-数组与数组指针"><a href="#2-数组与数组指针" class="headerlink" title="2.数组与数组指针"></a>2.数组与数组指针</h1><ul>
<li>数组 arr 的值 = arr 取地址的值  = arr[0]的地址的值（首地址）</li>
<li>数组 arr_p[i] == *(arr_p+i)</li>
</ul>
<p>数组指针指向的是数组的首地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 定义数组</span></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组，linux 就有问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">4</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for 循环在 c 和 c++ 中的正确写法</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看一种现象：arr 的值 = arr 取地址的值 , arr 地址的值 = arr[0]的地址的值（首地址）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"arr = %p\n"</span>,arr); <span class="comment">// arr = 000000000060FE00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;arr = %p\n"</span>,&amp;arr); <span class="comment">// &amp;arr = 000000000060FE00</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"&amp;arr[0] = %p\n"</span>,&amp;arr[<span class="number">0</span>]); <span class="comment">// &amp;arr[0] = 000000000060FE00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如何获取数组的指针</span></span><br><span class="line">    <span class="keyword">int</span>* arr_p = arr;<span class="comment">// 数组指针指向的是数组的首地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一系列的操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*arr_p); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对指针进行 ++</span></span><br><span class="line">    arr_p++;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*arr_p); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针再往后挪动两位</span></span><br><span class="line">    arr_p += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*arr_p); <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-采用指针遍历数据"><a href="#2-1-采用指针遍历数据" class="headerlink" title="2.1. 采用指针遍历数据"></a>2.1. 采用指针遍历数据</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arr_p = arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置%d的值是：%d\n"</span>,i,*(arr_p+i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">位置0的值是：1</span><br><span class="line">位置1的值是：2</span><br><span class="line">位置2的值是：3</span><br><span class="line">位置3的值是：4</span><br></pre></td></tr></table></figure>

<h2 id="2-2-采用指针循环为数组赋值"><a href="#2-2-采用指针循环为数组赋值" class="headerlink" title="2.2. 采用指针循环为数组赋值"></a>2.2. 采用指针循环为数组赋值</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">4</span>]; <span class="comment">// 指定数组[4]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arr_p = arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        *(arr_p + i) = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"位置%d的值是：%d\n"</span>,i,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">位置0的值是：0</span><br><span class="line">位置1的值是：1</span><br><span class="line">位置2的值是：2</span><br><span class="line">位置3的值是：3</span><br></pre></td></tr></table></figure>

<h2 id="2-3-数组指针的几种操作方式"><a href="#2-3-数组指针的几种操作方式" class="headerlink" title="2.3.数组指针的几种操作方式"></a>2.3.数组指针的几种操作方式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* arr_p = arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"使用arr_p[i]算出位置%d的值是：%d\n"</span>,i,arr_p[i]); <span class="comment">// == *(arr_p+i)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"使用*(arr + i)算出位置%d的值是：%d\n"</span>, i, *(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用arr_p[i]算出位置0的值是：1</span><br><span class="line">使用*(arr + i)算出位置0的值是：1</span><br><span class="line">使用arr_p[i]算出位置1的值是：2</span><br><span class="line">使用*(arr + i)算出位置1的值是：2</span><br><span class="line">使用arr_p[i]算出位置2的值是：3</span><br><span class="line">使用*(arr + i)算出位置2的值是：3</span><br><span class="line">使用arr_p[i]算出位置3的值是：4</span><br><span class="line">使用*(arr + i)算出位置3的值是：4</span><br></pre></td></tr></table></figure>

<h1 id="3-函数指针"><a href="#3-函数指针" class="headerlink" title="3.函数指针"></a>3.函数指针</h1><p>方法指针怎么定义？ <code>方法的返回（*方法的名称）（方法的参数)</code>,中间的 * 号可以省略</p>
<p><code>函数指针跟数组类似  数组是 arr = &amp;arr,  函数指针是 void(*method)(int,int) = &amp;method,&amp;可以不要</code></p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法指针， 传两个数</span><br><span class="line">void operator1(void(method)(int,int),int num1,int num2)&#123;</span><br><span class="line">    method(num1,num2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 加上*号也是可以的</span><br><span class="line">void operator1(void(*method)(int,int),int num1,int num2)&#123;</span><br><span class="line">    method(num1,num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_back</span><span class="params">(<span class="keyword">int</span> current,<span class="keyword">int</span> total)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"压缩的进度是：%d/%d\n"</span>,current,total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法 3 ，他是一个额外的文件了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>* file_name,<span class="keyword">void</span>(*call_back)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">    call_back(<span class="number">12</span>,<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>(*call)(<span class="keyword">int</span>,<span class="keyword">int</span>); <span class="comment">// 声明了一个函数</span></span><br><span class="line">    call = call_back; <span class="comment">// 给函数指针赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// call(1,2) 通过函数指针间接的调用call_back</span></span><br><span class="line">    compress(<span class="string">"1.png"</span>,call);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础：03.随机数和内存开辟</title>
    <url>/03.C%E5%9F%BA%E7%A1%80-%E9%9A%8F%E6%9C%BA%E6%95%B0%E5%92%8C%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F/</url>
    <content><![CDATA[<h1 id="1-生成随机数"><a href="#1-生成随机数" class="headerlink" title="1.生成随机数"></a>1.生成随机数</h1><ol>
<li>初始化随机发生器：<strong><code>srand(NULL)</code></strong>　<strong><code>srand((unsigned)time(NULL))</code></strong></li>
<li>调用函数：<strong><code>rand()</code></strong></li>
</ol>
<p>问题：<code>srand(NULL)</code>初始化发生器时每次随机数都是一样的。  </p>
<p>解决：<br>　　<br>　　初始化随机发生器时调用<strong><code>srand((unsigned)time(NULL))</code></strong>，每次发生器都是当前时间，所以随机数不会再一样了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    &#x2F;&#x2F; 可以随机但是每次运行，随机数都一致，解决的方法就是初始化发生器</span><br><span class="line">    &#x2F;&#x2F; 初始化随机发生器，每次发生器都是当前时间，啰嗦，实用场景，在 c 层生成秘钥（安全）</span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for(; i&lt; 10; i++)</span><br><span class="line">        printf(&quot;%d\n&quot;,rand() % 100);</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-重点，内存开辟"><a href="#2-重点，内存开辟" class="headerlink" title="2.重点，内存开辟"></a>2.重点，内存开辟</h1><ul>
<li>c 有分区，四驱模型，栈，堆</li>
<li>栈(<strong>是一块连续的内存的区域</strong>)：占用内存空间最大值 2M ，开辟内存的方式是静态内存开辟 int arr[10<em>1024</em>1024]，方法结束会自动回收</li>
<li>堆(是用链表来存储的空闲内存地址的，<strong>是不连续的</strong>)：占用内存空间最大值 80% ，开辟内存的方式是动态内存开辟 ，不会自动回收必须手动回收（内存不再使用的时候一定要手动回收）</li>
</ul>
<p>静态内存开辟</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">staticlloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>]; <span class="comment">// 静态开辟 0.8M</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        arr[i] = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,%p\n"</span>,*(arr+i),arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态内存开辟</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Stack overflow 栈溢出， 如何判断一块内存中有没有写入数据， 判 NULL? ，判越界</span></span><br><span class="line">    <span class="comment">// int arr[10*1024*1024]; // 占用的内存是多少？ 大小？ 10M数组大小， int 占用4字节，40M空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c 有分区，四驱模型，栈，堆</span></span><br><span class="line">    <span class="comment">// 栈： 占用内存空间最大值 2M, 开辟内存的方式是静态内存开辟 int arr[10*1024*1024], 方法结束会自动回收</span></span><br><span class="line">    <span class="comment">// 堆： 占用内存空间最大值 80%, 开内存的方式是动态内存开辟 不会自动回收必须手动回收（内存不再使用的时候一定要手动回收）</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">        staticlloc();<span class="comment">// 不会内存溢出</span></span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-动态内存开辟"><a href="#3-动态内存开辟" class="headerlink" title="3.动态内存开辟"></a>3.动态内存开辟</h1><ol>
<li>开辟内存：<code>malloc</code>　<strong><code>int* arr = (int*)malloc(sizeof(int)*num);</code></strong></li>
<li>释放内存： <code>free</code>　　<strong><code>free(arr)</code></strong> 不要反复去释放，那块地址一旦被释放，就有可能会被新的应用占用，不要去再次释放。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dynamiclloc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 40M</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二个重要的方法,手动释放 free , 释放arr 这一块内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态内存开辟</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// int arr[1 * 1024 * 1024];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">        dynamiclloc();</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/03%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%BC%80%E8%BE%9F.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 假设我们现在需要接收用户所输入的数，然后进行排序</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入数的个数："</span>);</span><br><span class="line">    <span class="comment">// 获取用户输入的值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个数组来存放用户的数据</span></span><br><span class="line">    <span class="comment">// int arr[num]; 静态开辟，内存大小不能改变。</span></span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for 循环接收</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> print_num;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; num; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"请输入第%d个的值："</span>,i);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;print_num);</span><br><span class="line">        arr[i] = print_num; <span class="comment">// arr[i] = *(arr+i)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d,%p\n"</span>,*(arr+i),arr + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序 堆排序（4个小时），快排序</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入数的个数：3</span><br><span class="line">请输入第0个的值：2</span><br><span class="line">2,0000000000AE1440</span><br><span class="line">请输入第1个的值：5</span><br><span class="line">5,0000000000AE1444</span><br><span class="line">请输入第2个的值：10</span><br><span class="line">10,0000000000AE1448</span><br></pre></td></tr></table></figure>


<h1 id="4-改变内存空间大小"><a href="#4-改变内存空间大小" class="headerlink" title="4.改变内存空间大小"></a>4.改变内存空间大小</h1><ul>
<li><code>realloc</code>：<strong><code>int* new_arr = (int*)realloc(arr, sizeof(int)*(num+new_num));</code></strong>    </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 改变内存空间大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入数的个数："</span>);</span><br><span class="line">    <span class="comment">// 获取用户输入的值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5 个值</span></span><br><span class="line">    <span class="keyword">int</span>* arr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*num);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; num; i++)&#123;</span><br><span class="line">        arr[i] = i; <span class="comment">// arr[i] == *(arr + i);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开辟内存的指针：%p\n"</span>,arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再加点内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的个数："</span>);</span><br><span class="line">    <span class="comment">// 获取用户新输入的值</span></span><br><span class="line">    <span class="keyword">int</span> new_num;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;new_num); <span class="comment">// 5</span></span><br><span class="line">    <span class="comment">// 原来那块内存的指针，总的大小（原来的大小+新的大小）</span></span><br><span class="line">    <span class="keyword">int</span>* new_arr = (<span class="keyword">int</span>*)<span class="built_in">realloc</span>(arr,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(num+new_num));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(new_arr)&#123; <span class="comment">// = if(new_arr != NULL)</span></span><br><span class="line">        i = num;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; (num+new_num); i++)&#123;</span><br><span class="line">            arr[i] = i; <span class="comment">// arr[i] == *(arr + i);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"新开辟内存的指针：%p\n"</span>,new_arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印数组</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; (num + new_num); i++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d,%p\n"</span>,*(arr + i),arr + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(new_arr)&#123;</span><br><span class="line">        <span class="comment">// 如果成功了，只需要释放新的地址就行</span></span><br><span class="line">        <span class="built_in">free</span>(new_arr);</span><br><span class="line">        new_arr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果没成功，释放原来的内存</span></span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要反复去释放，那块地址一旦被释放，就有可能会被新的应用占用，不要去再次释放。</span></span><br><span class="line">    <span class="comment">// free(new_arr);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作 C/C++ 精通</span></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入数的个数：2</span><br><span class="line">开辟内存的指针：0000000000B81440</span><br><span class="line">请输入新增的个数：1</span><br><span class="line">新开辟内存的指针：0000000000B81440</span><br><span class="line">0,0000000000B81440</span><br><span class="line">1,0000000000B81444</span><br><span class="line">2,0000000000B81448</span><br></pre></td></tr></table></figure>

<p><img src="/images/03realloc.png" alt></p>
]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI:03.Android共享内存的序列化过程</title>
    <url>/09.JNI%E5%9F%BA%E7%A1%80-Android%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>代码请看：<a href="https://github.com/EastUp/NDKPractice/tree/master/jni09" target="_blank" rel="noopener">NDKPractice项目的jni09</a></strong></p>
<h1 id="1-面试题："><a href="#1-面试题：" class="headerlink" title="1. 面试题："></a>1. 面试题：</h1><ol>
<li>进程间的通信方式有哪些</li>
<li>binder 和 socket 通信的区别有哪些 <ul>
<li>从传输性能上说 ： <code>Socket</code>,<code>传输效率低</code>，<code>开销大</code>，主要用在<code>跨网络的进程间通信</code>;消息队列和管道采用存储-转发方式.数据先从发送方拷贝到内存开辟的缓存区中，<br>然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。<code>Binder</code>只需要拷贝一次（因为内存映射）</li>
<li>从安全性上来说： Socket 没有任何安全措施，完全依赖上层协议来确保。<code>Binder</code> 通过包名和类名在<code>serviceManager</code>中进行查找，<code>Binder.getCallingUID();</code> 就能取得对方UID来检验它的身分等。还可以进行 <code>checkCallingPermission()</code>等</li>
<li>总结:（binder 共享内存，Soket需要copy内存） Socket 远程，本地低速（zygote）</li>
</ul>
</li>
<li>Android 为什么在大部分场景下用 Binder 进行进程间通信 (效率高，开销小，安全性高)</li>
<li>Serializable 和 Parcelable 之间的区别<br> Serializable ：主要是IO操作，消耗较大 ，好处就是 <code>简单</code>。<strong>存储设置中或将对象序列化后通过网络传输时使用</strong><br> Parcelable ：因为原理是<code>共享内存</code>,所以效率高，内存消耗小。<strong>应用程序在内存间数据传输时推荐使用</strong></li>
<li>Parcelable 序列化和反序列化的具体过程</li>
</ol>
<h1 id="2-重点：-Native-构建对象如何与-Java-层对应"><a href="#2-重点：-Native-构建对象如何与-Java-层对应" class="headerlink" title="2. 重点： Native 构建对象如何与 Java 层对应"></a>2. <font color="red">重点：</font> Native 构建对象如何与 Java 层对应</h1><p><img src="/images/09%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.png" alt></p>
<h2 id="2-1-opencv-Mat-源码阅读"><a href="#2-1-opencv-Mat-源码阅读" class="headerlink" title="2.1 opencv Mat 源码阅读"></a>2.1 opencv Mat 源码阅读</h2><p>Java -&gt; Mat.java = C++ Mat.cpp 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Mat &#123;&#x2F;&#x2F; Java 对象</span><br><span class="line">    &#x2F;&#x2F; </span><br><span class="line"></span><br><span class="line">    public final long nativeObj;</span><br><span class="line">    public Mat()&#123;</span><br><span class="line">        nativeObj &#x3D; n_Mat(rows, cols, type);&#x2F;&#x2F; c++ 创建一个对象，返回的是 long 类型（c++ 对象的指针地址）</span><br><span class="line">    &#125;</span><br><span class="line">    public static native long n_Mat(int rows, int cols, int type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c 层 构建的对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT jlong JNICALL Java_org_opencv_core_Mat_n_1Mat__DDI</span><br><span class="line">  (JNIEnv* env, jclass, jdouble size_width, jdouble size_height, jint type)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> method_name[] = <span class="string">"Mat::n_1Mat__DDI()"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LOGD(<span class="string">"%s"</span>, method_name);</span><br><span class="line">        <span class="function">Size <span class="title">size</span><span class="params">((<span class="keyword">int</span>)size_width, (<span class="keyword">int</span>)size_height)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> (jlong) <span class="keyword">new</span> Mat( <span class="built_in">size</span>, type );</span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e) &#123;</span><br><span class="line">        throwJavaException(env, &amp;e, method_name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        throwJavaException(env, <span class="number">0</span>, method_name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Parcel-java-的源码"><a href="#2-2-Parcel-java-的源码" class="headerlink" title="2.2 Parcel.java 的源码"></a>2.2 Parcel.java 的源码</h2><p><img src="/images/09Parcel%E5%8E%9F%E7%90%86.png" alt></p>
<p>java层 创建对象调用 c 层的创建对象并获取到 c 层的指针（地址）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void init(long nativePtr) &#123;</span><br><span class="line">    if (nativePtr !&#x3D; 0) &#123;</span><br><span class="line">        mNativePtr &#x3D; nativePtr;</span><br><span class="line">        mOwnsNativeParcelObject &#x3D; false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 这里获取 c 层 parcel 对象的 指针（地址）</span><br><span class="line">        mNativePtr &#x3D; nativeCreate();</span><br><span class="line">        mOwnsNativeParcelObject &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c 层创建 Parcel 对象</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_Parcel_create</span><span class="params">(JNIEnv* env, jclass clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> Parcel();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(parcel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java 层调用 c 层写入Int</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; nativePtr 指针地址</span><br><span class="line">private static native void nativeWriteInt(long nativePtr, int val);</span><br></pre></td></tr></table></figure>

<p>c 层的写入： </p>
<ul>
<li>mData : 共享内存的首地址</li>
<li>mDataPos：内存首地址的当前逻动位置</li>
<li>mDataCapacity：共享内存的总大小</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">status_t</span> <span class="title">Parcel</span>:</span>:writeAligned(T val) &#123;</span><br><span class="line">    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(<span class="keyword">sizeof</span>(T)) == <span class="keyword">sizeof</span>(T));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mDataPos+<span class="keyword">sizeof</span>(val)) &lt;= mDataCapacity) &#123;</span><br><span class="line">restart_write:</span><br><span class="line">        *<span class="keyword">reinterpret_cast</span>&lt;T*&gt;(mData+mDataPos) = val;</span><br><span class="line">        <span class="keyword">return</span> finishWrite(<span class="keyword">sizeof</span>(val));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">status_t</span> err = growData(<span class="keyword">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">if</span> (err == NO_ERROR) <span class="keyword">goto</span> restart_write;</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-手写个Native层的Parcel-cpp，便于理解"><a href="#3-手写个Native层的Parcel-cpp，便于理解" class="headerlink" title="3.手写个Native层的Parcel.cpp，便于理解"></a>3.手写个Native层的Parcel.cpp，便于理解</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_east_jni09_Parcel.h"</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_east_jni09_MainActivity_stringFromJNI</span><br><span class="line">(JNIEnv* env,jobject jobj)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体 == C++ 中对象 Parcel.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parcel</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* mData; <span class="comment">// char 1 共享内存的首地址</span></span><br><span class="line">    <span class="keyword">int</span> mDataPos = <span class="number">0</span>; <span class="comment">// 必须初始化 结构体没有默认值，除非在 &#125; 后跟上几个默认的子项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Parcel()&#123;</span><br><span class="line">        mData = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(<span class="built_in">malloc</span>(<span class="number">1024</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeInt</span><span class="params">(jint value)</span> </span>&#123;</span><br><span class="line">        *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(mData+mDataPos) = value; <span class="comment">// 0 ,4</span></span><br><span class="line">        mDataPos += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDataPosition</span><span class="params">(jint value)</span> </span>&#123;</span><br><span class="line">        mDataPos = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">jint <span class="title">readInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int</span>*&gt;(mData+mDataPos);</span><br><span class="line">        mDataPos += <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jlong JNICALL Java_com_east_jni09_Parcel_nativeCreate</span><br><span class="line">        (JNIEnv * env, jobject jobj)&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">new</span> Parcel();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(parcel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni09_Parcel_nativeWriteInt</span><br><span class="line">        (JNIEnv * env, jobject jobj,jlong nativePtr,jint value)&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    parcel -&gt; writeInt(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni09_Parcel_nativeSetDataPosition</span><br><span class="line">        (JNIEnv * env, jobject jobj,jlong nativePtr,jint value)&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    parcel -&gt; setDataPosition(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span>  JNIEXPORT jint JNICALL Java_com_east_jni09_Parcel_nativeReadInt</span><br><span class="line">        (JNIEnv * env, jobject jobj,jlong nativePtr)&#123;</span><br><span class="line">    Parcel* parcel = <span class="keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);</span><br><span class="line">    <span class="keyword">return</span> parcel-&gt;readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>java 层调用：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parcel = Parcel()</span><br><span class="line">       parcel.writeInt(<span class="number">12</span>)</span><br><span class="line">       parcel.writeInt(<span class="number">24</span>)</span><br><span class="line"></span><br><span class="line">       parcel.setDataPosition(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">       <span class="keyword">val</span> number1 = parcel.readInt()</span><br><span class="line">       <span class="keyword">val</span> number2 = parcel.readInt()</span><br><span class="line"></span><br><span class="line">       Log.e(<span class="string">"TAG"</span>,<span class="string">"number1 = <span class="variable">$number1</span> , number2 = <span class="variable">$number2</span>"</span>) <span class="comment">// 12,24</span></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>JNI学习</tag>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI:01.JNIEnv 的实现原理</title>
    <url>/07.JNI%E5%9F%BA%E7%A1%80-JNIEnv%20%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p><strong>代码请看：<a href="https://github.com/EastUp/JavaJNITest/tree/master/src/com/east/jni07" target="_blank" rel="noopener">07.JNI基础-JNI Env 实现原理</a></strong></p>
<p><code>-&gt; 调用的情况下必须是一级指针 *取值</code></p>
<ul>
<li><code>env-&gt;GetXXFieldID</code>：获取字段的ID</li>
<li><code>env-&gt;GetXXField</code>：获取字段上的值,返回XX类型</li>
<li><code>env-&gt;GetMethodID</code>:获取方法的ID</li>
<li><code>env-&gt;CallXXMethod</code>：调用方法。返回XX类型</li>
</ul>
<h1 id="1-JNI-的一般开发流程："><a href="#1-JNI-的一般开发流程：" class="headerlink" title="1. JNI 的一般开发流程："></a>1. JNI 的一般开发流程：</h1><ol>
<li>定义好本地的 native 方法,生成<code>.class</code>文件。</li>
<li>在存放<code>原文件 .java</code>的包名文件夹的最前面（<code>src</code>文件夹下）使用javah 命令生成 .h 头文件  <code>javah -d jni -jni com.east.NdkSample</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用法:</span><br><span class="line">  javah [options] &lt;classes&gt;</span><br><span class="line">其中, [options] 包括:</span><br><span class="line">  -o &lt;file&gt;                输出文件 (只能使用 -d 或 -o 之一)</span><br><span class="line">  -d &lt;dir&gt;                 输出目录</span><br><span class="line">  -v  -verbose             启用详细输出</span><br><span class="line">  -h  --help  -?           输出此消息</span><br><span class="line">  -version                 输出版本信息</span><br><span class="line">  -jni                     生成 JNI 样式的标头文件 (默认值)</span><br><span class="line">  -force                   始终写入输出文件</span><br><span class="line">  -classpath &lt;path&gt;        从中加载类的路径</span><br><span class="line">  -cp &lt;path&gt;               从中加载类的路径</span><br><span class="line">  -bootclasspath &lt;path&gt;    从中加载引导类的路径</span><br><span class="line">&lt;classes&gt; 是使用其全限定名称指定的</span><br><span class="line">(例如, java.lang.Object)。</span><br></pre></td></tr></table></figure></li>
<li>拷贝 <code>xxx.h</code>、<code>jni_md.h</code>、<code>jni.h</code> 到 VS 的工程目录并添加依赖进来。(jni_md.h和jni.h在java安装目录下搜索即可查找到)</li>
<li>实现我们头文件中的 native 方法</li>
<li>VS生成解决方案即可生成 <code>.dll 动态库</code>，java 引入 dll 动态库运行即可</li>
</ol>
<p>java 中加载动态库：</p>
<ul>
<li><code>System.loadLibrary</code> ：android 加载apk中的libs目录下 .so 库</li>
<li><code>System.load</code> : 加载一个具体路径上的 .so 库，去服务器上下载再进行加载(data/data)</li>
</ul>
<h1 id="2-详解-h-文件和实现文件"><a href="#2-详解-h-文件和实现文件" class="headerlink" title="2. 详解 .h 文件和实现文件"></a>2. 详解 .h 文件和实现文件</h1><p>com_east_NdkSample.h：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"jni.h"</span></span></span><br><span class="line"><span class="comment">/* Header for class com_east_NdkSample */</span></span><br><span class="line"><span class="comment">// 用来打一个标记， c 在编译的时候会把头文件 copy 到你引入的地方，不管是重复引用还是相互引用都只会 copy 一次</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_east_jni07_NdkSample</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_east_jni07_NdkSample</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus <span class="comment">// 相当于 if 语句 c++</span></span></span><br><span class="line"><span class="comment">// 不管是 c 还是 c++ 统一都是采用 c 的编译方法，因为在 c 里面是不允许函数重载的，但是在 c++ 里面可以</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_east_jni07_NdkSample</span></span><br><span class="line"><span class="comment"> * Method:    getSingnaturePassword</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_east_jni07_NdkSample_getSingnaturePassword</span><br><span class="line">  (JNIEnv *, jclass);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>Simple.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现我们的 native 方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"com_east_NdkSample.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// JNIEXPORT： JNI 一个关键字，不能少（编译能通过），标记为该方法可以被外部调用</span></span><br><span class="line"><span class="comment">// jstring：代表 java 中的 String</span></span><br><span class="line"><span class="comment">// JNICALL：也是一个关键字，可以少的 jni call</span></span><br><span class="line"><span class="comment">// jobject： 非静态方法时 java 传递下来的类对象，就是本项目中 NdkSample java 对象</span></span><br><span class="line"><span class="comment">// jclass：静态方法时，java 传递下来的 class 对象，就是本项目中的 NdkSample.class</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_east_NdkSample_getSingnaturePassword</span><br><span class="line">        (JNIEnv * env, jclass clz)&#123;</span><br><span class="line">    <span class="comment">// C 中 typedef const struct JNINativeInterface* JNIEnv; 已经是一个结构体指针了</span></span><br><span class="line">    <span class="comment">// C++ 中 typedef _JNIEnv JNIEnv; // 就是一个结构体</span></span><br><span class="line">    <span class="comment">// JNIEnv * 其实已经是一个二级指针了，所以 -&gt; 调用的情况下必须是一级指针 *取值</span></span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"eastrise"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-JNIEnv-的实现原理"><a href="#3-JNIEnv-的实现原理" class="headerlink" title="3. JNIEnv 的实现原理"></a>3. JNIEnv 的实现原理</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus) <span class="comment">// 如果是C++文件 </span></span></span><br><span class="line"><span class="keyword">typedef</span> _JNIEnv JNIEnv;    JNIEnv 就是结构体 _JNIEnv</span><br><span class="line"><span class="keyword">typedef</span> _JavaVM JavaVM;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface</span>* <span class="title">JNIEnv</span>;</span> <span class="comment">// 如果是C文件 JNIEnv 是JNINativeInterface的一级指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNIInvokeInterface</span>* <span class="title">JavaVM</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>看下 <code>JNINativeInterface</code> 的部分代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>*       reserved0;</span><br><span class="line">    <span class="keyword">void</span>*       reserved1;</span><br><span class="line">    <span class="keyword">void</span>*       reserved2;</span><br><span class="line">    <span class="keyword">void</span>*       reserved3;</span><br><span class="line"></span><br><span class="line">    jint        (*GetVersion)(JNIEnv *); <span class="comment">// 函数指针</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下 <code>_JNIEnv</code> 的部分代码（调用的还是 <code>JNINativeInterface</code> 的方法）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">JNIEnv</span> &#123;</span></span><br><span class="line">    <span class="comment">/* do not rename this; it does not seem to be entirely opaque */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">JNINativeInterface</span>* <span class="title">functions</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cplusplus) <span class="comment">// 如果是 C++ ，调用的还是 JNINativeInterface 的方法</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function">jint <span class="title">GetVersion</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> functions-&gt;GetVersion(<span class="keyword">this</span>); &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-C-中访问和修改-java-的属性和方法"><a href="#4-C-中访问和修改-java-的属性和方法" class="headerlink" title="4. C 中访问和修改 java 的属性和方法"></a>4. C 中访问和修改 java 的属性和方法</h1><ul>
<li><code>env-&gt;GetXXFieldID</code>：获取字段的ID</li>
<li><code>env-&gt;GetXXField</code>：获取字段上的值,返回XX类型</li>
</ul>
<p>进入类编译后的<code>.class</code>文件，<strong>全包名路径</strong>的目录下。</p>
<p>获取类中：属性和方法签名：<code>javap -p -s com.east.jni07.NdkSample</code></p>
<ul>
<li><code>-s</code>:输出内部类型签名</li>
<li><code>-p</code>:显示所有类和成员</li>
</ul>
<h2 id="4-1-C中修改-java-的普通属性"><a href="#4-1-C中修改-java-的普通属性" class="headerlink" title="4.1 C中修改 java 的普通属性"></a>4.1 C中修改 java 的普通属性</h2><p>java 中的属性：<code>public String name = &quot;Eastrise&quot;;</code></p>
<p>java 中的本地方法：<code>public native void changeName();</code></p>
<p>c中的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_NdkSample1_changeName</span><br><span class="line">(JNIEnv * env, jobject jobj)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 获取 jclass</span></span><br><span class="line">	jclass j_clz = (*env)-&gt;GetObjectClass(env,jobj);</span><br><span class="line">	<span class="comment">// 2. 获取 jfieldID</span></span><br><span class="line">	<span class="comment">// 获取 jfieldId (JNIEnv *env, jclass clazz, const char *name, const char *sig)</span></span><br><span class="line">	<span class="comment">// name 获取哪个属性的属性名 ,sig 属性的签名</span></span><br><span class="line">	jfieldID j_fid = (*env)-&gt;GetFieldID(env, j_clz, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">	<span class="comment">// 1. 获取 name 的属性值</span></span><br><span class="line">	jstring j_str = (*env)-&gt;GetObjectField(env,jobj,j_fid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印字符串 jstring -&gt; c_str</span></span><br><span class="line">	<span class="keyword">char</span>* c_str = (*env)-&gt;GetStringUTFChars(env, j_str, <span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"name is %s"</span>, c_str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改成 Jack</span></span><br><span class="line">	jstring jack_name = (*env)-&gt;NewStringUTF(env,<span class="string">"Jack"</span>);</span><br><span class="line">	(*env)-&gt;SetObjectField(env,jobj,j_fid,jack_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-C中修改-java-的静态属性"><a href="#4-2-C中修改-java-的静态属性" class="headerlink" title="4.2 C中修改 java 的静态属性"></a>4.2 C中修改 java 的静态属性</h2><p>java 中的属性：<code>public static int age = 24;</code></p>
<p>java 中的本地静态方法：<code>public static native void changeAge();</code></p>
<p>c中的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态方法参数会变为 jclass 代表 NdkSample1.class</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_NdkSample1_changeAge</span><br><span class="line">(JNIEnv * env, jclass jcls)&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 获取 jfieldID</span></span><br><span class="line">	jfieldID j_fid = (*env)-&gt;GetStaticFieldID(env,jcls,<span class="string">"age"</span>,<span class="string">"I"</span>);</span><br><span class="line">	<span class="comment">// 1. 获取 age 的值 Static 获取静态的</span></span><br><span class="line">	jint age = (*env)-&gt;GetStaticIntField(env,jcls,j_fid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// jnit == int</span></span><br><span class="line">	age += <span class="number">12</span>;</span><br><span class="line">	</span><br><span class="line">	(*env)-&gt;SetStaticIntField(env,jcls,j_fid,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-c-调用-java-方法"><a href="#4-3-c-调用-java-方法" class="headerlink" title="4.3 c 调用 java 方法"></a>4.3 c 调用 java 方法</h2><ul>
<li><code>env-&gt;GetMethodID</code>:获取方法的ID</li>
<li><code>env-&gt;CallXXMethod</code>：调用方法。返回XX类型</li>
</ul>
<p>java 中的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> number1+number2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c中的方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c 调用 java 层普通方法</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_NdkSample1_callAddMethod</span><br><span class="line">(JNIEnv * env, jobject jobj)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 获取 jclass</span></span><br><span class="line">	jclass jcls = (*env)-&gt;GetObjectClass(env,jobj);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 获取 jmethodID</span></span><br><span class="line">	jmethodID j_mid = (*env)-&gt;GetMethodID(env,jcls,<span class="string">"add"</span>,<span class="string">"(II)I"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 调用 java 方法</span></span><br><span class="line">	jint sum = (*env)-&gt;CallObjectMethod(env,jobj,j_mid,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sum = %d"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>JNI学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI:04.缓存策略和异常处理</title>
    <url>/10.JNI%E5%9F%BA%E7%A1%80-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p><strong>代码请看：<a href="https://github.com/EastUp/JavaJNITest/tree/master/src/com/east/jni10" target="_blank" rel="noopener">10.JNI基础-缓存策略和异常处理</a></strong></p>
<h1 id="1-数组排序："><a href="#1-数组排序：" class="headerlink" title="1. 数组排序："></a>1. 数组排序：</h1><ul>
<li><code>void qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, int(*_PtFuncCompare)(const void *, const void *))</code> ：c中的排序方法</li>
<li><code>jxxx* = env-&gt;GetXXArrayElements(env,jarray,NULL);</code>：将java层的数组转换成c层的数组（指针）。</li>
<li><code>(*env)-&gt;ReleaseXXArrayElements(env, jarray, xxArray, JNI_OK);</code>：同步数组的数据给 java 数组 xxArray 并不是 jarray。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; JNI_OK &#x3D;&#x3D; 0:：既要同步数据给 jarray， 又要释放 intArray</span><br><span class="line">&#x2F;&#x2F; JNI_COMMIT &#x3D;&#x3D; 1：会同步数据给 jarray, 但是不会释放 intArray</span><br><span class="line">&#x2F;&#x2F; JNI_ABORT &#x3D;&#x3D; 2：不会同步数据给 jarray, 但是会释放 intArray</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>native层：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. 定义一个 compare 的方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>* number1, <span class="keyword">const</span> <span class="keyword">int</span>* number2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> *number1 - *number2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组排序</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_sort</span><br><span class="line">(JNIEnv* env, jclass jclz, jintArray jarray)&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 获取 jintArray 的首地址</span></span><br><span class="line">	jint* intArray = (*env)-&gt;GetIntArrayElements(env,jarray,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 获取数组的长度</span></span><br><span class="line">	<span class="keyword">int</span> length = (*env)-&gt;GetArrayLength(env,jarray);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 对 jarray 进行排序</span></span><br><span class="line">	<span class="comment">// void qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, int(*_PtFuncCompare)(const void *, const void *))</span></span><br><span class="line">	<span class="comment">// 第一个参数：void* 数组的首地址</span></span><br><span class="line">	<span class="comment">// 第二个参数：数组的长度</span></span><br><span class="line">	<span class="comment">// 第三个参数：数组元素数据类型的大小</span></span><br><span class="line">	<span class="comment">// 第四个参数：数组的一个比较方法指针（Comparable）</span></span><br><span class="line">	qsort(intArray,length,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),compare);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 同步数组的数据给 java 数组 intArray 并不是 jarray， 可以简单理解为 copy</span></span><br><span class="line">	<span class="comment">// JNI_OK == 0:：既要同步数据给 jarray， 又要释放 intArray</span></span><br><span class="line">	<span class="comment">// JNI_COMMIT == 1：会同步数据给 jarray, 但是不会释放 intArray</span></span><br><span class="line">	<span class="comment">// JNI_ABORT == 2：不会同步数据给 jarray, 但是会释放 intArray</span></span><br><span class="line"></span><br><span class="line">	(*env)-&gt;ReleaseIntArrayElements(env, jarray, intArray, JNI_OK);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-局部引用和全局引用"><a href="#2-局部引用和全局引用" class="headerlink" title="2. 局部引用和全局引用"></a>2. 局部引用和全局引用</h1><ul>
<li><strong><code>jobject j_str = (*env)-&gt;NewObject(env,str_clz,jmid)</code></strong>：局部引用对象生成。</li>
<li><strong><code>(*env)-&gt;DeleteLocalRef(env,j_str);</code></strong> ：删除局部引用</li>
<li><strong><code>jstring globalStr =(*env)-&gt;NewGlobalRef(env,value);</code></strong> :创建全局引用</li>
<li><strong>(*env)-&gt;DeleteGlobalRef(env,globalStr)</strong>：删除全局引用</li>
</ul>
<h2 id="2-1-局部引用"><a href="#2-1-局部引用" class="headerlink" title="2.1. 局部引用"></a>2.1. 局部引用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 局部引用</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_localRef</span><br><span class="line">(JNIEnv * env, jclass jclz)&#123;</span><br><span class="line">	<span class="comment">// 在 native 层构建的 Java 对象，不用了应该怎么管理（应该进行回收删除）</span></span><br><span class="line">	<span class="comment">// native 层开辟的内存由谁管理，你能开辟多大</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 字符串截取，String 对象</span></span><br><span class="line">	jclass str_clz = (*env)-&gt;FindClass(env,<span class="string">"java/lang/String"</span>);</span><br><span class="line">	jmethodID jmid = (*env)-&gt;GetMethodID(env, str_clz, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">	jobject j_str = (*env)-&gt;NewObject(env,str_clz,jmid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 还有 100 行代码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// jobject 不要再使用了，要回收 javaGC 的源码</span></span><br><span class="line">	(*env)-&gt;DeleteLocalRef(env,j_str);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除了就不能再使用了，C 和 C++ 都需要自己释放内存（静态开辟的不需要，动态开辟的需要）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-全局引用"><a href="#2-2-全局引用" class="headerlink" title="2.2 全局引用"></a>2.2 全局引用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 全局引用</span></span><br><span class="line">jstring globalStr;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_saveGlobalRef</span><br><span class="line">(JNIEnv * env, jclass j_clz, jstring value)&#123;</span><br><span class="line">	<span class="comment">// 保存全局引用，其它方法需要用到</span></span><br><span class="line">	globalStr = (*env)-&gt;NewGlobalRef(env,value);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// NewWeakGlobalRef （java 中的软引用很像）无法保证对象不为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_east_jni10_Sample_getGlobalRef</span><br><span class="line">(JNIEnv * env, jclass j_clz)&#123;</span><br><span class="line">	<span class="keyword">return</span> globalStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除全局引用</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_deleteGlobalRef</span><br><span class="line">(JNIEnv * env, jclass j_clz)&#123;</span><br><span class="line">	(*env)-&gt;DeleteGlobalRef(env,globalStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-缓存策略-static-native层有一大堆方法需要去获取-name-属性-初始化全局静态缓存"><a href="#3-缓存策略-static-native层有一大堆方法需要去获取-name-属性-初始化全局静态缓存" class="headerlink" title="3. 缓存策略 static, native层有一大堆方法需要去获取 name 属性 // 初始化全局静态缓存"></a>3. 缓存策略 static, native层有一大堆方法需要去获取 name 属性 // 初始化全局静态缓存</h1><h2 id="3-1-局部静态缓存"><a href="#3-1-局部静态缓存" class="headerlink" title="3.1  局部静态缓存"></a>3.1  局部静态缓存</h2><p>局部静态缓存：即使方法被重复调用也不会反复的给<code>static</code>修饰的字段赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_staticLocalCache</span><br><span class="line">(JNIEnv * env, jclass j_clz, jstring value)&#123;</span><br><span class="line">	<span class="comment">// name 属性，赋值操作</span></span><br><span class="line">	<span class="keyword">static</span> jfieldID jfid = <span class="literal">NULL</span>; <span class="comment">// 局部静态缓存，即使方法被重复调用也不会反复的去获取 jfieldID</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (jfid)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"fieldID is not null\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		jfid = (*env)-&gt;GetStaticFieldID(env, j_clz, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);<span class="comment">// 如果没有静态缓存 这个方法会被多次调用，会去反复的获取 jfieldID</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	(*env)-&gt;SetStaticObjectField(env,j_clz,jfid,value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-全局静态缓存"><a href="#3-2-全局静态缓存" class="headerlink" title="3.2 全局静态缓存"></a>3.2 全局静态缓存</h2><p>全局静态缓存：即使方法被重复调用也不会反复的给<code>static</code>修饰的字段赋值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局静态缓存</span></span><br><span class="line"><span class="keyword">static</span> jfieldID f_name_id = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name1_id = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">static</span> jfieldID f_name2_id = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_staticLocalCache</span><br><span class="line">(JNIEnv * env, jclass j_clz, jstring value)&#123;</span><br><span class="line">	<span class="comment">// 因为是静态缓存，所以这个方法被反复调用，也不会反复的去获取 jfieldID</span></span><br><span class="line">	(*env)-&gt;SetStaticObjectField(env,j_clz,f_name_id,value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_initStaticCache</span><br><span class="line">(JNIEnv *env, jclass j_clz)&#123;</span><br><span class="line">	<span class="comment">// 初始化全局静态缓存</span></span><br><span class="line">	f_name_id = (*env)-&gt;GetStaticFieldID(env, j_clz, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">	f_name1_id = (*env)-&gt;GetStaticFieldID(env, j_clz, <span class="string">"name1"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">	f_name2_id = (*env)-&gt;GetStaticFieldID(env, j_clz, <span class="string">"name2"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-异常处理（简单讲，C-异常）"><a href="#4-异常处理（简单讲，C-异常）" class="headerlink" title="4. 异常处理（简单讲，C++异常）"></a>4. 异常处理（简单讲，C++异常）</h1><ul>
<li><code>jthrowable throwable = (*env)-&gt;ExceptionOccurred(env);</code>：正在抛出一个异常的本地引用</li>
<li><code>(*env)-&gt;ExceptionClear(env);</code>：清除异常</li>
<li><code>(*env)-&gt;Throw(env, throwable);</code>：将ExceptionOccurred获取到的异常直接抛给java层</li>
<li><code>(*env)-&gt;ThrowNew(env, no_such_clz, &quot;NoSuchFieldException name3&quot;);</code>：抛出自己想抛出的异常</li>
</ul>
<p>异常说明：</p>
<ol>
<li><p><code>ExceptionCheck</code> 用于检测如果一个异常已经抛出，则该方法将会返回JNI_TRUE就是typedef定义为1的布尔值。</p>
</li>
<li><p><code>ExceptionOccurred</code> 获取正在抛出一个异常的本地引用，Native或Java层必须处理该异常，并返回一个jthrowable对象。</p>
</li>
<li><p><code>ExceptionDescribe</code> 主要用于打印出异常的错误描述。</p>
</li>
<li><p><code>ExceptionClear</code> 清除刚刚抛出的异常。</p>
</li>
<li><p><code>FatalError</code> 的作用比较特殊，产生一个致命性的错误，Android123提示这样会导致JVM将关闭，就是程序停止运行了，所以使用时要谨慎。</p>
</li>
</ol>
<p>说明下：<code>ExceptionCheck</code> 用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">env-&gt;FindClass(<span class="string">"Android123CWJ"</span>); <span class="comment">//假设这个类本身不存在</span></span><br><span class="line"> <span class="keyword">if</span>(env-&gt;ExceptionCheck())</span><br><span class="line"> &#123;</span><br><span class="line">   env-&gt;ExceptionDescribe();</span><br><span class="line">   env-&gt;ExceptionClear();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<p>下面是：<code>ExceptionOccurred</code> 用法</p>
<p>注意： 保存后在抛出异常后记得 <code>return</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 异常处理</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni10_Sample_exception</span><br><span class="line">(JNIEnv *env, jclass j_clz)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 假设现在想给 ，name3 赋值</span></span><br><span class="line">	jfieldID jfid = (*env)-&gt;GetStaticFieldID(env, j_clz, <span class="string">"name3"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两种方式解决</span></span><br><span class="line">	<span class="comment">// 1. 补救措施， 不拿 name3 拿 name</span></span><br><span class="line">	<span class="comment">// 1.1 有没有异常</span></span><br><span class="line">	jthrowable throwable = (*env)-&gt;ExceptionOccurred(env);</span><br><span class="line">	<span class="comment">/*if (throwable)&#123;</span></span><br><span class="line"><span class="comment">		// 补救措施，先把异常清除</span></span><br><span class="line"><span class="comment">		printf("native have a exception");</span></span><br><span class="line"><span class="comment">		// 清除异常</span></span><br><span class="line"><span class="comment">		(*env)-&gt;ExceptionClear(env);</span></span><br><span class="line"><span class="comment">		// 重新获取 name 属性</span></span><br><span class="line"><span class="comment">		jfid = (*env)-&gt;GetStaticFieldID(env, j_clz, "name", "Ljava/lang/String;");</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 想给 java 层抛一个异常</span></span><br><span class="line">	<span class="keyword">if</span> (throwable)&#123;</span><br><span class="line">		<span class="comment">// 清除异常</span></span><br><span class="line">		(*env)-&gt;ExceptionClear(env);</span><br><span class="line">		<span class="comment">// 给 java 层抛 一个 Throwable 异常</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第一种方式，直接把异常抛给 java 层</span></span><br><span class="line">		(*env)-&gt;Throw(env, throwable);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 第二种方式抛异常</span></span><br><span class="line">		<span class="comment">// (*env)-&gt;ThrowNew(env, no_such_clz, "NoSuchFieldException name3");</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">//  必须 return 如果不的话，程序会接着往下运行，肯定还会crash</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jstring name = (*env)-&gt;NewStringUTF(env, <span class="string">"Eastrise"</span>);</span><br><span class="line">	(*env)-&gt;SetStaticObjectField(env, j_clz, jfid, name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>JNI学习</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化：1.App启动优化(源码)</title>
    <url>/1.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96(%E6%BA%90%E7%A0%81)/</url>
    <content><![CDATA[<h1 id="1-系统的启动"><a href="#1-系统的启动" class="headerlink" title="1.系统的启动"></a>1.系统的启动</h1><ol>
<li>打开电源  引导芯片代码加载引导程序Boot Loader到RAM中去执行</li>
<li>BootLoader把操作系统拉起来</li>
<li>Linux 内核启动开始系统设置，找到一个init.rc文件启动初始化进程</li>
<li>init进程初始化和启动属性服务，之后开启Zygote进程</li>
<li>Zygote开始创建JVM并注册JNI方法，开启SystemServer</li>
<li>启动Binder线程沲和SystemServiceManager,并启动各种服务</li>
<li>AMS启动Launcher</li>
</ol>
<p><img src="/images/%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt></p>
<h1 id="2-Launcher启动应用程序"><a href="#2-Launcher启动应用程序" class="headerlink" title="2.Launcher启动应用程序"></a>2.Launcher启动应用程序</h1><p>当我们用手点击一个图标时，就到了这个类<code>public final class Launcher extends Activity</code>,<br>类路径在<code>E:\tools\android-src\android-6.0.1_r1\packages\apps\Launcher2\src\com\android\launcher2\Launcher.java</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">执行&#96;onClick(View view)&#96;方法，会把这个应用的相关信息传入  </span><br><span class="line">先获取一个intent---&gt;startActivitySafely(v, intent, tag)--&gt;startActivity(v, intent, tag);--&gt;startActivity(intent);</span><br><span class="line">startActivity(intent)会开一个APP进程</span><br><span class="line"></span><br><span class="line">ActivityThread.java的main方法作为入口     用attach开启app    再加载application和activity</span><br><span class="line">thread.attach(false);---&gt;mgr.attachApplication(mAppThread)会通过远端进程去回调private void handleBindApplication(AppBindData data)</span><br><span class="line">Application app &#x3D; data.info.makeApplication()----创建Application对象</span><br><span class="line">mInstrumentation.callApplicationOnCreate(app);---- Application调用onCreate方法</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%96%B0%E5%BA%94%E7%94%A8%E7%9A%84%E5%90%AF%E5%8A%A8.png" alt></p>
<h1 id="3-adb一些命令说明"><a href="#3-adb一些命令说明" class="headerlink" title="3.adb一些命令说明"></a>3.adb一些命令说明</h1><ol>
<li>通过<code>adb shell dumpsys activity activities</code>查看当前的activity名</li>
<li>查看进程   <code>adb shell ps</code></li>
</ol>
<h1 id="4-黑白屏问题"><a href="#4-黑白屏问题" class="headerlink" title="4.黑白屏问题"></a>4.黑白屏问题</h1><p>原因：</p>
<pre><code>在res/values/styles.xml文件中  
白屏   `&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt;`
黑屏   ` &lt;style name=&quot;AppTheme&quot;&gt;（在以前的老版本上有效，现在的版本默认使用透明处理了）`</code></pre><p>伪解决办法：</p>
<pre><code>1.在自己的&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt;中加入windowsbackground，可用于打广告
2.设置windowbackground为透明的  &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
但这2种方法会有个问题，所有的activity启动都会显示
3.单独做成一个主题
&lt;style name=&quot;AppTheme.Launcher&quot;&gt;
        &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg&lt;/item&gt;
&lt;/style&gt;
再在功能清单中的单独activity下设置
&lt;activity
      android:theme=&quot;@style/AppTheme.Launcher&quot;
然后在程序中使用setTheme(R.style.AppTheme)
让APP中所有的activity还是使用以前的样式，这样做就只有启动时才使用自己的样式</code></pre><h1 id="5-启动时间查看"><a href="#5-启动时间查看" class="headerlink" title="5.启动时间查看"></a>5.启动时间查看</h1><p>4.4以前 <code>adb shell am start -W com.lqr.wechat/com.lqr.wechat.activity.SplashActivity</code></p>
<pre><code>ThisTime:最后一个启动的Activity的启动耗时；
TotalTime:自己的所有Activity的启动耗时；
WaitTime: ActivityManagerService启动App的Activity时的总时间（包括当前Activity的onPause()和自己Activity的启动）

AM路径：E:\tools\android-src\android-6.0.1_r1\frameworks\base\cmds\am\src\com\android\commands\am
Am.java   946行开始打印启动时间信息
其中一个result对象，在871行初始化 result = mAm.startActivityAndWait(。。。）
在这个初始化时就已经进行了时间的计算：
在android-src\android-6.0.1_r1\frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java文件中计算
void windowsDrawnLocked() ---&gt;reportLaunchTimeLocked(SystemClock.uptimeMillis())中完成时间的统计;</code></pre><p>4.4版本以后Logcat输入<code>Display</code>筛选系统日志  <code>不过滤信息No Filters</code></p>
<h1 id="6-TRACE工具分析代码执行时间"><a href="#6-TRACE工具分析代码执行时间" class="headerlink" title="6.TRACE工具分析代码执行时间"></a>6.TRACE工具分析代码执行时间</h1><h1 id="6-1-代码"><a href="#6-1-代码" class="headerlink" title="6.1.代码"></a>6.1.代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Debug.startMethodTracing(filePath);</span><br><span class="line">中间为需要统计执行时间的代码</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure>
<h1 id="6-2-分析"><a href="#6-2-分析" class="headerlink" title="6.2. 分析"></a>6.2. 分析</h1><p><code>adb pull /storage/emulated/0/app1.trace</code>把文件拉出来分析，把pull到电脑上的文件拖到AS中就可以分析了</p>
<h1 id="6-3-优化方案"><a href="#6-3-优化方案" class="headerlink" title="6.3. 优化方案"></a>6.3. 优化方案</h1><ol>
<li>开线程  <code>没建handler    没操作UI   对异步要求不高</code></li>
<li>懒加载  <code>用到的时候再初始化，如网络，数据库操作</code></li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>C基础：06.文件操作</title>
    <url>/06.C%E5%9F%BA%E7%A1%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="1-文件打开，读取，写入"><a href="#1-文件打开，读取，写入" class="headerlink" title="1.文件打开，读取，写入"></a>1.文件打开，读取，写入</h1><ul>
<li><code>siz_t fread(void *buffer,size_t size,size_t count, FILE* stream);</code> :以字节位计算长度,按照指定的长度和次数读取数据,遇到结尾或完成指定长度读取后停止.可用于文件复制</li>
<li><code>char *fgets(char *string, int n, FILE *stream);</code> :从流中读取一字符串,整行读取,遇到回车换行或结尾停止.在文本方式时使用.</li>
<li><code>int fputs(char *string, FILE *stream);</code>：将一个字符串写到一个文件流中 </li>
<li><code>FILE *fopen(char *filename, char *type);</code>：打开文件</li>
<li><code>int fclose(FILE *stream);</code>：关闭文件<br>打开：</li>
</ul>
<p><code>FILE* fopen(const char* filename,const char* mode);</code> // 打开文件 （文件名，模式）mode r(读) w(写) rb(作为二进制读) wb(作为二进制写) a（追加）<br>注意: <code>&quot;wb&quot; 模式 会新建一个文件 0KB</code></p>
<p>模式：</p>
<ul>
<li>“w” 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</li>
<li>“wb” 只写打开或新建一个二进制文件；只允许写数据。若文件不存在则建立该文件。,不会清空文件</li>
<li>“wb+” 读写打开或建立一个二进制文件，允许读和写</li>
<li>“a” 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</li>
<li>”a+“ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）</li>
</ul>
<h2 id="1-1-文件读取"><a href="#1-1-文件读取" class="headerlink" title="1.1.文件读取"></a>1.1.文件读取</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* file_name = <span class="string">"F:\\Sample.txt"</span>; <span class="comment">// 源文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//文件读</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打开文件（文件名，模式） mode r(读) w(写) rb(作为二进制读) wb(作为二进制写) a（追加）</span></span><br><span class="line">    <span class="comment">// FILE* fopen(const char* filename,const char* mode);</span></span><br><span class="line">    <span class="comment">// char *fgets(char *string, int n, FILE *stream);</span></span><br><span class="line">    FILE* file = fopen(file_name,<span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区buffer, 长度10，文件指针</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(<span class="built_in">buffer</span>,<span class="number">10</span>,file))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="built_in">buffer</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-文件写入"><a href="#1-2-文件写入" class="headerlink" title="1.2.文件写入"></a>1.2.文件写入</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* file = fopen(file_name,<span class="string">"w"</span>);  <span class="comment">//会清空原文件内容</span></span><br><span class="line">    <span class="keyword">if</span>(!file)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">"I am eastrise"</span>,file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-文件复制，当做二进制文件来操作"><a href="#2-文件复制，当做二进制文件来操作" class="headerlink" title="2.文件复制，当做二进制文件来操作"></a>2.文件复制，当做二进制文件来操作</h1><ul>
<li><code>int fread(void *ptr, int size, int nitems, FILE *stream);</code>：二进制流读取</li>
<li><code>int fwrite(void *ptr, int size, int nitems, FILE *stream);</code>: 二进制流写入</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* file = fopen(file_name,<span class="string">"rb"</span>); <span class="comment">// 流指针</span></span><br><span class="line">    FILE* file_copy = fopen(file_copy_name,<span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file || !file_copy)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// siz_t fread(void *buffer,size_t size,size_t count, FILE* stream);</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">buffer</span>[<span class="number">512</span>]; <span class="comment">// 2048 = 4*512</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="keyword">sizeof</span>(<span class="built_in">buffer</span>));</span><br><span class="line">    <span class="keyword">while</span> ((len = fread(<span class="built_in">buffer</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),<span class="number">512</span>,file))!=<span class="number">0</span>)&#123;</span><br><span class="line">        fwrite(<span class="built_in">buffer</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>),len,file_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(file);</span><br><span class="line">    fclose(file_copy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-获取文件大小"><a href="#3-获取文件大小" class="headerlink" title="3.获取文件大小"></a>3.获取文件大小</h1><ul>
<li><code>int fseek(FILE *stream, long offset, int fromwhere);</code>：重定位流上的文件指针 </li>
<li><code>long ftell(FILE *stream);</code>: 返回当前文件指针，大小是字节</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* file = fopen(file_name,<span class="string">"rb"</span>);<span class="comment">// 流指针</span></span><br><span class="line">    <span class="keyword">if</span> (!file)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有一个函数是可以直接拿文件大小</span></span><br><span class="line">    <span class="comment">// 思路：将文件的指针移动到最后，然后再去计算偏移量</span></span><br><span class="line">    <span class="comment">// 三个参数 SEEK_SET（开头），SEEK_CUR（当前），SEEK_END（移动到最后）</span></span><br><span class="line">    fseek(file,<span class="number">0</span>,SEEK_END);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算偏移的位置，ftell 从 0 开始统计到当前（SEEK_END）</span></span><br><span class="line">    <span class="keyword">long</span> file_size = ftell(file);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"文件大小：%ld个字节"</span>,file_size);</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-文件加密、解密（该方法文件适合图片，如果文件中有中文就不适合）"><a href="#4-文件加密、解密（该方法文件适合图片，如果文件中有中文就不适合）" class="headerlink" title="4.文件加密、解密（该方法文件适合图片，如果文件中有中文就不适合）"></a>4.文件加密、解密（该方法文件适合图片，如果文件中有中文就不适合）</h1><h2 id="4-1-加密"><a href="#4-1-加密" class="headerlink" title="4.1.加密"></a>4.1.加密</h2><ul>
<li><code>int fgetc(FILE *stream);</code>:从文件流中读取字符 </li>
<li><code>int fputc(int ch, FILE *stream);</code>：将字符写到一个文件流中 </li>
</ul>
<p>思路：文件每个字节拿出来<code>^5</code>,^（相同为0，不同为1）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了防止图片泄密，图片进行加密</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* file = fopen(file_image_name,<span class="string">"rb"</span>); <span class="comment">// 流指针</span></span><br><span class="line">    FILE* file_encrpy = fopen(file_encrpy_image_name,<span class="string">"wb"</span>); <span class="comment">// 新建一个文件 0KB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file || !file_encrpy)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 破坏文件，还原</span></span><br><span class="line">    <span class="comment">// 思路：把每一个字节都拿出来，对每一个字节都处理，把某部分字节拿出来，进行处理</span></span><br><span class="line">    <span class="comment">// 10^5 异或 加密过程</span></span><br><span class="line">    <span class="comment">// 1010</span></span><br><span class="line">    <span class="comment">// ^0101</span></span><br><span class="line">    <span class="comment">// 1111 加密</span></span><br><span class="line">    <span class="keyword">int</span> c;<span class="comment">// EOF end of file</span></span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(file))!=EOF)&#123;</span><br><span class="line">        fputc(c ^ <span class="number">5</span>,file_encrpy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-解密"><a href="#4-2-解密" class="headerlink" title="4.2.解密"></a>4.2.解密</h2><p>思路：文件每个字节拿出来<code>^5</code>,^（相同为0，不同为1）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* file = fopen(file_encrpy_image_name,<span class="string">"rb"</span>); <span class="comment">// 流指针</span></span><br><span class="line">    FILE* file_decrpy = fopen(file_decrpy_image_name,<span class="string">"wb"</span>);<span class="comment">// 新建一个文件 0kb</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file || !file_decrpy)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解密 同样的去异或 5</span></span><br><span class="line">    <span class="comment">//  1111</span></span><br><span class="line">    <span class="comment">// ^0101</span></span><br><span class="line">    <span class="comment">//  1010  // 解密后 10</span></span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">// EOF end of file;</span></span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(file))!=EOF)&#123;</span><br><span class="line">        fputc(c ^ <span class="number">5</span>,file_decrpy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    fclose(file_decrpy);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-字符串秘钥对文件进行加密、解密"><a href="#5-字符串秘钥对文件进行加密、解密" class="headerlink" title="5.字符串秘钥对文件进行加密、解密"></a>5.字符串秘钥对文件进行加密、解密</h1><h2 id="5-1-字符串秘钥对文件加密"><a href="#5-1-字符串秘钥对文件加密" class="headerlink" title="5.1.字符串秘钥对文件加密"></a>5.1.字符串秘钥对文件加密</h2><p>思路：文件每个字节拿出来按照顺序轮流跟字符串秘钥进行<code>^</code>操作,^（相同为0，不同为1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pass_word = <span class="string">"12345"</span>; <span class="comment">// 轮流进行^操作</span></span><br><span class="line"></span><br><span class="line">    FILE* file = fopen(file_image_name,<span class="string">"rb"</span>); <span class="comment">// 流操作</span></span><br><span class="line">    FILE* file_encrpy = fopen(file_encrpy_image_name,<span class="string">"wb"</span>); <span class="comment">// 新建一个文件 0KB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file || !file_encrpy)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">// EOF end of file</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pass_len = <span class="built_in">strlen</span>(pass_word);</span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(file))!=EOF)&#123;</span><br><span class="line">        fputc(c ^ pass_word[index % pass_len],file_encrpy);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    fclose(file_encrpy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-字符串秘钥对文件解密"><a href="#5-2-字符串秘钥对文件解密" class="headerlink" title="5.2.字符串秘钥对文件解密"></a>5.2.字符串秘钥对文件解密</h2><p>思路：文件每个字节拿出来按照顺序轮流跟字符串秘钥进行<code>^</code>操作,^（相同为0，不同为1）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* pass_word = <span class="string">"12345"</span>;<span class="comment">// 轮流进行^操作</span></span><br><span class="line"></span><br><span class="line">    FILE* file = fopen(file_encrpy_image_name,<span class="string">"rb"</span>); <span class="comment">// 流操作</span></span><br><span class="line">    FILE* file_decrpy = fopen(file_decrpy_image_name,<span class="string">"wb"</span>); <span class="comment">// 新建一个文件 0KB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!file || !file_decrpy)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"文件打开失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// 退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c; <span class="comment">// EOF end of file</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pass_len = <span class="built_in">strlen</span>(pass_word);</span><br><span class="line">    <span class="keyword">while</span> ((c = fgetc(file)) != EOF)&#123;</span><br><span class="line">        fputc(c ^ pass_word[index%pass_len],file_decrpy);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    fclose(file_decrpy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-文件切割、合并"><a href="#6-文件切割、合并" class="headerlink" title="6. 文件切割、合并"></a>6. 文件切割、合并</h1><ul>
<li><code>int sprintf(char *string, char *farmat [,argument,...]);</code>：将格式化输出到字符串中 </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFileSize</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName)</span></span>&#123;</span><br><span class="line">    FILE* file = fopen(fileName,<span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!file)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    fseek(file,<span class="number">0</span>,SEEK_END);</span><br><span class="line">    <span class="keyword">int</span> file_size = ftell(file);</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> file_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-1-文件切割"><a href="#6-1-文件切割" class="headerlink" title="6.1.文件切割"></a>6.1.文件切割</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 百度云 不大于4G的文件？ 8G 文件， 扔进去</span></span><br><span class="line">    <span class="comment">// 大文件（断点续传）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件切割，把文件合作为一个思考</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每个文件需要写入多少？</span></span><br><span class="line"></span><br><span class="line">    FILE* file = fopen(file_image_name,<span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> file_size = getFileSize(file_image_name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 切多少，计算大小，指定文件名</span></span><br><span class="line">    <span class="keyword">int</span> file_number = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 二位数组，char[] char*</span></span><br><span class="line">    <span class="comment">// image_0.png</span></span><br><span class="line">    <span class="comment">// image_1.png</span></span><br><span class="line">    <span class="comment">// image_2.png</span></span><br><span class="line">    <span class="comment">// char* file_name;</span></span><br><span class="line">    <span class="comment">// char*</span></span><br><span class="line">    <span class="keyword">char</span>** file_names = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*file_number);</span><br><span class="line">    <span class="keyword">int</span> preFileSize = file_size / file_number;</span><br><span class="line">    <span class="comment">// 计算复制</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        file_names[i] = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);<span class="comment">// '\0'</span></span><br><span class="line">        <span class="built_in">sprintf</span>(file_names[i],file_split,i);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,file_names[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; file_number; i++)&#123;</span><br><span class="line">        <span class="comment">// 从源文件中往切割文件写入数据</span></span><br><span class="line">        FILE* cur_file = fopen(file_names[i],<span class="string">"wb"</span>);  <span class="comment">// w 会新建文件</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写多少？</span></span><br><span class="line">        <span class="keyword">int</span> start = i*preFileSize;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">end</span> = (i + <span class="number">1</span>)*preFileSize;</span><br><span class="line">        <span class="keyword">if</span>(i == file_number - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">end</span> = file_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个循环 file 读，第二个循环还是从 file 里面</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start; j&lt; <span class="built_in">end</span>; j++)&#123;</span><br><span class="line">            <span class="comment">// 从 file 里面读，写入到 cur_file</span></span><br><span class="line">            fputc(fgetc(file),cur_file);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(cur_file);</span><br><span class="line">        <span class="built_in">free</span>(file_names[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="built_in">free</span>(file_names);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-文件合并"><a href="#6-2-文件合并" class="headerlink" title="6.2.文件合并"></a>6.2.文件合并</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE* file0 = fopen(<span class="string">"F:\\image_0.jpg"</span>,<span class="string">"rb"</span>);</span><br><span class="line">    FILE* file1 = fopen(<span class="string">"F:\\image_1.jpg"</span>,<span class="string">"rb"</span>);</span><br><span class="line">    FILE* file2 = fopen(<span class="string">"F:\\image_2.jpg"</span>,<span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">    FILE* file_merge = fopen(<span class="string">"F:\\image_merge.jpg"</span>,<span class="string">"wb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(file0))!=EOF)&#123;</span><br><span class="line">        fputc(c,file_merge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(file1))!=EOF)&#123;</span><br><span class="line">        fputc(c,file_merge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>((c = fgetc(file2))!=EOF)&#123;</span><br><span class="line">        fputc(c,file_merge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file0);</span><br><span class="line">    fclose(file1);</span><br><span class="line">    fclose(file2);</span><br><span class="line">    fclose(file_merge);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C基础</tag>
      </tags>
  </entry>
  <entry>
    <title>C进阶：07.内存四驱模型</title>
    <url>/11.C%E8%BF%9B%E9%98%B6-%E5%86%85%E5%AD%98%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="1-数组作为参数传递时获取不到长度的问题！！"><a href="#1-数组作为参数传递时获取不到长度的问题！！" class="headerlink" title="1. 数组作为参数传递时获取不到长度的问题！！"></a>1. 数组作为参数传递时获取不到长度的问题！！</h1><p>原因：数组作为参数传递，会退化成为一个指针，传递的是首地址 （高效）</p>
<h1 id="2-数据类型剖析"><a href="#2-数据类型剖析" class="headerlink" title="2. 数据类型剖析"></a>2. 数据类型剖析</h1><p>数据类型的本质：<code>一块连续大小的内存空间</code><br>数据类型的别名：int32_t<br>void指针数据类型：<code>void*</code> 代表任意的数据类型的指针  </p>
<h1 id="3-变量的本质"><a href="#3-变量的本质" class="headerlink" title="3. 变量的本质"></a>3. 变量的本质</h1><ul>
<li>变量的本质：固定内存块大小（一块连续大小的内存空间）的别名，通过变量可以去操作一块内存上的数据</li>
<li>变量的三要素：内存大小，名称，作用域</li>
</ul>
<h1 id="4-内存四驱模型"><a href="#4-内存四驱模型" class="headerlink" title="4. 内存四驱模型"></a>4. 内存四驱模型</h1><h2 id="4-1-程序运行的流程："><a href="#4-1-程序运行的流程：" class="headerlink" title="4.1 程序运行的流程："></a>4.1 程序运行的流程：</h2><ol>
<li>操作系统会把物理硬盘上的代码 load 到内存</li>
<li>加载到内存后会把 c 代码分成 4 个区</li>
<li>然后系统会找到 main 函数的入口去执行</li>
</ol>
<h2 id="4-2-四驱模型"><a href="#4-2-四驱模型" class="headerlink" title="4.2  四驱模型"></a>4.2  四驱模型</h2><ol>
<li>栈区：由编译器自动分配的，存放一些局部变量值和函数，这个里面内存是会自动进行回收的</li>
<li>堆区：一般都是由我们自己去开辟的，这个里面的内存需要手动进行释</li>
<li>全局区：静态的一些常量，字符串 等等</li>
<li>程序代码区：存放的是函数体的二进制代码</li>
</ol>
<h1 id="5-栈的开口方向"><a href="#5-栈的开口方向" class="headerlink" title="5. 栈的开口方向"></a>5. 栈的开口方向</h1><ul>
<li>debug模式下：向下</li>
<li>release模式下：向上</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 0508 , 0496  a 的地址要大于 b 的地址 （debug）</span></span><br><span class="line">    <span class="comment">// 016  , 020   a 的地址要小于 b 的地址 （release）</span></span><br><span class="line">    <span class="comment">// buffer 数据类型跟栈的开口方向无关 （内部存储都是向上）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buff[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// buff+1 -&gt; buff</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p , %p , %p , %p"</span>,&amp;a,&amp;b,buff,buff+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a1 = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span>* ff=  &amp;a1; <span class="comment">// 虽说是 a1 的地址，但是我也可以把 ff 看做一个数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char** 二位数组 char** 二级指针</span></span><br><span class="line"></span><br><span class="line">    ff += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-指针强化"><a href="#6-指针强化" class="headerlink" title="6. 指针强化"></a>6. 指针强化</h1><p><font color="red"><strong>一个指针的大小始终是32位系统占4个字节，64位系统占8字节</strong></font></p>
<p>指针为什么要有类型：</p>
<ol>
<li>为了地址增量的方便：例如double型的地址增量为8，而int型指针的地址增量为4</li>
<li>为了类型安全：帮助编译器发现你是否用了错误的类型</li>
</ol>
<p><code>指针是以内存地址作为变量地址</code></p>
]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI:02.数据类型，签名，Native层构建java对象，指针常量和常量指针</title>
    <url>/08.JNI%E5%9F%BA%E7%A1%80-Native%E5%B1%82%E6%9E%84%E5%BB%BAjava%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><strong>代码请看：<a href="https://github.com/EastUp/JavaJNITest/tree/master/src/com/east/jni08" target="_blank" rel="noopener">08.JNI基础-Native层构建java对象</a></strong></p>
<h1 id="1-调用-java-层-static-的获取-uuid-的方法"><a href="#1-调用-java-层-static-的获取-uuid-的方法" class="headerlink" title="1. 调用 java 层 static 的获取 uuid 的方法"></a>1. 调用 java 层 static 的获取 uuid 的方法</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_east_jni08_Sample1_callStaticMethod</span><br><span class="line">(JNIEnv* env,jclass jclz)&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 2. 获取jmethodID</span></span><br><span class="line">	jmethodID j_mid = (*env)-&gt;GetStaticMethodID(env, jclz, <span class="string">"getUUID"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 调用 getUUID 的方法 statics</span></span><br><span class="line">	jstring j_uuid = (*env)-&gt;CallStaticObjectMethod(env,jclz,j_mid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// jstring -&gt; c_str</span></span><br><span class="line">	<span class="keyword">char</span>* c_uuid = (*env)-&gt;GetStringUTFChars(env,j_uuid,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回收，字符串回收</span></span><br><span class="line">	(*env)-&gt;ReleaseStringChars(env,j_uuid,c_uuid);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"c_uuid = %s"</span>,c_uuid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jni 回收内存：<br><code>(*env)-&gt;ReleaseStringUTFChars(env,j_uuid,c_uuid);</code></p>
<h1 id="2-jni-数据类型"><a href="#2-jni-数据类型" class="headerlink" title="2. jni 数据类型"></a>2. jni 数据类型</h1><ul>
<li>jstring -&gt; java String</li>
<li>jint -&gt; java int</li>
<li>jfloat -&gt; java float</li>
<li>jdouble -&gt; java double</li>
<li>jobject -&gt; java object</li>
<li>jintArray -&gt; java int[]</li>
<li>jdoubleArray -&gt; java double[]</li>
<li>jbyteArray -&gt; java byte[]<br>….</li>
</ul>
<h1 id="3-java数据类型对应的签名"><a href="#3-java数据类型对应的签名" class="headerlink" title="3.java数据类型对应的签名"></a>3.java数据类型对应的签名</h1><h2 id="3-1-基本数据类型签名"><a href="#3-1-基本数据类型签名" class="headerlink" title="3.1.基本数据类型签名"></a>3.1.基本数据类型签名</h2><ul>
<li>boolean -&gt; Z</li>
<li>byte    -&gt; B</li>
<li>char    -&gt; C</li>
<li>short   -&gt; S</li>
<li>int     -&gt; I</li>
<li>long    -&gt; J</li>
<li>float   -&gt; F</li>
<li>double  -&gt; D</li>
<li>void    -&gt; V</li>
</ul>
<h2 id="3-2-数组引用类型签名"><a href="#3-2-数组引用类型签名" class="headerlink" title="3.2.数组引用类型签名"></a>3.2.数组引用类型签名</h2><ul>
<li>int[]    -&gt; [I</li>
<li>float[]  -&gt; [f</li>
<li>byte[]   -&gt; [B</li>
<li>char[]   -&gt; [C</li>
<li>short[]  -&gt; [S</li>
<li>double[] -&gt; [D</li>
<li>long[]   -&gt; [F</li>
<li>boolean[]-&gt; [Z</li>
</ul>
<h2 id="3-3-引用数据类型签名"><a href="#3-3-引用数据类型签名" class="headerlink" title="3.3.引用数据类型签名"></a>3.3.引用数据类型签名</h2><ul>
<li>String -&gt; Ljava/lang/String;</li>
<li>Object[] -&gt; [L全类名;</li>
</ul>
<h1 id="4-常量指针和指针常量"><a href="#4-常量指针和指针常量" class="headerlink" title="4. 常量指针和指针常量"></a>4. 常量指针和指针常量</h1><ul>
<li>常量变量：被常量修饰的变量，不能再次被赋值 （Java）</li>
<li>常量指针：const 在 * 之前，指针的地址是可以被再次赋值的（可以修改的），指针地址上面的值（变量）是不能被修改的，常量指针的常量是不能被改变的。</li>
<li>指针常量：const 在 * 之后，指针的地址是不可以被再次赋值的（不可以修改的），指针地址上面的值（变量）能被修改的，指针常量的指针地址是不能被改变的。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 常量，不能去修改</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// number = 200;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> number1 = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">int</span> number2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 常量指针（const 在 * 之前,地址可以被重新赋值，但是值不能改变）</span></span><br><span class="line">	<span class="comment">// int const * n_p = &amp;number2;</span></span><br><span class="line">	<span class="comment">// n_p = &amp;number1;</span></span><br><span class="line">	<span class="comment">// printf("n_p = %p",n_p); // 地址是可以重新被赋值的</span></span><br><span class="line">	<span class="comment">// *n_p = 300; // 值不能改变</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 指针常量（const 在 * 之后,地址不可以被重新赋值，但是值可以改变）</span></span><br><span class="line">	<span class="keyword">int</span>* <span class="keyword">const</span> n_p = &amp;number2;</span><br><span class="line">	<span class="comment">// n_p = &amp;number1; // 地址是不能被重新赋值的</span></span><br><span class="line">	*n_p = <span class="number">300</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"number2 = %d"</span>,number2);<span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-Native-层构建-Java-对象"><a href="#5-Native-层构建-Java-对象" class="headerlink" title="5. Native 层构建 Java 对象"></a>5. Native 层构建 Java 对象</h1><ul>
<li>如果是一个类的构造方法获取jmethodID时，名字传<code>&lt;init&gt;</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c 层 创建 java 对象</span></span><br><span class="line">JNIEXPORT jobject JNICALL Java_com_east_jni08_Sample1_createPoint</span><br><span class="line">(JNIEnv* env, jclass jclz)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 需要获取 Point 的class name = "全类名"</span></span><br><span class="line">	<span class="comment">// 方法参数上的 jclz  指的是 Sample1.class</span></span><br><span class="line">	jclass point_clz = (*env)-&gt;FindClass(env,<span class="string">"com/east/jni08/Point"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 获取jmethodID ,构造方法写死 "&lt;init&gt;"</span></span><br><span class="line">	jmethodID j_mid = (*env)-&gt;GetMethodID(env, point_clz, <span class="string">"&lt;init&gt;"</span>,<span class="string">"(II)V"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 创建对象</span></span><br><span class="line">	jobject <span class="built_in">point</span> = (*env)-&gt;NewObject(env,point_clz, j_mid, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 练习下 y 重新赋值,调用 set 方法</span></span><br><span class="line">	j_mid = (*env)-&gt;GetMethodID(env,point_clz,<span class="string">"setY"</span>,<span class="string">"(I)V"</span>);</span><br><span class="line">	<span class="comment">/* va_list 集合</span></span><br><span class="line"><span class="comment">	void (JNICALL *CallVoidMethodV)</span></span><br><span class="line"><span class="comment">	(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);</span></span><br><span class="line"><span class="comment">	// jvalue</span></span><br><span class="line"><span class="comment">	void (JNICALL *CallVoidMethodA)</span></span><br><span class="line"><span class="comment">	(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue * args);</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	(*env)-&gt;CallObjectMethod(env,<span class="built_in">point</span>,j_mid,<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直接重新赋值，相当于反射了但是比反射快</span></span><br><span class="line">	jfieldID j_fid = (*env)-&gt;GetFieldID(env,point_clz,<span class="string">"y"</span>,<span class="string">"I"</span>);</span><br><span class="line">	(*env)-&gt;SetIntField(env,<span class="built_in">point</span>,j_fid,<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">point</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>JNI学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C进阶：09.二级指针和多级指针</title>
    <url>/13.C%E8%BF%9B%E9%98%B6-%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E5%92%8C%E5%A4%9A%E7%BA%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="1-指针使用的注意事项"><a href="#1-指针使用的注意事项" class="headerlink" title="1. 指针使用的注意事项"></a>1. 指针使用的注意事项</h1><ol>
<li>不要轻易改变指针的位置</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* p = <span class="literal">NULL</span>;  </span><br><span class="line"><span class="built_in">strcpy</span>(p,<span class="string">"string"</span>);  <span class="comment">//  报错，无效（需要先动态给p开辟内存，或者定义时char p[num]这样使用才有效）</span></span><br><span class="line">p=<span class="string">"string"</span>;  <span class="comment">// 可以</span></span><br></pre></td></tr></table></figure>

<p><code>第一个是把string赋值给p，第二个是p指向“string”的首地址。</code></p>
<h1 id="2-const-关键字"><a href="#2-const-关键字" class="headerlink" title="2. const 关键字"></a>2. const 关键字</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常量（创建一个指针还是可以改变的）</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量指针(常量指针的值是不能被修改的)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* numberP = &amp;number;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针常量（指针常量的地址是不能被修改的）</span></span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> numberP = &amp;number2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值不能修改，指针也不能修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> numberP = &amp;number2;</span><br></pre></td></tr></table></figure>


<h1 id="3-二级指针的内存模式"><a href="#3-二级指针的内存模式" class="headerlink" title="3. 二级指针的内存模式"></a>3. 二级指针的内存模式</h1><h2 id="3-1-指针数组"><a href="#3-1-指针数组" class="headerlink" title="3.1 指针数组"></a>3.1 指针数组</h2><p><code>指针数组</code>：数组指针指向的是数组元素的首地址</p>
<h2 id="3-2-二维数组的几种定义方式"><a href="#3-2-二维数组的几种定义方式" class="headerlink" title="3.2 二维数组的几种定义方式"></a>3.2 二维数组的几种定义方式</h2><p>第一种定义方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* name[<span class="number">10</span>] = &#123;<span class="string">"east"</span>,<span class="string">"rose"</span>,<span class="string">"jack"</span>&#125;;<span class="comment">// 后面的默认指向的是 NULL 地址，都是在静态常量区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>** name = &#123;<span class="string">"east"</span>,<span class="string">"rose"</span>,<span class="string">"jack"</span>&#125;; <span class="comment">// 这种定义方式有问题,直接去赋值那么 c 和 c++ 会把这哥们当做 二级指针。而不是指针数组</span></span><br></pre></td></tr></table></figure>

<p>第二种定义的方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[<span class="number">10</span>][<span class="number">30</span>] = &#123;<span class="string">"east"</span>,<span class="string">"rose"</span>,<span class="string">"jack"</span>&#125;; <span class="comment">// 这个几个数据都是从静态常量区copy 到 栈的 buffer里面的</span></span><br></pre></td></tr></table></figure>

<p>第三种定义方式（最常见的一种方式）动态开辟，不理解记住套路：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>** str,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt; len; i++)&#123;</span><br><span class="line"><span class="comment">//        printf("%s\n",str[i]); // [] 也相当于挪动指针</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,*(str+i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">char</span>** params = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*number); <span class="comment">// 开辟二位数组</span></span><br><span class="line">    <span class="comment">// 开辟一维数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;number; i++)&#123;</span><br><span class="line">        params[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>); <span class="comment">// 不会去开辟一维数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写一些数据</span></span><br><span class="line">        <span class="built_in">sprintf</span>(params[i],<span class="string">"i = %d"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(params,number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;number; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(params[i])&#123;</span><br><span class="line">            <span class="built_in">free</span>(params[i]);</span><br><span class="line">            params[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 然后再释放 params 二维数组  (也可以看做一维数组，只不过这个一维数组里面存放的是元素是 一级数组指针)</span></span><br><span class="line">    <span class="keyword">if</span>(params)&#123;</span><br><span class="line">        <span class="built_in">free</span>(params);</span><br><span class="line">        params = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-多级指针"><a href="#4-多级指针" class="headerlink" title="4. 多级指针"></a>4. 多级指针</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initParams</span><span class="params">(<span class="keyword">char</span>*** params,<span class="keyword">int</span> number)</span></span>&#123; <span class="comment">// 三级指针就出来了，最多也就二级指针（数组指针）</span></span><br><span class="line">    <span class="comment">// 开辟内存去赋值</span></span><br><span class="line">    <span class="keyword">char</span>** tempParams = (<span class="keyword">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>*)*number); <span class="comment">// 开辟二位数组</span></span><br><span class="line">    <span class="comment">// 开辟一维数组</span></span><br><span class="line">    <span class="keyword">int</span> i =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;number; i++)&#123;</span><br><span class="line">        tempParams[i] = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">50</span>); <span class="comment">// 不会去开辟一维数组</span></span><br><span class="line">        <span class="built_in">sprintf</span>(tempParams[i],<span class="string">"i = %d"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    *params = tempParams;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 我想给字符串数组开辟内存，开辟内存写到另一个方法</span></span><br><span class="line">    <span class="keyword">char</span>** params = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">4</span>;</span><br><span class="line">    initParams(&amp;params,number);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(params,number);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：01.引用和函数重载</title>
    <url>/15.C++%E5%9F%BA%E7%A1%80-%E5%BC%95%E7%94%A8%E5%92%8C%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<h1 id="1-c-和-c-的区别"><a href="#1-c-和-c-的区别" class="headerlink" title="1. c 和 c++ 的区别"></a>1. c 和 c++ 的区别</h1><ol>
<li>c++ 代码中可以混编 c 代码，c++ 里面写 c 代码也可以调用</li>
<li>c++ 面向对象（java）, c 面向过程</li>
<li>很多的开源框架都是用 c++ 写的（大部分基于 c++）</li>
</ol>
<p>打印：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; // c++ 的包</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; <span class="comment">// 命名的空间， java中的内部类</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-常量"><a href="#2-常量" class="headerlink" title="2. 常量"></a>2. 常量</h1><p>c++ 中 通过指针修改常量，编译都不会通过。（在C中可以）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number = 20;</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">int</span>* numberP = &amp;number; <span class="comment">//  c++中不能通过地址去修改常量值（报错），但是某些编译器上面能通过，但是也不能修改值。</span></span><br><span class="line">    <span class="comment">// c 是能干修改的，在 c 中可以说是一个伪命题</span></span><br><span class="line"></span><br><span class="line">     *numberP = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-引用和常量引用"><a href="#3-引用和常量引用" class="headerlink" title="3. 引用和常量引用"></a>3. 引用和常量引用</h1><h2 id="3-1-引用"><a href="#3-1-引用" class="headerlink" title="3.1 引用"></a>3.1 引用</h2><p><strong><code>int &amp;b = a;</code></strong>：b 是 a 的引用可以直接根据地址改变a的数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;number1,<span class="keyword">int</span> &amp;number2)</span></span>&#123; <span class="comment">// 引用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"swap number1的地址"</span> &lt;&lt; &amp;number1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    temp = number1;</span><br><span class="line">    number1 = number2;</span><br><span class="line">    number2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a  = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int b = a; // 这个地址不一样</span></span><br><span class="line">    <span class="keyword">int</span> &amp;b = a; <span class="comment">// 给 a 指向的内存取另外一个别，名 b</span></span><br><span class="line"></span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a的地址"</span> &lt;&lt; &amp;a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b的地址"</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"a的值"</span> &lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"b的值"</span> &lt;&lt; b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换值</span></span><br><span class="line">    <span class="keyword">int</span> number1 = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> number2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用，四驱模型值的拷贝，引用其实就是地址赋值，可以看成同一块内存的另外一个变量</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"main number1的地址"</span> &lt;&lt; &amp;number1 &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    swap(number1,number2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"number1 = "</span> &lt;&lt; number1 &lt;&lt; <span class="string">", number2 = "</span> &lt;&lt; number2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a的地址0x61fe04</span><br><span class="line">b的地址0x61fe04</span><br><span class="line">a的值20</span><br><span class="line">b的值20</span><br><span class="line">main number1的地址0x61fe00</span><br><span class="line">swap number1的地址0x61fe00</span><br><span class="line">number1 &#x3D; 20, number2 &#x3D; 10</span><br></pre></td></tr></table></figure>

<p><img src="/images/15%E5%BC%95%E7%94%A8%E5%AE%9E%E4%BE%8B.png" alt></p>
<h2 id="3-2-常量引用"><a href="#3-2-常量引用" class="headerlink" title="3.2 常量引用"></a>3.2 常量引用</h2><p><code>const Student &amp;stu</code>：签名加一个const关键字就变成了只读，不能修改里面的任何值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertStu</span><span class="params">(<span class="keyword">const</span> Student &amp;stu)</span> </span>&#123;<span class="comment">// &amp;stu  不想改，常量引用</span></span><br><span class="line">    <span class="comment">// 可以修改 stu 的值</span></span><br><span class="line">    <span class="comment">// strcpy(stu.name,"Jack"); // 引用加了const 所以不能修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就变成了只读</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu.name &lt;&lt; <span class="string">","</span> &lt;&lt; stu.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-函数重载和默认参数"><a href="#4-函数重载和默认参数" class="headerlink" title="4. 函数重载和默认参数"></a>4. 函数重载和默认参数</h1><p> <code>c 不允许函数的重载,c++ 中可以</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2 = <span class="number">200</span>, <span class="keyword">bool</span> cache = <span class="number">0</span>)</span> </span>&#123; <span class="comment">// number2 = 200 默认的参数 kotlin 很像</span></span><br><span class="line">    <span class="keyword">return</span> number1 + number2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果在C中会报错：错误 1 error C2084：函数 "int add(int,int)" 已有主题， c 不允许函数的重载,c++ 中可以</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2, <span class="keyword">int</span> number3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number1 + number2 + number3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-类的初探"><a href="#5-类的初探" class="headerlink" title="5. 类的初探"></a>5. 类的初探</h1><ol>
<li>class 定义类，跟 java 几乎类似</li>
<li>真正的开发过程中我们的 cpp 或者 c 文件，最终 dll 或者 so 库供调用者使用，所以为了确保类能够正常被调用，我们一般需要定义 .h 头文件</li>
<li>实现方法的使用要用命名空间  xxx类名::xxx方法</li>
</ol>
<p>头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span> <span class="comment">// 结构体类似</span></span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// 私有，包装，影响下面所有的属性</span></span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span>* name)</span></span>;</span><br><span class="line">    <span class="comment">// private： // 影响到下面的所有方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实现文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写实现，定义了另外一个方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123; <span class="comment">// 实现 Student 的 setAge 方法</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::setName</span><span class="params">(<span class="keyword">char</span>* name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span> -&gt; name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Student::getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Student::getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

























]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：02.类的构造函数、析构函数、拷贝函数</title>
    <url>/16.C++%E5%9F%BA%E7%A1%80-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E3%80%81%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E3%80%81%E6%8B%B7%E8%B4%9D%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="面试题：finalize-finally-final-之间的区别"><a href="#面试题：finalize-finally-final-之间的区别" class="headerlink" title="面试题：finalize , finally, final 之间的区别"></a>面试题：finalize , finally, final 之间的区别</h1><p><code>finalize</code> : java中垃圾回收回收该对象的时候会调用的方法   (c 中的析构函数)  </p>
<p><code>finally</code>： finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常,即使try语句块中有<code>return</code>）</p>
<p><code>final</code> ：  在java中，final可以用来修饰类，方法和变量（成员变量或局部变量）。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰类：当用final修饰类的时，表明该类不能被其他类所继承。</span><br><span class="line">修饰方法：当用final修饰方法时，把方法锁定，以防止继承类对其进行更改不能被重写。（注意：若父类中final方法的访问权限为private，</span><br><span class="line">        将导致子类中不能直接继承该方法，因此，此时可以在子类中定义相同方法名的函数，此时不会与重写final的矛盾，而是在子类中重新地定义了新方法。）</span><br><span class="line">修饰变量：final成员变量表示常量，只能被赋值一次，赋值后其值不再改变。类似于C++中的const。</span><br></pre></td></tr></table></figure>

<h1 id="1-构造函数（可以有很多）"><a href="#1-构造函数（可以有很多）" class="headerlink" title="1. 构造函数（可以有很多）"></a>1. 构造函数（可以有很多）</h1><h2 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1.定义"></a>1.1.定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    Student()&#123;<span class="comment">// 空参构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"空参构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Student(char* name):age(0)&#123;//  一个参数构造函数，相当于 this-&gt;age = 0;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; "一个参数构造函数" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        // this-&gt;name = name;</span></span><br><span class="line"><span class="comment">        // this-&gt;age = age;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">char</span>* name):Student(name,<span class="number">0</span>)&#123; <span class="comment">// 调用两个参数的构造函数，注意：先会调用两个参数的构造函数，然后才会执行当前构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"一个参数构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Student(<span class="keyword">char</span>* name,<span class="keyword">int</span> age)&#123; <span class="comment">// 两个参数构造函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"两个参数构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,name);</span><br><span class="line">        <span class="comment">// this-&gt;name = name; // 这样赋值不行</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 析构函数，如果有在对象内部开辟堆内存，可以在析构函数中释放内存</span></span><br><span class="line">    ~Student()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 临终遗言：对象被回收的时候会被调用</span></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 拷贝构造函数，对象会有一个默认的拷贝构造函数，用来对象之间赋值</span></span><br><span class="line">    Student(<span class="keyword">const</span> Student&amp; stu)&#123; <span class="comment">// 常量的引用</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// this-&gt;name = stu.name;// 浅拷贝</span></span><br><span class="line">        <span class="comment">// 如果动态开辟内存，一定要采用深拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*<span class="number">100</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name,stu.name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = stu.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="keyword">char</span>* name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-调用"><a href="#1-2-调用" class="headerlink" title="1.2.调用"></a>1.2.调用</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 默认调用空参的构造函数</span></span><br><span class="line">Student stu;</span><br><span class="line">stu.setAge(<span class="number">24</span>);</span><br><span class="line">stu.setName(<span class="string">"Eastrise"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用两参构造函数</span></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"Eastrise"</span>,<span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.用 new 关键字，返回的是一个 Student 的一级指针</span></span><br><span class="line">Student* stu = <span class="keyword">new</span> Student(<span class="string">"eastrise"</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.用 malloc 的方式，并没有调用空参的构造函数</span></span><br><span class="line">Student* stu = (Student*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Student));</span><br><span class="line">stu-&gt;setAge(<span class="number">25</span>);</span><br><span class="line">stu-&gt;setName(<span class="string">"eastrise"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数相互调用</span></span><br><span class="line">Student* stu = <span class="keyword">new</span> Student(<span class="string">"eastrise"</span>); <span class="comment">// 会先调用两参的再调用一参的</span></span><br></pre></td></tr></table></figure>


<h1 id="2-析构函数（只能有一个）"><a href="#2-析构函数（只能有一个）" class="headerlink" title="2. 析构函数（只能有一个）"></a>2. 析构函数（只能有一个）</h1><p><code>析构函数</code>:<code>如果有在对象内部开辟堆内存，可以在析构函数中释放内存</code></p>
<p><strong>如果是 <code>new</code> 的对象，则必须调用 <code>delete</code> 才会调用到<code>析构函数</code></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 2. 析构函数，如果有在对象内部开辟堆内存，可以在析构函数中释放内存</span></span><br><span class="line">    ~Student()&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 临终遗言：对象被回收的时候会被调用</span></span><br><span class="line">        <span class="comment">// 释放内存</span></span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;name);</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student* stu = <span class="keyword">new</span> Student(<span class="string">"eastrise"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu-&gt;getName() &lt;&lt; <span class="string">", "</span> &lt;&lt; stu-&gt;getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-malloc、free、new、delete-区别"><a href="#3-malloc、free、new、delete-区别" class="headerlink" title="3.malloc、free、new、delete 区别"></a>3.malloc、free、new、delete 区别</h1><ol>
<li>malloc/free 他们是一套， new/delete 它们是一套</li>
<li>malloc/free 不会去调用构造函数和析构函数</li>
<li>new/delete 会调用构造函数和析构函数</li>
</ol>
<h1 id="4-拷贝构造函数和调用场景"><a href="#4-拷贝构造函数和调用场景" class="headerlink" title="4. 拷贝构造函数和调用场景"></a>4. 拷贝构造函数和调用场景</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Person&#123;</span><br><span class="line">    int age;</span><br><span class="line">    char* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Person person1 &#x3D; &#123;25,&quot;east&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    Person person2 &#x3D; person1;&#x2F;&#x2F; &#x3D; 是赋值，把里面所有定义的属性赋值，c&#x2F;c++ 编译器帮我们做的</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &amp;person1 &lt;&lt; &quot; , &quot; &lt;&lt; &amp;person2 &lt;&lt; endl; &#x2F;&#x2F; 地址不一样，是深拷贝</span><br><span class="line"></span><br><span class="line">    person1.name &#x3D; &quot;sss&quot;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; person2.name &lt;&lt; &quot; , &quot; &lt;&lt; person2.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：<font color="red">非指针运算的 = 应该都是深拷贝</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.拷贝构造函数，对象会有一个默认的拷贝构造函数，用来对象之间的赋值</span></span><br><span class="line">Student(<span class="keyword">const</span> Student&amp; stu)&#123;<span class="comment">// 常量的引用</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// this-&gt;name = stu.name;// 浅拷贝</span></span><br><span class="line">	<span class="comment">// 如果动态开辟内存，一定要采用深拷贝</span></span><br><span class="line">	<span class="keyword">this</span>-&gt;name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)* <span class="number">100</span>);</span><br><span class="line">	<span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, stu.name);</span><br><span class="line">	<span class="keyword">this</span>-&gt;age = stu.age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/16%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC.png" alt></p>
<ol>
<li><p>= 会调用拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">stu1</span><span class="params">(<span class="string">"Darren"</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line">Student stu2 = stu1; <span class="comment">// = 是赋值，把里面所有定义的属性赋值，c/c++ 编译器帮我们做的，其实会调用对象的拷贝构造</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 以下方式不会调用拷贝构造函数</span></span><br><span class="line">Student stu2;<span class="comment">// 声明变量，开辟变量内存</span></span><br><span class="line">stu2 = stu1; <span class="comment">// 这个不会去调用拷贝构造函数，但是会赋值 c 的类似</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二种场景 作为参数返回的时候会调用拷贝构造函数</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">getStudent</span><span class="params">(<span class="keyword">char</span>* name)</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(name)</span></span>;<span class="comment">// 栈 ，方法执行完，这个对象会被回收，但是发现调用了拷贝构造函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; &amp;stu &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> stu;<span class="comment">// 会返回一个新的 Student 对象，而栈内开辟的 stu 是会被回收 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student stu = getStudent(<span class="string">"Jack"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; &amp;stu &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>第三种场景 作为参数传递的时候会调用拷贝构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student stu)</span></span>&#123;<span class="comment">// stu 是该方法栈中一个新的对象，拷贝构造函数赋值，方法执行完会调用析构函数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu.getName() &lt;&lt; <span class="string">" , "</span> &lt;&lt; stu.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"Darren"</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line">printStudent(stu);</span><br></pre></td></tr></table></figure>








































</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI:05.ndk调试</title>
    <url>/11.JNI%E5%9F%BA%E7%A1%80-ndk%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="1-ndk-stack-调试"><a href="#1-ndk-stack-调试" class="headerlink" title="1. ndk-stack 调试"></a>1. <code>ndk-stack</code> 调试</h1><p>条件：配置 <code>adb</code> 和 <code>ndk</code> 的环境变量.<br>命令：<code>adb logcat | ndk-stack -sym E:\AndroidStudioProjects\MyBintrayLib\NDKPractice\datastructure28bubbkeselectsort\build\intermediates\cmake\debug\obj\arm64-v8a</code> // 路径为有.so库的路径</p>
<p>如果出现：<code>&#39;ndk-stack&#39; 不是内部或外部命令，也不是可运行的程序</code>,则需要去ndk 目录下点击 <code>ndk-gdb.cmd</code>,再关闭程序重新打开尝试</p>
<h1 id="2-addr2line"><a href="#2-addr2line" class="headerlink" title="2. addr2line"></a>2. <code>addr2line</code></h1><p>条件：配置addr2line的环境变量：<br><code>D:\AndroidSdk\ndk\21.2.6472646\toolchains\aarch64-linux-android-4.9\prebuilt\windows-x86_64\bin</code></p>
<p>命令：<br><code>aarch64-linux-android-addr2line -e E:\AndroidStudioProjects\MyBintrayLib\NDKPractice\datastructure28bubbkeselectsort\build\intermediates\cmake\debu
g\obj\arm64-v8a\libnative-lib.so 000000000000fdb8 // 000000000000fdb8是(详细错误)</code></p>
<p>命令最后一位的地址编码请看：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.553</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG: backtrace:</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.554</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG:     #<span class="number">00</span> pc <span class="number">000000000006</span>a784  /system/lib64/libc.so (tgkill+<span class="number">8</span>)</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.554</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG:     #<span class="number">01</span> pc <span class="number">000000000001</span>db50  /system/lib64/libc.so (<span class="built_in">abort</span>+<span class="number">88</span>)</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.554</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG:     #<span class="number">02</span> pc <span class="number">000000000002532</span>c  /system/lib64/libc.so (__libc_fatal+<span class="number">116</span>)</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.554</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG:     #<span class="number">03</span> pc <span class="number">0000000000091</span>c6c  /system/lib64/libc.so (ifree+<span class="number">812</span>)</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.554</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG:     #<span class="number">04</span> pc <span class="number">0000000000091</span>eec  /system/lib64/libc.so (je_free+<span class="number">120</span>)</span><br><span class="line"><span class="comment">// 主要是以下这行，复制他的地址编码到命令中</span></span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.554</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG:     #<span class="number">05</span> pc <span class="number">000000000000f</span>db8  /data/app/com.east.datastructure28bubbkeselectsort-Rq_huZaLg_y9lQEFGFjFuw==/lib/arm64/libnative-lib.so (Java_com_east_datastructure28bubbkeselectsort_MainActivity_stringFromJNI+<span class="number">192</span>)</span><br><span class="line"><span class="number">2020</span><span class="number">-07</span><span class="number">-02</span> <span class="number">16</span>:<span class="number">38</span>:<span class="number">57.554</span> <span class="number">18029</span><span class="number">-18029</span>/? A/DEBUG:     #<span class="number">06</span> pc <span class="number">000000000000f</span>09c  /data/app/com.east.datastructure28bubbkeselectsort-Rq_huZaLg_y9lQEFGFjFuw==/oat/arm64/base.odex (offset <span class="number">0xf000</span>)</span><br></pre></td></tr></table></figure>

<p>坑: <code>如果addr2line的时候，报错 File format not recognized</code></p>
<p>解决:<br>　　1. <font color="red">addr2line的环境变量修改为 arm-linux-androideabi-4.9的：</font><code>D:\AndroidSdk\ndk\21.2.6472646\toolchains\arm-linux-androideabi-4.9\prebuilt\windows-x86_64\bin</code><br>　　<br>　　2. 命令修改为：<code>arm-linux-androideabi-addr2line -e E:\AndroidStudioProjects\MyBintrayLib\NDKPractice\datastructure28bubbkeselectsort\build\intermediates\cmake\debu
g\obj\arm64-v8a\libnative-lib.so 000000000000fdb8 // 000000000000fdb8是(详细错误)</code></p>
]]></content>
      <categories>
        <category>JNI</category>
      </categories>
      <tags>
        <tag>JNI学习</tag>
        <tag>异常</tag>
        <tag>ndk调试</tag>
      </tags>
  </entry>
  <entry>
    <title>C进阶：10.结构体赋值、套指针、深浅拷贝、大小</title>
    <url>/14.C%E8%BF%9B%E9%98%B6-%E7%BB%93%E6%9E%84%E4%BD%93%E8%B5%8B%E5%80%BC%E3%80%81%E5%A5%97%E6%8C%87%E9%92%88%E3%80%81%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E3%80%81%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<h1 id="1-结构体赋值操作"><a href="#1-结构体赋值操作" class="headerlink" title="1. 结构体赋值操作"></a>1. 结构体赋值操作</h1><p><strong><code>结构体赋值相当于是（内容）赋值操作</code></strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Student stu1 = &#123;<span class="string">"Eastrise"</span>,<span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">Student stu2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// strcpy(stu2.name,stu1.name);</span></span><br><span class="line"><span class="comment">// stu2.age = stu1.age;</span></span><br><span class="line"></span><br><span class="line">stu2 = stu1;<span class="comment">// = 赋值操作，java 中 stu2 对象就会变成 stu1</span></span><br><span class="line"><span class="comment">// 在 c 中相当于是（内容）赋值操作，是把 stu1 的值赋值给 stu2;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p,%p\n"</span>,stu1,stu2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s,%d"</span>,stu2.name,stu2.age);</span><br></pre></td></tr></table></figure>

<h1 id="2-结构体套指针"><a href="#2-结构体套指针" class="headerlink" title="2. 结构体套指针"></a>2. 结构体套指针</h1><p>注意：  </p>
<ol>
<li><code>结构体套指针，我们必须对结构体指针进行初始化（赋值）</code></li>
<li><code>如果需要调用 strcpy 给结构体的char* 赋值就必须要开辟内存</code></li>
<li><code>将指针指向常量区的中Eastrise（OK）</code></li>
</ol>
<p>指针占多少个字节：  </p>
<ul>
<li>一个指针在<code>64位</code>的计算机上，占<code>8</code>个字节；</li>
<li>一个指针在<code>32位</code>的计算机上，占<code>4</code>个字节。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name; <span class="comment">// 定义一个 name 指针，name 是可以给任何char*值，结构体的大小怎么算,64位计算机上8字节，32位上4个字节</span></span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">// 4个字节</span></span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stu.name = "Eastrise";// 将指针指向常量区的中Eastrise（OK）</span></span><br><span class="line"></span><br><span class="line">    stu.name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>); <span class="comment">// 如果需要调用 strcpy 给结构体的char* 赋值就必须要开辟内存</span></span><br><span class="line">    <span class="comment">// 结构体套指针，我们必须对结构体指针进行初始化（赋值）</span></span><br><span class="line">    <span class="comment">// 指针可以指向任何地址，但在64位计算机上它的大小永远是 8 个字节，在32位计算机上它的大小永远是 4 字节</span></span><br><span class="line">    <span class="built_in">strcpy</span>(stu.name,<span class="string">"Eastrise"</span>);<span class="comment">// 往 stu.name 中拷贝数据 Eastrise（错误，必须先进行开辟内存才能拷贝）</span></span><br><span class="line"></span><br><span class="line">    stu.age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s,%d,%d"</span>,stu.name,stu.age,<span class="keyword">sizeof</span>(Student)); <span class="comment">// 16个字节？？因为要字节对齐，是8的倍数所以是 16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Eastrise,24,16</span><br></pre></td></tr></table></figure>


<h1 id="3-深拷贝和浅拷贝"><a href="#3-深拷贝和浅拷贝" class="headerlink" title="3. 深拷贝和浅拷贝"></a>3. 深拷贝和浅拷贝</h1><ul>
<li><code>浅拷贝（shallowCopy）</code>：只是增加了一个指针指向已存在的内存地址，</li>
<li><code>深拷贝（deepCopy）</code>：是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* name; <span class="comment">// 定义一个 name 指针，name 是可以给任何char*值，结构体的大小怎么算,64位计算机上8字节，32位上4个字节</span></span><br><span class="line">    <span class="keyword">int</span> age; <span class="comment">// 4个字节</span></span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyTo</span><span class="params">(Student* from,Student* to)</span></span>&#123;</span><br><span class="line">    *to = *from; <span class="comment">// 指针的赋值运算 是一个浅拷贝，都指向的是同一块内存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非得用，就将指针进行深拷贝（系统架构原型设计模式里面）</span></span><br><span class="line">    to-&gt;name = <span class="built_in">malloc</span>(<span class="number">100</span>); <span class="comment">// 开辟一块内存</span></span><br><span class="line">    <span class="built_in">strcpy</span>(to-&gt;name,from-&gt;name); <span class="comment">// 值的拷贝。</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu1;</span><br><span class="line"></span><br><span class="line">    stu1.name = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(stu1.name,<span class="string">"Eastrise"</span>);</span><br><span class="line">    stu1.age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    Student stu2;</span><br><span class="line">    stu2.name = <span class="string">"Jack"</span>;</span><br><span class="line">    stu2.age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    copyTo(&amp;stu1,&amp;stu2); <span class="comment">// 用方法进行拷贝，有问题吗？</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s,%d"</span>,stu2.name,stu2.age);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">if</span>(stu1.name)&#123;</span><br><span class="line">        <span class="built_in">free</span>(stu1.name);</span><br><span class="line">        stu1.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stu2.name)&#123;</span><br><span class="line">        <span class="built_in">free</span>(stu2.name); <span class="comment">// 浅拷贝会释放出错</span></span><br><span class="line">        stu2.name = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Eastrise,24</span><br></pre></td></tr></table></figure>


<h1 id="4-结构体的偏移量强化"><a href="#4-结构体的偏移量强化" class="headerlink" title="4. 结构体的偏移量强化"></a>4. 结构体的偏移量强化</h1><p>结构体大小的偏移量问题：</p>
<ol>
<li>获取内存元素的偏移量 &amp;(stu-&gt;name) - (int)stu</li>
<li>获取结构体的大小 sizeof(student)</li>
<li>大小怎么来的，根据每个的偏移量计算来的 ， 结构体的大小跟内存位置摆放有关</li>
<li><code>把最小的字节数尽量往后靠</code>，结构体一旦定义了不要轻易的去挪动，因为我们只要知道内部任何一个变量的地址，那么就知道了整个结构体</li>
</ol>
<p>大部分情况下：内部偏移量 字节对齐 是针对后面的这个数据来看的</p>
]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：05.虚继承、虚函数、模板函数</title>
    <url>/19.C++%E5%9F%BA%E7%A1%80-%E8%99%9A%E7%BB%A7%E6%89%BF%E3%80%81%E8%99%9A%E5%87%BD%E6%95%B0%E3%80%81%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E3%80%81%E6%A8%A1%E6%9D%BF%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="1-属性初始化"><a href="#1-属性初始化" class="headerlink" title="1. 属性初始化"></a>1. 属性初始化</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// char* courseName;</span></span><br><span class="line">    Course course;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span>* name,<span class="keyword">int</span> age,<span class="keyword">char</span>* courseName):Person(name,age),course(courseName)&#123; <span class="comment">// 初始化父类的属性</span></span><br><span class="line">        <span class="comment">// this-&gt;courseName = courseName;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>  &lt;&lt; name &lt;&lt; <span class="string">","</span> &lt;&lt; age &lt;&lt; <span class="string">","</span> &lt;&lt; course._name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-多继承，（在-java-里面是不允许多继承的，-c-是可以的-但是你也不能有二义性（歧义））"><a href="#2-多继承，（在-java-里面是不允许多继承的，-c-是可以的-但是你也不能有二义性（歧义））" class="headerlink" title="2. 多继承，（在 java 里面是不允许多继承的， c++ 是可以的, 但是你也不能有二义性（歧义））"></a>2. 多继承，（在 java 里面是不允许多继承的， c++ 是可以的, 但是你也不能有二义性（歧义））</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> *name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *_name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Child(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> _age() &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person, <span class="keyword">public</span> Child &#123; <span class="comment">// 多继承，并没有实现</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age) : Person(name), Child(age) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="3-虚继承（二义性）"><a href="#3-虚继承（二义性）" class="headerlink" title="3. 虚继承（二义性）"></a>3. 虚继承（二义性）</h1><p>作用：<code>解决二义性</code>，<code>确保继承过来的相同属性或者函数，只存在一份拷贝</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123; <span class="comment">// 确保继承过来的相同属性或者函数，只存在一份拷贝</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.name = <span class="string">"east"</span>; <span class="comment">// 如果不用虚继承，会报错：不明确 name 是 B 的 还是 C 的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-c-中的多态"><a href="#4-c-中的多态" class="headerlink" title="4. c++ 中的多态"></a>4. c++ 中的多态</h1><p><code>c++</code> 中的多态默认情况下<code>不存在</code>,如果需要使用多态，一定要加上<code>virtual</code> 关键字</p>
<p>c++中多态分两种：  </p>
<ol>
<li>动态多态：子父类继承</li>
<li>静态多态：方法的重载</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Activity</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果没有 virtual 关键字就没有多态</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123; <span class="comment">// 支持多态，虚函数</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Activity 中的 onCreate"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> :</span> <span class="keyword">public</span> Activity &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"MainActivity 中的 onCreate"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Activity *activity1 = <span class="keyword">new</span> MainActivity();</span><br><span class="line">startActivity(activity1);</span><br></pre></td></tr></table></figure>

<h1 id="5-纯虚函数（类似于：java-中的-抽象类，接口）"><a href="#5-纯虚函数（类似于：java-中的-抽象类，接口）" class="headerlink" title="5. 纯虚函数（类似于：java 中的 抽象类，接口）"></a>5. 纯虚函数（类似于：java 中的 抽象类，接口）</h1><p>如果全部都是纯虚函数就类似 java 中的 <code>接口</code>,否则类似 <code>抽象类</code></p>
<p><code>virtual void click() = 0; // 必须要加 = 0</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123; <span class="comment">// 普通函数</span></span><br><span class="line">        initView();</span><br><span class="line">        initData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类必须要实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 虚函数，没有实现的，类似于 java 中的抽象方法，如果子类不实现会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不实现父类的纯虚函数，那么 MainActivity 也会变成抽象类，抽象类不允许实例化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span>:</span><span class="keyword">public</span> BaseActivity&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"initData"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"initView"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickListener</span>&#123;</span> <span class="comment">// 所有的函数都是虚函数，那么就可以认为是接口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 必须要加 = 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="6-构造函数和析构函数"><a href="#6-构造函数和析构函数" class="headerlink" title="6. 构造函数和析构函数"></a>6. 构造函数和析构函数</h1><ul>
<li>构造函数：先父类 -&gt; 再子类</li>
<li>析构函数: 先子类 -&gt; 再父类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数：先父类 -&gt; 再子类</span></span><br><span class="line">    <span class="comment">// 析构函数: 先子类 -&gt; 再父类</span></span><br><span class="line">    Student* stu = <span class="keyword">new</span> Student(<span class="string">"East"</span>,<span class="number">25</span>);</span><br><span class="line">    <span class="keyword">delete</span> (stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-模板函数（java-中的泛型）"><a href="#7-模板函数（java-中的泛型）" class="headerlink" title="7. 模板函数（java 中的泛型）"></a>7. 模板函数（java 中的泛型）</h1><h2 id="7-1-定义："><a href="#7-1-定义：" class="headerlink" title="7.1.定义："></a>7.1.定义：</h2><p><code>template &lt;typename T&gt;  // 模板函数的定义（不能有分号）</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 模板函数的定义（不能有分号）</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T number1,T number2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number1+number2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-2-当普通函数和模板函数同时存在时，优先会调用普通函数"><a href="#7-2-当普通函数和模板函数同时存在时，优先会调用普通函数" class="headerlink" title="7.2. 当普通函数和模板函数同时存在时，优先会调用普通函数"></a>7.2. <strong><code>当普通函数和模板函数同时存在时，优先会调用普通函数</code></strong></h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(<span class="keyword">int</span> number1, <span class="keyword">int</span> number2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"模板函数被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> number1+number2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"int add 被调用"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> number1+number2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// so 是很难被反编译，比 java 安全为啥</span></span><br><span class="line"><span class="comment">// samll 语法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum1 = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> sum2 = add(<span class="number">1.0</span>,<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> sum3 = add(<span class="number">1.0f</span>,<span class="number">2.0f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum1 &lt;&lt; <span class="string">" , "</span> &lt;&lt; sum2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int add 被调用</span><br><span class="line">int add 被调用</span><br><span class="line">int add 被调用</span><br><span class="line">3 , 3</span><br></pre></td></tr></table></figure>

<h1 id="8-模板类"><a href="#8-模板类" class="headerlink" title="8.模板类"></a>8.模板类</h1><p><code>语法跟模板函数非常相似</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Callback</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSucceed</span><span class="params">(T result)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; result &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类继承</span></span><br><span class="line"><span class="comment">// 如果子类不是模板类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpCallback</span> :</span> <span class="keyword">public</span> Callback&lt;<span class="keyword">int</span>&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类还是模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpCallback</span> :</span> <span class="keyword">public</span> Callback&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：03.可变参数、static、对象大小和友元类、函数</title>
    <url>/17.C++%E5%9F%BA%E7%A1%80-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E3%80%81static%E3%80%81%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%8F%8B%E5%85%83%E7%B1%BB%E3%80%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="1-可变参数"><a href="#1-可变参数" class="headerlink" title="1. 可变参数"></a>1. 可变参数</h1><p>java中：<code>int ...</code><br>c++：<code>...</code></p>
<ul>
<li><code>va_start(vp,count);</code>：将可变参数放到va_list vp中去，这个宏必须在使用 va_arg 和 va_end 之前被调用。</li>
<li><code>int number = va_arg(vp,int);</code>: 获取可变参数，如果超出了可获取的范围默认就为0</li>
<li><code>va_end(vp);</code>：结束了释放内存。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count,...)</span></span>&#123;<span class="comment">// java：int ..., c++： ...</span></span><br><span class="line">    va_list vp;</span><br><span class="line">    <span class="comment">// 可变参数开始方法， count 最后一个传递给函数的已知的固定参数。</span></span><br><span class="line">    va_start(vp,count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number = va_arg(vp,<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取下一个</span></span><br><span class="line">    number = va_arg(vp,<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取下一个，超出了默认是 0</span></span><br><span class="line">    number = va_arg(vp,<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结尾，释放内存</span></span><br><span class="line">    va_end(vp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     sum(<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> count,...)</span></span>&#123;<span class="comment">// java：int ..., c++： ...</span></span><br><span class="line">    va_list vp;</span><br><span class="line">    <span class="comment">// 可变参数开始方法， count 最后一个传递给函数的已知的固定参数。</span></span><br><span class="line">    va_start(vp,count);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;count;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> number = va_arg(vp,<span class="keyword">int</span>);</span><br><span class="line">        sum += number;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">"："</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结尾，释放内存</span></span><br><span class="line">    va_end(vp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = sum(<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>); <span class="comment">// 7</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0：1</span><br><span class="line">1：2</span><br><span class="line">2：4</span><br><span class="line">3：0</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h1 id="2-static-关键字"><a href="#2-static-关键字" class="headerlink" title="2. static 关键字"></a>2. static 关键字</h1><p>总结：</p>
<ol>
<li>静态的属性定义时<strong><code>必须要初始化</code></strong> （实现） <code>int Student::tag = 12;</code></li>
<li>静态 可以直接用类名去操作 ::   <code>Student::tag += 12;</code></li>
<li>静态的方法只能去操作静态的属性或者方法</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//静态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> tag; <span class="comment">// 定义</span></span><br><span class="line"></span><br><span class="line">    Student()&#123;</span><br><span class="line">        tag = <span class="number">12</span>; <span class="comment">// 这里不算初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tag += <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span> -&gt; change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态属性在 c++ 中必须要初始化，初始化必须这么写</span></span><br><span class="line"><span class="keyword">int</span> Student::tag = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态 可以直接用类名去操作 ：：</span></span><br><span class="line"><span class="comment">//      静态的属性必须初始化（实现）</span></span><br><span class="line"><span class="comment">//      静态的方法只能去操作静态的属性或方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// stu.tag = 12;</span></span><br><span class="line">    <span class="comment">// c++ 操作静态语法 ::</span></span><br><span class="line">    <span class="comment">// Student::tag += 12;</span></span><br><span class="line">    <span class="comment">// Student::change();</span></span><br><span class="line">    stu.change1();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;Student::tag &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure>



<h1 id="3-对象大小"><a href="#3-对象大小" class="headerlink" title="3. 对象大小"></a>3. 对象大小</h1><ol>
<li>对象的大小与结构体的计算方式类似</li>
<li>static 静态变量和方法并没有算到类的大小中</li>
<li>栈，堆，全局（静态，常量，字符串），代码区 ，类的大小只与普通属性有关系</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    C(<span class="keyword">int</span> a)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 对象的大小与结构体的计算方式类似</span></span><br><span class="line"><span class="comment">// 2. static 静态变量和方法并没有算到类的大小中</span></span><br><span class="line"><span class="comment">// 3. 栈、堆、全局（静态、常量、字符串），代码区，类的大小只与普通属性有关系</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"A 的大小： "</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"B 的大小： "</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"C 的大小： "</span> &lt;&lt; <span class="keyword">sizeof</span>(C) &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    <span class="function">C <span class="title">c2</span><span class="params">(<span class="number">24</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c1.getA() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c2.getA() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A 的大小： 16</span><br><span class="line">B 的大小： 16</span><br><span class="line">C 的大小： 16</span><br><span class="line">12</span><br><span class="line">24</span><br></pre></td></tr></table></figure>



<h1 id="4-this-指针"><a href="#4-this-指针" class="headerlink" title="4. this 指针"></a>4. this 指针</h1><p><code>this 指针：代表当前的对象，因为类的方法放在代码区，大家一起共享的，所以要有 this 做区分</code></p>
<h1 id="5-const-修饰函数"><a href="#5-const-修饰函数" class="headerlink" title="5.const 修饰函数"></a>5.const 修饰函数</h1><p><code>const 在 () 之后主要用来限制 this 关键字</code>,<code>this</code> 的值和地址都不能修改</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this = const Student* const this</span></span><br><span class="line"><span class="comment">// 第一个 const : 常量指针， 代表值不能修改</span></span><br><span class="line"><span class="comment">// 第二个 const : 指针常量，代表指针的地址不能修改</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// const 在 () 之后主要用来限制 this 关键字</span></span><br><span class="line">    <span class="comment">// this-&gt;age + = 12;</span></span><br><span class="line">    <span class="comment">// this = (Student)0x0012;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-友元函数"><a href="#6-友元函数" class="headerlink" title="6.友元函数"></a>6.友元函数</h1><p>作用：<code>友元函数是可以在外部访问其私有属性的</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">	 <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 如果有自己写构造函数，那么会默认覆盖无参的构造函数</span></span><br><span class="line">	Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 友元函数的声明</span></span><br><span class="line">	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">friend_change</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 友元函数的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">friend_change</span><span class="params">(Person *person, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 修改一下 age 的值</span></span><br><span class="line">	<span class="comment">// 在类的内部才能访问私有属性</span></span><br><span class="line">	<span class="comment">// 如果该方法声明成友元函数那么是可以在外部访问其私有属性的</span></span><br><span class="line">	person-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person person = Person(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">    friend_change(&amp;person,<span class="number">36</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.getAge() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure>

<p>注意：调用的时候<code>不</code>使用 <code>类名::</code></p>
<h2 id="6-1-友元函数与普通函数的区别"><a href="#6-1-友元函数与普通函数的区别" class="headerlink" title="6.1 友元函数与普通函数的区别"></a>6.1 友元函数与普通函数的区别</h2><ul>
<li>友元函数：直接<code>方法名</code>调用。</li>
<li>普通函数：需要<code>对象名::</code>+<code>方法名</code> 调用</li>
</ul>
<h1 id="7-友元类"><a href="#7-友元类" class="headerlink" title="7.友元类"></a>7.友元类</h1><p>作用：<code>友元类是可以在访问其附属类的私有属性</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">ImageView</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// B 是 A 的友元类</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	ImageView aObj;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">changeA</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		aObj.a = number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getA</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> aObj.a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class b;</span><br><span class="line">    b.changeA(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; b.getA() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C进阶：08.指针赋值、野指针、项目开发模型强化</title>
    <url>/12.C%E8%BF%9B%E9%98%B6-%E5%9B%9B%E9%A9%B1%E6%A8%A1%E5%9E%8B%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88%E3%80%81%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%BC%BA%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-内存四驱模型"><a href="#1-内存四驱模型" class="headerlink" title="1. 内存四驱模型"></a>1. 内存四驱模型</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change1</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123; <span class="comment">// 不能修改</span></span><br><span class="line">    number = <span class="number">300</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,&amp;number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 a 的值</span></span><br><span class="line"></span><br><span class="line">    a = <span class="number">200</span>;</span><br><span class="line">    change1(a); <span class="comment">// a变量的值复制给了 number 变量，number 是在另一个函数中，number 是一个新的变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"change1：a = %d\n"</span>,a); <span class="comment">// a = 200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/12.1%E9%97%B4%E6%8E%A5%E8%B5%8B%E5%80%BC.png" alt></p>
<h1 id="2-指针间接赋值的意义"><a href="#2-指针间接赋值的意义" class="headerlink" title="2. 指针间接赋值的意义"></a>2. 指针间接赋值的意义</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change2</span><span class="params">(<span class="keyword">int</span>* number)</span></span>&#123; <span class="comment">//  可以</span></span><br><span class="line">    *number = <span class="number">300</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    change2(&amp;a); <span class="comment">//  a 的地址复制给了 number 变量，number 是在另一个函数中，number 是一个新的变量</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"change2：a = %d\n"</span>,a); <span class="comment">// a = 300;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getchar();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/12.2%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E9%97%B4%E6%8E%A5%E8%B5%8B%E5%80%BC.png" alt></p>
<p>在做开发的时候，离不开指针，指针出现的意义有很多，其中一种就是通过方法去修改值 :</p>
<ol>
<li>获取Bitmap信息</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AndroidBitmapInfo android_bitmap_info; <span class="comment">// 结构体</span></span><br><span class="line">AndroidBitmap_getInfo(env,bitmap,&amp;android_bitmap_info);<span class="comment">// 通过 getInfo 方法去获取 Bitmap 的属性</span></span><br><span class="line"><span class="comment">// 获取Bitmap的 宽，高，format</span></span><br><span class="line"><span class="keyword">int</span> bitmap_width = android_bitmap_info.<span class="built_in">width</span>;</span><br><span class="line"><span class="keyword">int</span> bitmap_height = android_bitmap_info.<span class="built_in">height</span>;</span><br></pre></td></tr></table></figure>

<p><code>c 和 java 的方法不同所在，c 可以传对象的地址在方法里面去赋值，java 一般都是通过返回值</code></p>
<p>java 写法：<br>　　<code>AndroidBitmapInfo android_bitmap_info = AndroidBitmap_getInfo(env,bitmap);</code></p>
<h1 id="3-野指针和-null-地址"><a href="#3-野指针和-null-地址" class="headerlink" title="3. 野指针和 null 地址"></a>3. 野指针和 null 地址</h1><p><code>野指针</code>:指 释放了指针对应的内存地址后，没有把指针置为 NULL</p>
<p><code>NULL</code> : NULL 相当于指向 <code>0x00000000</code>,这块地方是 c 和 c++ 编译器所持有的，不能在这块区域赋值</p>
<p>strcpy(p,”string”);<br>p=”string”;<br><code>第一个是把string赋值给p，第二个是p指向“string”的首地址。</code></p>
<p><img src="/images/12.3%E9%87%8E%E6%8C%87%E9%92%88.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 写入位置 0x00000000 时发生访问冲突</span></span><br><span class="line">    <span class="keyword">char</span>* p1 = <span class="literal">NULL</span>; <span class="comment">// p1 = NULL,NUll 也是地方，指针指向 NULL 相当于指向 0x00000000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是我们不能对 0x00000000 去操作，这块地方是 c 和 c++ 编译器所持有的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Student student = null; 不用纠结 null 是啥，跟 c 和 c++ 有点类似</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,<span class="string">"1122"</span>); <span class="comment">// 把 1122 赋值给p1 NUll的位置，这是错误的</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p1 = %s"</span>,p1); <span class="comment">// Null的地址不能操作</span></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-字符串强化"><a href="#4-字符串强化" class="headerlink" title="4. 字符串强化"></a>4. 字符串强化</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// char buff[100] = &#123;'e','a','s','t','r','i','s','e'&#125;;// 后面 8 - 99 都是默认值 0</span></span><br><span class="line">    <span class="comment">// char buff[5] = &#123;'e','a','s','t','r'&#125;;</span></span><br><span class="line">    <span class="comment">// char buff[] = &#123;'e','a','s','t','r'&#125;; // 长度是 12（'\0'）, size 是 5（默认统计里面的个数）</span></span><br><span class="line">    <span class="comment">// char buff[2] = &#123;'e','a','s','t','r'&#125;; // 编译不通过，长度超出</span></span><br><span class="line">    <span class="comment">// char buff[100] = &#123; 0 &#125;; // 把数组初始化为 0</span></span><br><span class="line">    <span class="comment">// char buff[100] 数据都是默认值 -52</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">char</span> buff[] = <span class="string">"123456"</span>; <span class="comment">// len 是 6（'\0'）,size 是 7</span></span><br><span class="line">    <span class="comment">// 相当于 char buff[] = &#123;1,2,3,4,5,6,\0&#125;</span></span><br><span class="line"><span class="comment">//    char* buff= "123456"; // len==6, size==8（64位系统指针占8字节）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 纠结一下 char buff[] = "123456" 和 char* buff= "123456"; malloc 的方式 啥区别 ？</span></span><br><span class="line">    <span class="comment">// 字符串可以在任何地方开辟内存，栈区，堆区，常量区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大小 size 100</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(buff);<span class="comment">// len 5 碰到 '\0' 就结束了</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(buff);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"len = %d , size = %d\n"</span>,len,<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内容</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d,%d,%d"</span>,buff[<span class="number">0</span>],buff[<span class="number">66</span>],buff[<span class="number">99</span>],buff[<span class="number">77</span>]);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/12.4%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B9%8B%E5%A4%84.png" alt></p>
<h1 id="5-项目开发模型强化"><a href="#5-项目开发模型强化" class="headerlink" title="5. 项目开发模型强化"></a>5. 项目开发模型强化</h1><ol>
<li>确定你的参数，传递指针</li>
<li>一定要考虑健壮性</li>
<li>要异常错误进行抛出说明 萤视频 ffmpeg</li>
<li>不要直接轻易的去改变调用传递给你的指针</li>
</ol>
]]></content>
      <categories>
        <category>C知识</category>
      </categories>
      <tags>
        <tag>C学习</tag>
        <tag>C进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：07.类型转换、实现System.arrayCopy、异常处理</title>
    <url>/21.C++%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E5%AE%9E%E7%8E%B0System.arrayCopy%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-类型转换"><a href="#1-类型转换" class="headerlink" title="1. 类型转换"></a>1. 类型转换</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student *stu = <span class="keyword">static_cast</span>&lt;Student*&gt;(person); <span class="comment">// 正确</span></span><br><span class="line">Student stu = <span class="keyword">static_cast</span>&lt;Student&gt;(person); <span class="comment">// 错误</span></span><br><span class="line"></span><br><span class="line">Student *stu = <span class="keyword">reinterpret_cast</span>&lt;Student*&gt;(person); <span class="comment">// 正确</span></span><br><span class="line">Student stu = <span class="keyword">reinterpret_cast</span>&lt;Student&gt;(person); <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="1-1-static-cast-静态转换"><a href="#1-1-static-cast-静态转换" class="headerlink" title="1.1 static_cast 静态转换"></a>1.1 static_cast <code>静态转换</code></h2><ul>
<li><code>非指针情况下：子类可以转换成父类，父类不能转换成子类，指针情况下可以</code></li>
<li><code>用于基本数据类型之间的转换，如把int转换成char</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name,<span class="keyword">int</span> age):name(name),age(age)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name,<span class="keyword">int</span> age):Person(name,age)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static_cast(静态转换 类似于 直接转换)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> number1 = <span class="number">20.02</span>;</span><br><span class="line">    <span class="comment">// 直接转换</span></span><br><span class="line">    <span class="comment">// int number2 = number1;</span></span><br><span class="line">    <span class="comment">// 用于基本数据类型之间的转换，例如把 int 转 char</span></span><br><span class="line">    <span class="comment">// int number2 = static_cast&lt;int&gt;(number1);</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; number2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把类型转换成另一种类型，用于类层次结构中基类和派生类之间指针或引用的转换</span></span><br><span class="line">    <span class="comment">// Student *stu = new Student("eastrise",26);</span></span><br><span class="line">    <span class="comment">// Person *person = stu;</span></span><br><span class="line">    <span class="comment">// Person *person = static_cast&lt;Person*&gt;(stu); // ok的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待会再试</span></span><br><span class="line">    Person person = Person(<span class="string">"eastrise"</span>,<span class="number">26</span>);</span><br><span class="line">    <span class="comment">// 转成 Student</span></span><br><span class="line">    <span class="comment">// Student stu = person; // 错误</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person.name.c_str() &lt;&lt; <span class="string">" , "</span> &lt;&lt; person.age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-const-cast-常量转换"><a href="#1-2-const-cast-常量转换" class="headerlink" title="1.2. const_cast 常量转换"></a>1.2. const_cast <code>常量转换</code></h2><p>用于修改常量的值（<code>转换成了不是常量的指针然后去修改值</code>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> Person* person = <span class="keyword">new</span> Person(<span class="string">"eastrise"</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person-&gt;name.c_str() &lt;&lt; <span class="string">" , "</span> &lt;&lt; person-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// person-&gt;age = 24;</span></span><br><span class="line">    <span class="comment">// const_cast</span></span><br><span class="line">    Person* person1 = <span class="keyword">const_cast</span>&lt;Person*&gt;(person);</span><br><span class="line">    person1-&gt;age = <span class="number">25</span>;</span><br><span class="line">    person1-&gt;name = <span class="string">"Jack"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; person1-&gt;name.c_str() &lt;&lt; <span class="string">" , "</span> &lt;&lt; person1-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-reinterpret-cast-强制类型转换"><a href="#1-3-reinterpret-cast-强制类型转换" class="headerlink" title="1.3. reinterpret_cast 强制类型转换"></a>1.3. reinterpret_cast <code>强制类型转换</code></h2><p>用于转换任意类型</p>
<ul>
<li><code>非指针情况下：子类可以转换成父类，父类不能转换成子类，指针情况下可以</code></li>
<li><code>jni</code> 中常见的是 <code>long</code> 转 <code>指针</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 待会再试</span></span><br><span class="line">    Person *person = <span class="keyword">new</span> Person(<span class="string">"eastrise"</span>,<span class="number">26</span>);</span><br><span class="line">    <span class="comment">// 转成 Student</span></span><br><span class="line">    <span class="comment">// Student stu = person; // 错误</span></span><br><span class="line">    <span class="comment">// Student *stu = static_cast&lt;Student*&gt;(person); // 正确</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> mPtr = (<span class="keyword">long</span>)person; <span class="comment">// NDK中可以</span></span><br><span class="line">    <span class="comment">// 除了字符类，各种类型的转换  long -&gt; 对象的指针* ，用到reinterpret_cast</span></span><br><span class="line">    <span class="comment">// 与 static_Cast 区别在于 static_cast 一般用于转换有继承关系的类型 reinterpret_cast 也能转换有继承关系的类型</span></span><br><span class="line">    Student *stu = <span class="keyword">reinterpret_cast</span>&lt;Student*&gt;(person);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu-&gt;name.c_str() &lt;&lt; <span class="string">" , "</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-dynamic-cast-动态转换"><a href="#1-4-dynamic-cast-动态转换" class="headerlink" title="1.4. dynamic_cast 动态转换"></a>1.4. dynamic_cast <code>动态转换</code></h2><p><code>必须要包含多态类型</code> ,虽然<code>更安全</code>，<code>转换成功返回类型，失败返回空</code> ，<br>      和 <code>static_cast</code> 很类似，但是更安全</p>
<p>static_cast <code>一般用于转换有继承关系的类型</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student *stu = <span class="keyword">new</span> Student(<span class="string">""</span>,<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">    Person *worker = <span class="keyword">dynamic_cast</span>&lt;Person* &gt;(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-native-层实现-System-arrayCopy-的功能"><a href="#2-native-层实现-System-arrayCopy-的功能" class="headerlink" title="2. native 层实现 System.arrayCopy  的功能"></a>2. native 层实现 System.arrayCopy  的功能</h1><p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/cpp21" target="_blank" rel="noopener">NDKPractice项目的cpp21</a></strong></p>
<ul>
<li><code>jobject  obj = env-&gt;GetObjectArrayElement(src_array,srcPos+i);</code>：获取jobjectArray中下标为srcPos+i的数据。</li>
<li><code>env-&gt;SetObjectArrayElement(dest_array,destPos+i,obj);</code>：设置jobjectArray中下标为destPos+i的数据为obj</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_darren_ndk_day26_MainActivity_arraycopy(JNIEnv *env, jclass type, jobject src, jint srcPos,</span><br><span class="line">                                                 jobject dest, jint destPos, jint length) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做一些列的判断 ，是不是数组</span></span><br><span class="line">    <span class="comment">// 做一系列的准备工作 ，如果有异常，挂了，程序是会崩掉</span></span><br><span class="line">    <span class="comment">// buggly  so库报错 ，如果有抛 java 层的异常，是可以 try ，但是很多情况下并不会抛java层的异常</span></span><br><span class="line">    <span class="comment">// 如果没抛 java 层的异常，在 java 层 try 了 依旧会蹦</span></span><br><span class="line">    <span class="comment">// src</span></span><br><span class="line">    <span class="comment">// dest</span></span><br><span class="line">    <span class="comment">// 都是 java 数组，需要类型转换 reinterpret_cast static_cast dynamic_cast(最佳)</span></span><br><span class="line">    <span class="comment">// dynamic_cast 但是必须包含多态类型</span></span><br><span class="line">    jobjectArray src_array = <span class="keyword">reinterpret_cast</span>&lt;jobjectArray&gt;(src);</span><br><span class="line">    jobjectArray dest_array = <span class="keyword">reinterpret_cast</span>&lt;jobjectArray&gt;(dest);</span><br><span class="line">    <span class="keyword">if</span>(src_array &amp;&amp; dest_array)&#123;</span><br><span class="line">        __android_log_print(ANDROID_LOG_ERROR,<span class="string">"TAG"</span>,<span class="string">"转换成功"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; length ; i ++)&#123;</span><br><span class="line">            jobject  obj = env-&gt;GetObjectArrayElement(src_array,srcPos+i);</span><br><span class="line">            <span class="comment">// 放到新数组里面</span></span><br><span class="line">            env-&gt;SetObjectArrayElement(dest_array,destPos+i,obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3. 异常处理"></a>3. 异常处理</h1><ul>
<li>c++ 中有自己一套异常的体系，不要去强记 <a href="https://www.cnblogs.com/QG-whz/p/5136883.html" target="_blank" rel="noopener">c++自己的异常</a></li>
<li>但是 c++ 可以抛任何数据类型 <code>try{}catch(数据类型 变量名){}</code></li>
<li>throw 抛异常</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// c++ 中有自己一套异常的体系，不要去强记</span></span><br><span class="line">    <span class="comment">// 但是 c++ 可以抛任何数据类型 try&#123;&#125;catch(数据类型 变量名)&#123;&#125;</span></span><br><span class="line">    <span class="comment">// throw 抛异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> Exception(<span class="string">"出异常了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="number">12.5f</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">int</span> number) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕捉到异常"</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕捉到异常："</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"捕捉到其它异常"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>NDK 异常总结:  </p>
<ol>
<li>在 c++ 层如果是自己写的代码或者调用别人的方法，记得要 try 住， 如果不 try 在 java 层 try 是没有意义的</li>
<li>如果异常需要往外抛给 java 层，一定要按照java层抛异常的方式</li>
<li>如果是自己写的 NDK 层的代码，最好抛自己写的异常，声明异常</li>
<li>如果是做 c++/c , 或者是帮 c/c++ 写代码，最好抛系统定义好的异常或者继承系统的异常</li>
<li>系统异常的体系  exception 基类  <a href="https://www.cnblogs.com/QG-whz/p/5136883.html" target="_blank" rel="noopener">https://www.cnblogs.com/QG-whz/p/5136883.html</a></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_method</span><span class="params">()</span> <span class="title">throw</span><span class="params">(Exception,<span class="keyword">int</span>)</span></span>&#123; <span class="comment">// 如果是自己写的， 1000 多行</span></span><br><span class="line">    <span class="keyword">throw</span> Exception(<span class="string">"异常了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c_method();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception exception)&#123;</span><br><span class="line">        <span class="comment">// 这个异常可以抛给 java 层，但是要抛成 java 层的异常</span></span><br><span class="line">        jclass  je = env-&gt;FindClass(<span class="string">"java/lang/Exception"</span>);</span><br><span class="line">        env -&gt;ThrowNew(je,exception.what());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-NDK异常处理增强"><a href="#4-NDK异常处理增强" class="headerlink" title="4.NDK异常处理增强"></a>4.NDK异常处理增强</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exception</span> :</span> <span class="keyword">public</span> out_of_range &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Exception(<span class="built_in">string</span> mag) : out_of_range(mag) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Exception() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"析构函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">c_method</span><span class="params">()</span> </span>&#123; <span class="comment">// 如果是自己的写，1000 多行</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"抛异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"异常了"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c_method();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception *e) &#123;</span><br><span class="line">        <span class="comment">// Exception：多次构造函数和析构函数</span></span><br><span class="line">        <span class="comment">// Exception&amp;：避免了多次创建对象（最多的）</span></span><br><span class="line">        <span class="comment">// Exception*：创建的对象会被析构，如果使用局部函数或者成员就会是一个野指针</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"try异常"</span> &lt;&lt; e-&gt;what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"其它异常"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：06.反转单链表、实现ArrayList</title>
    <url>/20.C++%E5%9F%BA%E7%A1%80-%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%81%E5%AE%9E%E7%8E%B0ArrayList/</url>
    <content><![CDATA[<h1 id="1-腾讯面试题："><a href="#1-腾讯面试题：" class="headerlink" title="1. 腾讯面试题："></a>1. 腾讯面试题：</h1><ol>
<li><p>用 c/c++ 反转单链表   </p>
<ul>
<li><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>
</li>
<li><p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">struct ListNode *<span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">newHead</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">node</span>;</span></span><br><span class="line">	<span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">//1. 对之前的链表做头删</span></span><br><span class="line">		node = head;</span><br><span class="line">		head = head-&gt;next;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2. 对新链表做头插</span></span><br><span class="line">		node-&gt;next = newHead;</span><br><span class="line">		newHead = node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>用 c/c++ 判断一棵树是否为平衡二叉树 （<strong>可以是一棵空树，左右子树的高度差不会超过 1 ，并且左右两棵子树都是一棵平衡二叉树</strong>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  判断一棵树是否是平衡二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">isBalanceTree</span>(<span class="title">TreeNode</span>&lt;T&gt; *<span class="title">pNode</span>)&#123;</span></span><br><span class="line">    <span class="comment">// 可以是一棵空树，左右子树的高度差不会超过 1 ，并且左右两棵子树都是一棵平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!pNode)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树的高度差不会超过 1</span></span><br><span class="line">    <span class="keyword">int</span> left = getDepthTree(pNode-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = getDepthTree(pNode-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并且左右两棵子树都是一棵平衡二叉树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(left-right) &lt;= <span class="number">1</span> &amp;&amp; isBalanceTree(pNode-&gt;left) &amp;&amp; isBalanceTree(pNode-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="2-ArrayList-源码分析"><a href="#2-ArrayList-源码分析" class="headerlink" title="2. ArrayList 源码分析"></a>2. ArrayList 源码分析</h1><p>重点：<code>如果开发中涉及到模板类，声明和实现要写到同一个类中，hpp = h + cpp/c (编译)</code></p>
<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/cpp20" target="_blank" rel="noopener">NDKPractice项目的cpp20</a></strong></p>
<p>或者请看： jni/<code>20.C++基础-实现Native层的ArrayList</code></p>
<p><code>java中ArrayList</code>知识点：  </p>
<ol>
<li><strong>如果未指定容量大小的话，默认容量是 <code>10</code></strong></li>
<li><strong>每次扩容都是扩充的原来的一半 <code>oldCapacity + (oldCapacity &gt;&gt; 1);</code></strong></li>
</ol>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> JNI20_ARRAYLIST_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> JNI20_ARRAYLIST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="comment">//------------------------ 声明 ------------------------//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ArrayList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 长度，数组，当前交表</span></span><br><span class="line">    E *<span class="built_in">array</span> = <span class="literal">NULL</span>;      <span class="comment">// 当前数组指针</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;   <span class="comment">// 数组大小</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 当前角标</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ArrayList();</span><br><span class="line"></span><br><span class="line">    ArrayList(<span class="keyword">int</span> len);</span><br><span class="line"></span><br><span class="line">    ~ArrayList();</span><br><span class="line"></span><br><span class="line">    ArrayList(<span class="keyword">const</span> ArrayList&amp; <span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------ 实现 ------------------------//</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayList</span>&lt;E&gt;:</span>:ArrayList() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个方法都得添加</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayList</span>&lt;E&gt;:</span>:ArrayList(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span>(len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;len = len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">array</span> = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayList</span>&lt;E&gt;:</span>:~ArrayList() &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span>)&#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayList</span>&lt;E&gt;:</span>:ArrayList(<span class="keyword">const</span> ArrayList &amp;<span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;len = <span class="built_in">list</span>.len;</span><br><span class="line">    <span class="keyword">this</span>-&gt;index = <span class="built_in">list</span>.index;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span>)&#123;</span><br><span class="line">       <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*<span class="built_in">list</span>.len);</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span>,<span class="built_in">list</span>.<span class="built_in">array</span>, <span class="keyword">sizeof</span>(E)*index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">ArrayList</span>&lt;E&gt;:</span>:<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayList</span>&lt;E&gt;:</span>:add(E e) &#123;</span><br><span class="line">    ensureCapacityInternal(index+<span class="number">1</span>); <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">array</span>[index++] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayList</span>&lt;E&gt;:</span>:ensureCapacityInternal(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">        capacity = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span>(capacity &gt; <span class="keyword">this</span>-&gt;len)&#123;</span><br><span class="line">        <span class="comment">// 创建新数组</span></span><br><span class="line">        grow(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayList</span>&lt;E&gt;:</span>:grow(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    <span class="keyword">int</span> new_len = len + (len &gt;&gt; <span class="number">1</span>); <span class="comment">// 扩容 len的一半</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(capacity &gt; new_len)&#123;</span><br><span class="line">        new_len = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的数组</span></span><br><span class="line">    E* new_array = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*new_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span>)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(new_array,<span class="keyword">this</span>-&gt;<span class="built_in">array</span>,<span class="keyword">sizeof</span>(E)* index); <span class="comment">// sizeof(E)*index 字节</span></span><br><span class="line">        <span class="comment">// 释放旧的array</span></span><br><span class="line">        <span class="built_in">free</span>(<span class="keyword">this</span>-&gt;<span class="built_in">array</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">array</span> = new_array;</span><br><span class="line">    <span class="keyword">this</span>-&gt;len = new_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">ArrayList</span>&lt;E&gt;:</span>:<span class="built_in">get</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">ArrayList</span>&lt;E&gt;:</span>:<span class="built_in">remove</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    E e = <span class="built_in">array</span>[index];</span><br><span class="line">    <span class="keyword">int</span> numMoved = <span class="keyword">this</span>-&gt;index - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; index + numMoved ;i++)&#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="built_in">array</span>[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">array</span>[--<span class="keyword">this</span>-&gt;index] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// JNI20_ARRAYLIST_H</span></span></span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习，面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：08.string、c++const增强和引用本质分析</title>
    <url>/22.C++%E5%9F%BA%E7%A1%80-string%E3%80%81c++const%E5%A2%9E%E5%BC%BA%E5%92%8C%E5%BC%95%E7%94%A8%E6%9C%AC%E8%B4%A8%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-string-常见操作"><a href="#1-string-常见操作" class="headerlink" title="1. string 常见操作"></a>1. string 常见操作</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; // STL 算法包</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;   // 用到一个函数指针，回调函数</span></span></span><br></pre></td></tr></table></figure>

<h2 id="1-1-string创建"><a href="#1-1-string创建" class="headerlink" title="1.1.string创建"></a>1.1.string创建</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"123"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"123"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str3</span><span class="params">(<span class="number">5</span>,<span class="string">'A'</span>)</span></span>; <span class="comment">// 5 个 A = AAAAA</span></span><br><span class="line"><span class="built_in">string</span> *str4 = <span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="1-2-string-与-char-互转"><a href="#1-2-string-与-char-互转" class="headerlink" title="1.2. string 与 char* 互转"></a>1.2. string 与 char* 互转</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// string 转 char* c_str();</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* c_str1 = str1.c_str();</span><br><span class="line"></span><br><span class="line"><span class="comment">// char* 转 string</span></span><br><span class="line"><span class="keyword">char</span>* c_str = <span class="string">"east"</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(c_str)</span></span>; <span class="comment">// 对象</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-遍历"><a href="#1-3-遍历" class="headerlink" title="1.3. 遍历"></a>1.3. 遍历</h2><p><code>str.at(i)</code> 和 <code>str[i]</code>，区别在于 <code>str.at(i)</code>如果数组越界会报异常，而<code>str[i]</code>不一定</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length() + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str.at(i) &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 如果越界会抛异常</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length() + <span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 不会报错！！！，会导致程序宕机，AS里面是可以的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"异常了"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"1234567"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 1. 字符串的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it = str.<span class="built_in">begin</span>(); it &lt; str.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-添加"><a href="#1-4-添加" class="headerlink" title="1.4. 添加"></a>1.4. 添加</h2><ol>
<li><code>str1 = str1 + str2;</code></li>
<li><code>str1 = str1.append(str2);</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">"123"</span>;</span><br><span class="line">    <span class="built_in">string</span> str2 = <span class="string">"456"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     str1 = str1 + str2;    </span></span><br><span class="line">     str1 = str1.append(str2);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">123456</span><br></pre></td></tr></table></figure>

<h2 id="1-5-删除"><a href="#1-5-删除" class="headerlink" title="1.5. 删除"></a>1.5. 删除</h2><ul>
<li><code>str1.erase(it);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"123 abc 123 abc 123"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// str1.erase(0,3);// 第一个参数：从哪里开始，第二个参数：删除几个（默认值，字符串结尾）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器删除 2 bc 123 abc 123 解释</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it = str1.<span class="built_in">begin</span>(); it&lt;str1.<span class="built_in">begin</span>()+<span class="number">3</span>; it++)&#123; <span class="comment">// 删除一个节后都会从头开始计算</span></span><br><span class="line">    str1.erase(it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 删除一个节后都会从头开始计算</span><br><span class="line">2 bc 123 abc 123</span><br></pre></td></tr></table></figure>

<h2 id="1-6-替换"><a href="#1-6-替换" class="headerlink" title="1.6. 替换"></a>1.6. 替换</h2><ul>
<li><code>str1.replace(0,6,&quot;1234&quot;);</code>：从0开始，替换6个字符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"123 abc 123 abc 123"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数：从哪里开始</span></span><br><span class="line"><span class="comment">// 第二个参数：替换几个</span></span><br><span class="line"><span class="comment">// 第三个参数：替换成谁</span></span><br><span class="line">str1.replace(<span class="number">0</span>,<span class="number">6</span>,<span class="string">"1234"</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1234c 123 abc 123</span><br></pre></td></tr></table></figure>

<h2 id="1-7-查找"><a href="#1-7-查找" class="headerlink" title="1.7. 查找"></a>1.7. 查找</h2><ul>
<li><code>str1.find(&quot;123&quot;,0);</code>：// 查找谁，从哪里开始</li>
<li><code>str1.rfind(&quot;123&quot;);</code>：// 从后面往前找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1 = <span class="string">"123 abc 123 abc 123"</span>;</span><br><span class="line"><span class="comment">// 查找谁，从哪里开始</span></span><br><span class="line"><span class="comment">// int position = str1.find("123",0);</span></span><br><span class="line"><span class="comment">// 从后面往前找</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">position</span> = str1.rfind(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,16</span><br></pre></td></tr></table></figure>

<h2 id="1-8-大小写转换"><a href="#1-8-大小写转换" class="headerlink" title="1.8. 大小写转换"></a>1.8. 大小写转换</h2><ul>
<li><code>transform(str1.begin(),str1.end(),str1.begin(),::toupper);</code>：转大写</li>
<li><code>transform(str1.begin(),str1.end(),str1.begin(),::tolower);</code>：转小写</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str1 = <span class="string">"AAA abc BBB abc 123"</span>;</span><br><span class="line">    <span class="comment">// 转换成大写</span></span><br><span class="line">    transform(str1.<span class="built_in">begin</span>(),str1.<span class="built_in">end</span>(),str1.<span class="built_in">begin</span>(),::<span class="built_in">toupper</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转小写</span></span><br><span class="line">    transform(str1.<span class="built_in">begin</span>(),str1.<span class="built_in">end</span>(),str1.<span class="built_in">begin</span>(),::<span class="built_in">tolower</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; str1.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-c-相对-c-的一些增强"><a href="#2-c-相对-c-的一些增强" class="headerlink" title="2. c++ 相对 c 的一些增强"></a>2. c++ 相对 c 的一些增强</h1><h2 id="2-1-实用性增强"><a href="#2-1-实用性增强" class="headerlink" title="2.1 实用性增强"></a>2.1 实用性增强</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">a=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b; <span class="comment">// 有的编译器不通过， c++ 中肯定能通过</span></span><br><span class="line">b = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-register-增强-c中报错，c-可以通过"><a href="#2-2-register-增强-c中报错，c-可以通过" class="headerlink" title="2.2 register 增强(c中报错，c++可以通过)"></a>2.2 register 增强(c中报错，c++可以通过)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寄存器上面的变量不能取地址，register 快速</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// c中报错，c++可以通过</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">getchar();</span><br></pre></td></tr></table></figure>

<h2 id="2-3-参数增强-以下代码，c中没问题，c-中会检测报错"><a href="#2-3-参数增强-以下代码，c中没问题，c-中会检测报错" class="headerlink" title="2.3 参数增强 (以下代码，c中没问题，c++中会检测报错)"></a>2.3 参数增强 (以下代码，c中没问题，c++中会检测报错)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数处理增强</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a);<span class="comment">// c中没问题，c++中会检测报错</span></span><br><span class="line">    </span><br><span class="line">        getchar();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-检测增强-以下代码，c中没问题，c-中会检测报错"><a href="#2-4-检测增强-以下代码，c中没问题，c-中会检测报错" class="headerlink" title="2.4 检测增强 (以下代码，c中没问题，c++中会检测报错)"></a>2.4 检测增强 (以下代码，c中没问题，c++中会检测报错)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测增强</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,f()); <span class="comment">// c中没问题，c++中会检测报错</span></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-const-关键字"><a href="#3-const-关键字" class="headerlink" title="3. const 关键字"></a>3. const 关键字</h1><p>const 使用场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 修饰变量不可改变</span></span><br><span class="line"><span class="comment">// const int number = 1;</span></span><br><span class="line"><span class="comment">// 修饰指针 常量指针，指针常量</span></span><br><span class="line"><span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const int *n_p = &amp;number;</span></span><br><span class="line"><span class="comment">// *n_p = 3; // 常量指针不能改变值</span></span><br><span class="line"><span class="comment">// 指针常量</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> n_p = &amp;number;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">200</span>;</span><br><span class="line"><span class="comment">// n_p = &amp;a; // 指针常量不能修改值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造函数，操作符重载，方法后面（都是由于它的成员不可改变）</span></span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li>c 里面 const 是一个伪命题，可以通过指针去操作，编译时期的检测</li>
<li>c++ 里面不光在编译时期做处理，还在运行时做了处理</li>
</ul>
<h1 id="4-引用加强"><a href="#4-引用加强" class="headerlink" title="4. 引用加强"></a>4. 引用加强</h1><p>其实引用的本质就是 <code>指针</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name) : name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> &amp;<span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="comment">// java 想都别想</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu = Student(<span class="string">"eastrise"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改不动</span></span><br><span class="line">    <span class="comment">// stu.getName() = "Jack";</span></span><br><span class="line"></span><br><span class="line">    stu.getName() = <span class="string">"Jack"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stu.getName() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// vector front back</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：09.STL容器的基本介绍和使用</title>
    <url>/23.C++%E5%9F%BA%E7%A1%80-STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://en.cppreference.com/w/cpp/container/sets" target="_blank" rel="noopener">学习精华：集合底层的数据结构原理</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br></pre></td></tr></table></figure>


<h1 id="1-vector-容器"><a href="#1-vector-容器" class="headerlink" title="1. vector 容器"></a>1. vector 容器</h1><p>(1). 容量  </p>
<ul>
<li>向量大小： vec.size();</li>
<li>向量真实大小： vec.capacity();</li>
<li>向量判空： vec.empty();</li>
</ul>
<p>(2). 修改  </p>
<ul>
<li>末尾添加元素： vec.push_back();</li>
<li>末尾删除元素： vec.pop_back();</li>
<li>任意位置插入元素： vec.insert();</li>
<li>任意位置删除元素： vec.erase();</li>
<li>清空向量元素： vec.clear();</li>
</ul>
<p>(3)迭代器</p>
<ul>
<li>开始指针：vec.begin();</li>
<li>末尾指针：vec.end(); //指向最后一个元素的下一个位置</li>
<li>指向常量的末尾指针： vec.cend();</li>
</ul>
<p>(4)元素的访问</p>
<ul>
<li>下标访问： vec[1]; //并不会检查是否越界</li>
<li>at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常</li>
<li>访问第一个元素： vec.front();</li>
<li>访问最后一个元素： vec.back();</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="comment">// vector 数组</span></span><br><span class="line">    <span class="comment">// vector</span></span><br><span class="line">    <span class="comment">// 1. vector&lt;int&gt; v;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. vector&lt;int&gt; v(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. vector&lt;int&gt; v(10,0);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据</span></span><br><span class="line">    <span class="comment">// v.begin(); // 迭代器的开始位置</span></span><br><span class="line">    v.insert(v.<span class="built_in">begin</span>(),<span class="number">12</span>);</span><br><span class="line">    v.insert(v.<span class="built_in">begin</span>(),<span class="number">22</span>);</span><br><span class="line">    v.insert(v.<span class="built_in">begin</span>(),<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    v.insert(v.<span class="built_in">end</span>(),<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用当左值当右值（修改）</span></span><br><span class="line">    v.front() = <span class="number">33</span>;</span><br><span class="line">    v.back() = <span class="number">44</span>;</span><br><span class="line"></span><br><span class="line">    v.push_back(<span class="number">55</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除最后的元素，并没有返回值</span></span><br><span class="line">    <span class="comment">// v.pop_back();</span></span><br><span class="line">    <span class="comment">// 通过迭代器位置进行移除</span></span><br><span class="line">    <span class="comment">// v.erase(v.begin());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取数据 for 循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[i] &lt;&lt; <span class="string">"\t"</span>; <span class="comment">// 越界程序宕机,clion 和 AS中不一定出错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v.at(i) &lt;&lt; <span class="string">"\t"</span>; <span class="comment">// 越界抛异常 out_of_range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">"\t"</span>; <span class="comment">// 越界抛异常 out_of_range</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-stack-容器（先进后出）"><a href="#2-stack-容器（先进后出）" class="headerlink" title="2. stack 容器（先进后出）"></a>2. stack 容器（先进后出）</h1><p><code>不能通过角标或迭代器去循环值</code></p>
<ul>
<li>压栈：s.push(12);</li>
<li>获取顶部元素：s.top(); </li>
<li>弹栈顶部元素：s.pop();</li>
<li>判空： s.empty();</li>
</ul>
<h1 id="3-queue-容器（先进先出）"><a href="#3-queue-容器（先进先出）" class="headerlink" title="3. queue 容器（先进先出）"></a>3. queue 容器（先进先出）</h1><ul>
<li>添加元素：s.push(12);</li>
<li>访问第一个元素： q.front();</li>
<li>访问最后一个元素： q.back();</li>
<li>弹出第一个元素：q.pop();</li>
</ul>
<h1 id="4-优先级队列-priority-queue"><a href="#4-优先级队列-priority-queue" class="headerlink" title="4. 优先级队列 priority_queue"></a>4. 优先级队列 priority_queue</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int 存放的数据 vector&lt;int&gt; 数据类型（数组） greater 从大到小 less 从小到大</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; pq;</span><br><span class="line">pq.push(<span class="number">12</span>);</span><br><span class="line">pq.push(<span class="number">44</span>);</span><br><span class="line">pq.push(<span class="number">32</span>);</span><br><span class="line">pq.push(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大值 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pq.top() &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<h1 id="5-list-容器-链表，双向链表"><a href="#5-list-容器-链表，双向链表" class="headerlink" title="5. list 容器(链表，双向链表)"></a>5. list 容器(链表，双向链表)</h1><p><code>不能通过角标去访问</code></p>
<p>插入：  </p>
<ul>
<li>开头插入：l.push_front(11);</li>
<li>末尾插入：l.push_back(22);</li>
<li>指定的iterator位置插入：l.insert(l.begin(),10);</li>
</ul>
<p>修改：  </p>
<ul>
<li>修改最后一个元素：l.back() = 33;</li>
<li>修改最开头的元素：l.front() = 44;</li>
</ul>
<p>移除：  </p>
<ul>
<li>移除指定位置上元素：l.erase(l.begin());</li>
<li>移除开头元素：l.pop_front();</li>
<li>移除末尾元素：l.pop_back();</li>
</ul>
<p>循环：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = l.<span class="built_in">begin</span>(); it != l.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-set-容器"><a href="#6-set-容器" class="headerlink" title="6. set 容器"></a>6. set 容器</h1><p><code>set 容器（红黑树结构），会对你存入的数据进行排序，但是不允许元素相同</code></p>
<ul>
<li><code>set&lt;int, greater&lt;int&gt;&gt; s;</code>：排序从大到小</li>
<li><code>set&lt;int, less&lt;int&gt;&gt; s;</code>：排序从大到小</li>
<li><code>pair&lt;set&lt;int,greater&lt;int&gt;&gt;::iterator ,bool&gt; res = s.insert(5);</code>：插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set&lt;int, less&lt;int&gt;&gt; s; // 从小到大排序，默认就是 less</span></span><br><span class="line">   <span class="built_in">set</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; s; <span class="comment">// 从大到小</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加参数， 不需要用迭代器，也不需要指定位置</span></span><br><span class="line">   s.insert(<span class="number">3</span>);</span><br><span class="line">   s.insert(<span class="number">5</span>);</span><br><span class="line">   s.insert(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 重复的插入，并不会报错，返回两个值 插入迭代器的位置，是否插入功</span></span><br><span class="line">   pair&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator ,<span class="keyword">bool</span>&gt; res = s.insert(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// res.first;// 获取第一个参数</span></span><br><span class="line">   <span class="keyword">bool</span> insert_succeed = res.second;</span><br><span class="line">   <span class="keyword">if</span>(insert_succeed)&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"插入失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = s.count(<span class="number">5</span>);</span><br><span class="line">   <span class="comment">// s.find();</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; :: iterator it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it ++)&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-函数谓词和函数对象"><a href="#7-函数谓词和函数对象" class="headerlink" title="7.函数谓词和函数对象"></a>7.函数谓词和函数对象</h1><p>函数谓词：<code>按照特定的规则所表写的函数谓词</code></p>
<p>函数对象：有函数重载了<code>（）</code>运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> grade;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Student(<span class="built_in">string</span> name,<span class="keyword">int</span> grade):name(name),grade(grade)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 谓词（函数谓词）：按照特定的规则所表写的函数谓词</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Student&amp; _Left,<span class="keyword">const</span> Student&amp; _Right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _Left.grade &gt; _Right.grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象 仿函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comparefuction</span>&#123;</span></span><br><span class="line">    <span class="comment">// 函数重载了（）运算符，函数对象，仿函数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Student&amp; _Left,<span class="keyword">const</span> Student&amp; _Right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _Left.grade &gt; _Right.grade; <span class="comment">// 从大到小</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本数据类型，对象数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;Student,comparefuction&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"eastrise"</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="string">"eastrise"</span>,<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">"eastrise"</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s.insert(s1);</span><br><span class="line">    s.insert(s2);</span><br><span class="line">    s.insert(s3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;Student&gt;::iterator it = s.<span class="built_in">begin</span>(); it!=s.<span class="built_in">end</span>(); it ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; it-&gt;name &lt;&lt; <span class="string">","</span> &lt;&lt; it-&gt;grade &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-multiset容器"><a href="#8-multiset容器" class="headerlink" title="8. multiset容器"></a>8. multiset容器</h1><p><code>multiset容器 , 允许重复 ，用法和 set 一样</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set&lt;int,less&lt;int&gt;&gt;;// 从小到大排序，默认就是 less</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; ms;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加参数， 不需要用迭代器，也不需要指定位置</span></span><br><span class="line">ms.insert(<span class="number">3</span>);</span><br><span class="line">ms.insert(<span class="number">5</span>);</span><br><span class="line">ms.insert(<span class="number">4</span>);</span><br><span class="line">ms.insert(<span class="number">4</span>);</span><br><span class="line">ms.insert(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ms.<span class="built_in">begin</span>(); it != ms.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：10.map、函数对象、一元、二元谓词</title>
    <url>/24.C++%E5%9F%BA%E7%A1%80-map%E3%80%81%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E3%80%81%E4%B8%80%E5%85%83%E3%80%81%E4%BA%8C%E5%85%83%E8%B0%93%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="1-map"><a href="#1-map" class="headerlink" title="1. map"></a>1. <a href="https://en.cppreference.com/w/cpp/container/map" target="_blank" rel="noopener">map</a></h1><p><code>map 不能存 key 重复的数据，要么不生效，要么覆盖</code></p>
<p><code>map 会对 key 排序，二叉数算法</code></p>
<h2 id="1-1-添加数据："><a href="#1-1-添加数据：" class="headerlink" title="1.1. 添加数据："></a>1.1. 添加数据：</h2><ul>
<li><code>map1.insert(pair&lt;int,string&gt;(01,&quot;01&quot;));</code> // 重复添加<code>不会覆盖值</code></li>
<li><code>map1.insert(make_pair(02,&quot;02&quot;));</code> // 重复添加<code>不会覆盖值</code></li>
<li><code>map1.insert(map&lt;int,string&gt;::value_type(03,&quot;03&quot;));</code> // 重复添加<code>不会覆盖值</code></li>
<li><code>map1[04] = &quot;04&quot;</code> // 重复添加<code>会覆盖</code> </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt; map1;</span><br><span class="line"></span><br><span class="line">map1.insert(pair&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;(<span class="number">01</span>,<span class="string">"01"</span>));</span><br><span class="line">map1.insert(make_pair(<span class="number">02</span>,<span class="string">"02"</span>));</span><br><span class="line">map1.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::value_type(<span class="number">03</span>,<span class="string">"03"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//区别，如果用前面三种 key 重复添加，不生效</span></span><br><span class="line"><span class="comment">// map1.insert(map&lt;int,string&gt;::value_type(03,"30"));// 无效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种方式 = map[key] = value</span></span><br><span class="line">map1[<span class="number">04</span>] = <span class="string">"04"</span>;</span><br><span class="line"><span class="comment">// 这种方式会覆盖</span></span><br><span class="line">map1[<span class="number">04</span>] = <span class="string">"40"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-判断是否添加成功"><a href="#1-2-判断是否添加成功" class="headerlink" title="1.2.判断是否添加成功:"></a>1.2.判断是否添加成功:</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator,<span class="keyword">bool</span>&gt; p = map1.insert(make_pair(<span class="number">06</span>,<span class="string">"06"</span>));</span><br><span class="line"><span class="keyword">if</span>(p.second)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"添加成功"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"添加失败"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-循环："><a href="#1-3-循环：" class="headerlink" title="1.3.循环："></a>1.3.循环：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环迭代器</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" - "</span> &lt;&lt; it-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-删除："><a href="#1-4-删除：" class="headerlink" title="1.4.删除："></a>1.4.删除：</h2><p><code>auto</code>：可以推到出类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; c = &#123;&#123;<span class="number">1</span>, <span class="string">"one"</span>&#125;, &#123;<span class="number">2</span>, <span class="string">"two"</span>&#125;, &#123;<span class="number">3</span>, <span class="string">"three"</span>&#125;,</span><br><span class="line">                                    &#123;<span class="number">4</span>, <span class="string">"four"</span>&#125;, &#123;<span class="number">5</span>, <span class="string">"five"</span>&#125;, &#123;<span class="number">6</span>, <span class="string">"six"</span>&#125;&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// erase all odd numbers from c</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it = c.<span class="built_in">begin</span>(); it != c.<span class="built_in">end</span>(); ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it-&gt;first % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            it = c.erase(it);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++it;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; p : c) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; p.second &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5查找："><a href="#1-5查找：" class="headerlink" title="1.5查找："></a>1.5查找：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator find_it = map1.<span class="built_in">find</span>(<span class="number">0</span>); <span class="comment">// 0指的是key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// cout &lt;&lt; find_it-&gt;first &lt;&lt; " - " &lt;&lt; find_it-&gt;second.c_str() &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span>(find_it!=map1.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; find_it-&gt;first &lt;&lt; <span class="string">" - "</span> &lt;&lt; find_it-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">" 找不到 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-multimap"><a href="#2-multimap" class="headerlink" title="2. multimap"></a>2. <a href="https://en.cppreference.com/w/cpp/container/multimap" target="_blank" rel="noopener">multimap</a></h1><p><code>multimap 可存 key 重复的数据</code>, 基本操作与 <code>map</code> 类似<br><code>multimap</code> 是没有排序的</p>
<p>遍历和分组查询：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = map1.<span class="built_in">begin</span>(); it != map1.<span class="built_in">end</span>(); it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" - "</span> &lt;&lt; it-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">" 遍历结束 "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分组查询 多个数据</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,<span class="built_in">string</span>&gt;::iterator find_it = map1.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">while</span>(find_it!=map1.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; find_it-&gt;first &lt;&lt; <span class="string">" - "</span> &lt;&lt; find_it-&gt;second.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    find_it ++;</span><br><span class="line">    <span class="comment">// 不是我们要找的内容</span></span><br><span class="line">    <span class="keyword">if</span>(find_it == map1.<span class="built_in">end</span>() || find_it -&gt; first != <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"到底了"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-容器存对象"><a href="#3-容器存对象" class="headerlink" title="3. 容器存对象"></a>3. 容器存对象</h1><p><code>java</code> 和 <code>c++</code> 的区别：<br>java: <code>java</code> 中把对象添加到了集合,这个对象发送了改变，集合中的对象也会发生改变，他们是同一块地址<br>c++：中会调用对象的拷贝构造函数，<code>存进去的是另一个对象</code></p>
<p>c++ 中容器中存对象需要注意的点：  </p>
<ol>
<li>没有默认的构造函数</li>
<li>析构函数也可能回调多次，如果说在析构函数中释放内存，需要在拷贝构造函数中进行深拷贝</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Person&gt; vector1;</span><br><span class="line"></span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(<span class="string">"eastrise"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会调用对象的拷贝构造函数，存进去的是另一个对象</span></span><br><span class="line">    vector1.push_back(person);</span><br><span class="line"></span><br><span class="line">    person.setName(<span class="string">"Jack"</span>);</span><br><span class="line"></span><br><span class="line">    Person p1 = vector1.back();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p1.name.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-函数对象"><a href="#4-函数对象" class="headerlink" title="4. 函数对象"></a>4. 函数对象</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&#123;</span></span><br><span class="line">    <span class="comment">// 重载了括号操作符</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"仿函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compare1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"普通函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 函数对象（仿函数） 一元谓词，二元谓词</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Compare compare;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跟函数非常类似</span></span><br><span class="line">    compare();</span><br><span class="line">    <span class="comment">// 普通函数调用</span></span><br><span class="line">    compare1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-一元谓词"><a href="#5-一元谓词" class="headerlink" title="5. 一元谓词"></a>5. 一元谓词</h1><p>定义：重载<code>()</code>，并且需要传递<code>1</code>个参数,常返回int值用于计数</p>
<ul>
<li><code>printObj = for_each(set1.begin(),set1.end(),printObj);</code>：最后一个参数传一元函数对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仿函数 - 一元谓词（能够记录状态）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintObj</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数和仿函数的区别</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set1;</span><br><span class="line"></span><br><span class="line">    set1.insert(<span class="number">1</span>);</span><br><span class="line">    set1.insert(<span class="number">2</span>);</span><br><span class="line">    set1.insert(<span class="number">3</span>);</span><br><span class="line">    set1.insert(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for_each 迭代器，非常重要的一点就是：仿函数如果要保存记录状态，要确保对象一致，可以用返回值</span></span><br><span class="line">    <span class="comment">// for_each(set1.begin(),set1.end(),print);</span></span><br><span class="line">    PrintObj printObj;</span><br><span class="line">    <span class="comment">// 如果不用返回值，那么printObj 和 </span></span><br><span class="line">    printObj = for_each(set1.<span class="built_in">begin</span>(),set1.<span class="built_in">end</span>(),printObj);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"个数："</span> &lt;&lt; printObj.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-二元谓词"><a href="#6-二元谓词" class="headerlink" title="6. 二元谓词"></a>6. 二元谓词</h1><p>定义：重载<code>()</code>，并且需要传递<code>2</code>个参数,常返回bool值用于算法判断条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareObj</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> str1,<span class="keyword">const</span> <span class="built_in">string</span> str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1 &lt; str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 二元谓词的仿函数</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>,CompareObj&gt; set1;</span><br><span class="line">    set1.insert(<span class="string">"aaa"</span>);</span><br><span class="line">    set1.insert(<span class="string">"aAa"</span>);</span><br><span class="line">    set1.insert(<span class="string">"ccc"</span>);</span><br><span class="line">    set1.insert(<span class="string">"ddd"</span>);</span><br><span class="line">    <span class="comment">// 是否包含 aaa ， 遍历比较 ， 找方法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::iterator it = set1.<span class="built_in">begin</span>();it != set1.<span class="built_in">end</span>(); it ++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (*it).c_str() &lt;&lt;  <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：11.C++中常用函数对象</title>
    <url>/25.C++%E5%9F%BA%E7%A1%80-C++%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/6badcff31c50" target="_blank" rel="noopener">源码阅读和追踪</a></p>
<h1 id="仿函数"><a href="#仿函数" class="headerlink" title="仿函数"></a>仿函数</h1><p><code>必须重载()运算符</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Equal</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> equal_number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Equal(<span class="keyword">int</span> equal_number):equal_number(equal_number)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equal_number == number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="1-预定义函数对象和函数适配器-bind2nd"><a href="#1-预定义函数对象和函数适配器-bind2nd" class="headerlink" title="1. 预定义函数对象和函数适配器(bind2nd)"></a>1. 预定义函数对象和函数适配器(bind2nd)</h1><p>c/c++ 提供了很多定义好的函数对象,常见的几个 <code>less</code>, <code>greater</code>, <code>plus</code>, <code>equal_to</code>，这些都是二元函数</p>
<p><strong>bind1st和bind2nd是将二元函数转换为一元函数，比如一个比较大小的函数是二元函数。</strong> 当在某些情况下我们想要固定第一个参数或者第二个参数时，就成了一元函数</p>
<ul>
<li><code>bind2nd(equal_to&lt;string&gt;(),&quot;aaa&quot;)</code></li>
<li><code>set&lt;string&gt; :: iterator  find_it = find_if(set1.begin(),set1.end(),bind2nd(equal_to&lt;string&gt;(),&quot;aaa&quot;));</code>// 查找是否包含<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// c/c++ 提供了很多定义好的函数对象</span></span><br><span class="line">    <span class="comment">// 常见的几个 less, greater , plus , equal_to</span></span><br><span class="line">    plus&lt;<span class="built_in">string</span>&gt; strAdd;</span><br><span class="line">    <span class="built_in">string</span> str = strAdd(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; str.c_str() &lt;&lt; endl; // aaabbb</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>,greater&lt;<span class="built_in">string</span>&gt;&gt; set1;</span><br><span class="line">    set1.insert(<span class="string">"aaa"</span>);</span><br><span class="line">    set1.insert(<span class="string">"bbb"</span>);</span><br><span class="line">    set1.insert(<span class="string">"ccc"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是不是包含 aaa</span></span><br><span class="line">    <span class="comment">// 怎么写仿函数，一定要确定好你的仿函数的参数</span></span><br><span class="line">    <span class="comment">// bind2nd 函数适配器， aaa 相当于 equal_to 中的 right</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; :: iterator  find_it = find_if(set1.<span class="built_in">begin</span>(),set1.<span class="built_in">end</span>(),bind2nd(equal_to&lt;<span class="built_in">string</span>&gt;(),<span class="string">"aaa"</span>));</span><br><span class="line">    <span class="keyword">if</span>(find_it!=set1.<span class="built_in">end</span>())&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"找到了"</span> &lt;&lt; (*find_it).c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="2-自定义仿函数（函数对象）-和-count-if"><a href="#2-自定义仿函数（函数对象）-和-count-if" class="headerlink" title="2.自定义仿函数（函数对象） 和 count_if"></a>2.自定义仿函数（函数对象） 和 count_if</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Equal</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> equal_number;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Equal(<span class="keyword">int</span> equal_number):equal_number(equal_number)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> equal_number == number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count_if</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line">    vector1.push_back(<span class="number">1</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">3</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">4</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找集合中 等于 2 的个数</span></span><br><span class="line">    <span class="keyword">int</span> count = count_if(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),Equal(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定义好的函数对象 +  函数适配器</span></span><br><span class="line">    count = count_if(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),bind2nd(equal_to&lt;<span class="keyword">int</span>&gt;(),<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"count = "</span> &lt;&lt; count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count &#x3D; 3</span><br><span class="line">count &#x3D; 3</span><br></pre></td></tr></table></figure>

<h1 id="3-foreach-transform"><a href="#3-foreach-transform" class="headerlink" title="3. foreach, transform"></a>3. foreach, transform</h1><ul>
<li><code>transform(vector1.begin(),vector1.end(),vector2.begin(),transform_print);</code>：修改</li>
<li><code>for_each(vector2.begin(),vector2.end(),print);</code>：循环遍历元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行修改</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transform_print</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; number &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line">    vector1.push_back(<span class="number">1</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">3</span>);</span><br><span class="line">    vector1.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for_each(vector1.begin(),vector1.end(),print);</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector2;</span><br><span class="line">    vector2.resize(vector1.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    transform(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),vector2.<span class="built_in">begin</span>(),transform_print);</span><br><span class="line"></span><br><span class="line">    for_each(vector2.<span class="built_in">begin</span>(),vector2.<span class="built_in">end</span>(),<span class="built_in">print</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h1 id="4-find-find-if"><a href="#4-find-find-if" class="headerlink" title="4. find, find_if"></a>4. find, find_if</h1><ul>
<li><code>find(first, end, value);</code>：返回区间[first,end)中第一个值等于value的元素的位置。如果没有找到匹配元素，则返回end。(只能判断等于)</li>
<li><code>find_if (begin, end, func)</code>：从begin开始 ，到end为止，返回第一个让 func这个函数返回true的iterator。（所有判断都可以）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line">vector1.push_back(<span class="number">1</span>);</span><br><span class="line">vector1.push_back(<span class="number">2</span>);</span><br><span class="line">vector1.push_back(<span class="number">3</span>);</span><br><span class="line">vector1.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator find_it = <span class="built_in">find</span>(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span>(find_it!=vector1.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"包含"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"不包含"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有没有大于2的，自定义函数对象，预定义函数对象+函数适配器，省略</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator find_it1 = find_if(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">4</span>));</span><br><span class="line"><span class="keyword">while</span>(find_it1!=vector1.<span class="built_in">end</span>())&#123;</span><br><span class="line">    <span class="keyword">if</span>(*find_it1&gt;=<span class="number">4</span>)&#123;</span><br><span class="line">        find_it1++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *find_it1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    find_it1++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">包含</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h1 id="5-count，count-if"><a href="#5-count，count-if" class="headerlink" title="5. count，count_if"></a>5. count，count_if</h1><ul>
<li><code>count(first, end, value);</code>：返回区间[first,end)中值等于value的元素的个数。(只能判断等于)</li>
<li><code>count_if(begin, end, func)</code>：从begin开始 ，到end为止，返回让 func这个函数返回true的元素个数。（所有判断都可以）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line">    vector1.push_back(<span class="number">1</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">3</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> number = count(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"等于2的个数："</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    number = count_if(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),bind2nd(less&lt;<span class="keyword">int</span>&gt;(),<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"小于2的个数："</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    number = count_if(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),bind2nd(greater&lt;<span class="keyword">int</span>&gt;(),<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"大于2的个数："</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">等于2的个数：2</span><br><span class="line">小于2的个数：1</span><br><span class="line">大于2的个数：2</span><br></pre></td></tr></table></figure>

<h1 id="6-merge"><a href="#6-merge" class="headerlink" title="6. merge"></a>6. merge</h1><ul>
<li><code>merge(vector1.begin(),vector1.end(),vector2.begin(),vector2.end(),vector3.begin());</code>：合并元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">merge</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> number1,<span class="keyword">int</span> number2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 两个有序数组进行合并 - 归并排序</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line">    vector1.push_back(<span class="number">1</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector2;</span><br><span class="line">    vector2.push_back(<span class="number">4</span>);</span><br><span class="line">    vector2.push_back(<span class="number">5</span>);</span><br><span class="line">    vector2.push_back(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector3;</span><br><span class="line">    vector3.resize(<span class="number">6</span>);</span><br><span class="line">    merge(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),vector2.<span class="built_in">begin</span>(),vector2.<span class="built_in">end</span>(),vector3.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line">    for_each(vector3.<span class="built_in">begin</span>(),vector3.<span class="built_in">end</span>(),<span class="built_in">print</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h1 id="7-sort"><a href="#7-sort" class="headerlink" title="7. sort"></a>7. sort</h1><ul>
<li><code>sort(vector1.begin(),vector1.end(),less&lt;int&gt;());</code>：按照从小到大的方式排序</li>
<li><code>random_shuffle(vector1.begin(),vector1.end());</code>：打乱 vector1的顺序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line">    vector1.push_back(<span class="number">1</span>);</span><br><span class="line">    vector1.push_back(<span class="number">3</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    sort(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">    for_each(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),<span class="built_in">print</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打乱顺序</span></span><br><span class="line">    random_shuffle(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>());</span><br><span class="line">    for_each(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),<span class="built_in">print</span>);</span><br></pre></td></tr></table></figure>

<h1 id="8-copy，replace"><a href="#8-copy，replace" class="headerlink" title="8. copy，replace"></a>8. copy，replace</h1><ul>
<li><code>copy(vector1.begin(),vector1.begin()+2,vector2.begin());</code>：将vector1的前两位拷贝到vector2中，从vector2的开始位置拷入。</li>
<li><code>replace(vector1.begin(),vector1.end(),2,22);</code>：将vector1中等于2的值替换成22</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vector1;</span><br><span class="line">    vector1.push_back(<span class="number">1</span>);</span><br><span class="line">    vector1.push_back(<span class="number">2</span>);</span><br><span class="line">    vector1.push_back(<span class="number">3</span>);</span><br><span class="line">    vector1.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vector2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    copy(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">begin</span>()+<span class="number">2</span>,vector2.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="comment">// for_each(vector2.begin(),vector2.end(),print);</span></span><br><span class="line"></span><br><span class="line">    replace(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),<span class="number">2</span>,<span class="number">22</span>);</span><br><span class="line">    for_each(vector1.<span class="built_in">begin</span>(),vector1.<span class="built_in">end</span>(),<span class="built_in">print</span>);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>C++：04.操作符重载和类的继承</title>
    <url>/18.C++%E5%9F%BA%E7%A1%80-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%92%8C%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="1-操作符重载"><a href="#1-操作符重载" class="headerlink" title="1. 操作符重载"></a>1. 操作符重载</h1><p><code>一般来讲我们定义在类的里面</code></p>
<p>格式：<strong>返回值 <code>operate</code>需要重载的操作符(参数){}</strong> 例如：void operator++(){}</p>
<h2 id="1-1-加减操作符"><a href="#1-1-加减操作符" class="headerlink" title="1.1 加减操作符"></a>1.1 加减操作符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(<span class="keyword">const</span> Vector &amp;<span class="built_in">vector</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="built_in">vector</span>.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="built_in">vector</span>.y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载减号运算符</span></span><br><span class="line">    <span class="comment">// 为什么要用引用，为了防止重新创建对象</span></span><br><span class="line">    <span class="comment">// const 关键常量，为了防止去修改值</span></span><br><span class="line">    Vector <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector &amp;<span class="built_in">vector</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x - <span class="built_in">vector</span>.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y - <span class="built_in">vector</span>.y;</span><br><span class="line">        <span class="function">Vector <span class="title">res</span><span class="params">(x, y)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> res; <span class="comment">// 不建议返回引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector <span class="keyword">operator</span> + (<span class="keyword">const</span> Vector &amp;<span class="built_in">vector</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="keyword">this</span>-&gt;x + <span class="built_in">vector</span>.x;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="keyword">this</span>-&gt;y + <span class="built_in">vector</span>.y;</span><br><span class="line">        <span class="function">Vector <span class="title">vector</span><span class="params">(x,y)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Vector <span class="title">vector1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">    <span class="function">Vector <span class="title">vector2</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java 中 string + string;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char* str = "123" + "456";</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载运算符 -</span></span><br><span class="line">    Vector <span class="built_in">vector</span> = vector1 - vector2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">vector</span>.getX() &lt;&lt; <span class="string">" , "</span> &lt;&lt; <span class="built_in">vector</span>.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0,0</span><br></pre></td></tr></table></figure>

<h2 id="1-2-自增减运算符"><a href="#1-2-自增减运算符" class="headerlink" title="1.2 自增减运算符"></a>1.2 自增减运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(<span class="keyword">const</span> Vector &amp;<span class="built_in">vector</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="built_in">vector</span>.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="built_in">vector</span>.y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自增运算符</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>++() &#123; <span class="comment">// ++X</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x = ++<span class="keyword">this</span>-&gt;x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = ++<span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; <span class="comment">// X++</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="keyword">this</span>-&gt;x++;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="keyword">this</span>-&gt;y++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector <span class="title">vector</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="comment">// vector++;</span></span><br><span class="line">    ++<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">vector</span>.getX() &lt;&lt; <span class="string">" , "</span> &lt;&lt; <span class="built_in">vector</span>.getY() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 , 3</span><br></pre></td></tr></table></figure>


<h2 id="1-3-输出运算符"><a href="#1-3-输出运算符" class="headerlink" title="1.3 输出运算符"></a>1.3 输出运算符</h2><p>定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector(<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector(<span class="keyword">const</span> Vector &amp;<span class="built_in">vector</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = <span class="built_in">vector</span>.x;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = <span class="built_in">vector</span>.y;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"拷贝构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出运算符</span></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;_Ostr, <span class="keyword">const</span> Vector <span class="built_in">vector</span>) &#123;</span><br><span class="line">        _Ostr &lt;&lt; <span class="built_in">vector</span>.x &lt;&lt; <span class="string">" , "</span> &lt;&lt; <span class="built_in">vector</span>.y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> _Ostr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Vector <span class="title">vector</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这么使用</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">vector</span> &lt;&lt; <span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">拷贝构造函数</span><br><span class="line">拷贝构造函数</span><br><span class="line">1 , 2</span><br><span class="line">1 , 2</span><br></pre></td></tr></table></figure>

<h2 id="1-4-条件运算符"><a href="#1-4-条件运算符" class="headerlink" title="1.4 条件运算符"></a>1.4 条件运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 条件运算符</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector &amp;<span class="built_in">vector</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>-&gt;x == <span class="built_in">vector</span>.x &amp;&amp; <span class="keyword">this</span>-&gt;y == <span class="built_in">vector</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-括号运算符"><a href="#1-5-括号运算符" class="headerlink" title="1.5 括号运算符"></a>1.5 括号运算符</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作符[]</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">array</span>[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-类继承"><a href="#2-类继承" class="headerlink" title="2. 类继承"></a>2. 类继承</h1><h2 id="2-1-变量修饰符和继承修饰符"><a href="#2-1-变量修饰符和继承修饰符" class="headerlink" title="2.1 变量修饰符和继承修饰符"></a>2.1 变量修饰符和继承修饰符</h2><p>变量修饰符：  </p>
<ol>
<li><code>private</code> ：本类中使用</li>
<li><code>protected</code> ：子类中能使用（默认）</li>
<li><code>public</code> ：公开，任何地方都可以</li>
</ol>
<p>类继承修饰符：  </p>
<ol>
<li><code>private</code> ：本类中使用</li>
<li><code>protected</code> ：子类中能使用（默认）</li>
<li><code>public</code> ：公开，任何地方都可以</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加了 public 才可以访问 Person 中的公有属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-初始化父类属性"><a href="#2-2-初始化父类属性" class="headerlink" title="2.2 初始化父类属性"></a>2.2 初始化父类属性</h2><p><code>不光可以给父类初始化属性，还可以给本类的属性进行初始化，用 , 隔开即可</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">char</span> *course) : Person(name, age), course(course) &#123;</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student 构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-初始化属性和函数重载"><a href="#2-3-初始化属性和函数重载" class="headerlink" title="2.3 初始化属性和函数重载"></a>2.3 初始化属性和函数重载</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">//变量修饰符</span></span><br><span class="line"><span class="keyword">private</span>:<span class="comment">// 本类中使用</span></span><br><span class="line">    <span class="comment">// protected: 子类中能使用（默认）</span></span><br><span class="line">    <span class="comment">// public：公开，任何地方都可以</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">char</span> *name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Person 构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>-&gt;name &lt;&lt; <span class="string">" , "</span> &lt;&lt; <span class="keyword">this</span>-&gt;age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *course;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// :Person(name,age) 调用构造函数初始化父类的属性</span></span><br><span class="line">    <span class="comment">// 不光可以给父类初始化属性，还可以给本类的属性进行初始化，用 , 隔开即可</span></span><br><span class="line">    Student(<span class="keyword">char</span> *name, <span class="keyword">int</span> age, <span class="keyword">char</span> *course) : Person(name, age), course(course) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Student 构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"course： "</span> &lt;&lt; course &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Student <span class="title">stu</span><span class="params">(<span class="string">"eastrise"</span>,<span class="number">25</span>,<span class="string">"数学"</span>)</span></span>;</span><br><span class="line">    stu.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person 构造函数</span><br><span class="line">Student 构造函数</span><br><span class="line">course： 数学</span><br></pre></td></tr></table></figure>

<h2 id="2-4-多继承"><a href="#2-4-多继承" class="headerlink" title="2.4 多继承"></a>2.4 多继承</h2><p>用 <code>,</code> 号 隔开</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person , <span class="keyword">public</span> Vector&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++学习</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化：2.UI绘制优化</title>
    <url>/2.UI%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-CPU与GPU工作流程"><a href="#1-CPU与GPU工作流程" class="headerlink" title="1.CPU与GPU工作流程"></a>1.CPU与GPU工作流程</h1><p>CPU 的任务繁多，做逻辑计算外，还要做内存管理、显示操作，因此在实际运算的时候性能会大打折扣，在没有 GPU 的时代，不能显示复<br>杂的图形，其运算速度远跟不上今天复杂三维游戏的要求。即使 CPU的工作频率超过 2GHz 或更高，对它绘制图形提高也不大。这时 GPU<br>的设计就出来了。</p>
<p><img src="/images/CPU%E3%80%81GPU%E4%BC%A0%E9%80%92%E5%B7%A5%E4%BD%9C.png" alt></p>
<p><img src="/images/CPU%E3%80%81GPU%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt></p>
<ul>
<li>黄色的 Control 为控制器，用于协调控制整个 CPU 的运行，包括取出指令、控制其他模块的运行等；</li>
<li>绿色的 ALU （ Arithmetic Logic Unit ）是算术逻辑单元，用于进行数学、逻辑运算；</li>
<li>橙色的 Cache 和 DRAM 分别为缓存和 RAM ，用于存储信息。</li>
</ul>
<p>从结构图可以看出， CPU 的控制器较为复杂，而 ALU 数量较少。因此 CPU 擅长各种复杂的逻辑运算，但不擅长数学尤其是浮点运算。</p>
<p><img src="/images/CPU%E3%80%81GPU%E7%BB%98%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt></p>
<p><img src="/images/CPU%E3%80%81GPU%E7%BB%98%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B2.png" alt></p>
<h1 id="2-60Hz-刷新频率由来"><a href="#2-60Hz-刷新频率由来" class="headerlink" title="2.60Hz 刷新频率由来"></a>2.60Hz 刷新频率由来</h1><ul>
<li>12 fps ：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约 10-12 帧的时候，就会认为是连贯的</li>
<li>24 fps ：有声电影的拍摄及播放帧率均为每秒 24 帧，对一般人而言已算可接受</li>
<li>30 fps ：早期的高动态电子游戏，帧率少于每秒 30 帧的话就会显得不连贯，这是因为没有动态模糊使流畅度降低</li>
<li><code>60 fps</code> <code>在与手机交互过程中</code>，如触摸和反馈 60 帧以下人是能感觉出来的。 60 帧以上不能察觉变化当帧率<br>低于 60 fps 时感觉的画面的卡顿和迟滞现象</li>
</ul>
<p>Android 系统每隔 <code>16ms</code> 发出 <code>VSYNC(垂直同步信号)</code> 信号 (1000ms/60=16.66ms) ，触发对 UI 进行渲染， 如果每次渲染都成<br>功这样就能够达到流畅的画面所需要的 60fps ，为了能够实现 60fps ，这意味着计算渲染的大多数操作都必须在 16ms 内完成。</p>
<h1 id="3-卡顿原理分析和解决方案"><a href="#3-卡顿原理分析和解决方案" class="headerlink" title="3.卡顿原理分析和解决方案"></a>3.卡顿原理分析和解决方案</h1><p>当这一帧画面渲染时间超过16ms的时候,垂直同步机制会让显示器硬件 等待GPU完成栅格化渲染操作<br>这样会让湿一帧画面，多停留了 16ms,甚至更多.这样就这造成了用户看起来画面停顿.</p>
<p><code>16 毫秒的时间主要被两件事情所占用</code></p>
<ul>
<li>第一件：将 UI 对象转换为一系列多边形和纹理</li>
<li>第二件： CPU 传递处理数据到 GPU 。</li>
</ul>
<p>所以很明显，我们要缩短这两部分的时间，也就是说需要尽量减少对象转换的次数，以及Cpu传递到GPU数据的次数。</p>
<p><code>如何减少这两部分的时间以至于在16ms完成呢</code></p>
<ul>
<li>CPU减少xml转换成对象的时间(<code>布局优化</code>)</li>
<li>GPU减少重复绘制的时间（<code>减少过度绘制</code>）</li>
</ul>
<h1 id="4-减少过度绘制-减少GPU工作量"><a href="#4-减少过度绘制-减少GPU工作量" class="headerlink" title="4.减少过度绘制(减少GPU工作量)"></a><code>4.减少过度绘制(减少GPU工作量)</code></h1><h2 id="4-1-过度绘制定义"><a href="#4-1-过度绘制定义" class="headerlink" title="4.1.过度绘制定义"></a>4.1.过度绘制定义</h2><p>GPU的绘制过程，就跟刷墙一样,一层层的进行,16ms刷一次.这样就会造成图层覆盖的现象，即无用的图层还被绘制在底层,造成不必要的浪费.</p>
<h2 id="4-2-GPU过度绘制几种情况"><a href="#4-2-GPU过度绘制几种情况" class="headerlink" title="4.2.GPU过度绘制几种情况"></a>4.2.GPU过度绘制几种情况</h2><ol>
<li>自定义控件中onDraw方法做了过多重复绘制(可以使用裁剪，只绘制用户看的到的地方)</li>
<li>布局层次太深，重叠性太强。用户看不到的区域GPU也会渲染，导致耗时增加.</li>
</ol>
<h2 id="4-3-过度绘制査看工具"><a href="#4-3-过度绘制査看工具" class="headerlink" title="4.3.过度绘制査看工具"></a>4.3.过度绘制査看工具</h2><p>手机端的开发者选项—&gt;<code>调试GPU过度绘制</code>—-&gt;显示过度绘制区域</p>
<p><img src="/images/%E6%9F%A5%E7%9C%8B%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6%E5%8C%BA%E5%9F%9F.png" alt></p>
<p><img src="/images/%E6%9F%A5%E7%9C%8B%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6%E5%8C%BA%E5%9F%9F2.png" alt></p>
<ul>
<li>蓝色过度绘制一次无过度绘制</li>
<li>淡绿过度绘制两次</li>
<li>淡红过度绘制三次</li>
<li>深红过度绘制四次</li>
</ul>
<p>代表了4种不同程度Overdraw情况 我们的目标就是尽量减少红色Overdraw ,看到更多的蓝色区域。</p>
<h2 id="4-4-优化方案"><a href="#4-4-优化方案" class="headerlink" title="4.4.优化方案"></a><code>4.4.优化方案</code></h2><h3 id="4-4-1-减少背景重复"><a href="#4-4-1-减少背景重复" class="headerlink" title="4.4.1. 减少背景重复"></a>4.4.1. 减少背景重复</h3><p>去掉默认背景<br><img src="/images/%E5%8E%BB%E6%8E%89%E9%BB%98%E8%AE%A4%E8%83%8C%E6%99%AF.png" alt></p>
<p>去掉二层容器背景<br><img src="/images/%E5%8E%BB%E6%8E%89%E5%AE%B9%E5%99%A8%E8%83%8C%E6%99%AF.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.去掉所有activity主题设置中的属性</span><br><span class="line">直接在styles.xml中设置&lt;item name&#x3D;&quot;android:windowBackground&quot;&gt;@null&lt;&#x2F;item&gt;</span><br><span class="line"></span><br><span class="line">2.去掉单个activity的主题设置的属性</span><br><span class="line">可以在setContentView之前getWindow().setBackgroundDrawable(null); </span><br><span class="line"></span><br><span class="line">3.非业务需要，不要去设置背景</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2-使用裁减减少控件之间的重合部分"><a href="#4-4-2-使用裁减减少控件之间的重合部分" class="headerlink" title="4.4.2. 使用裁减减少控件之间的重合部分"></a>4.4.2. 使用裁减减少控件之间的重合部分</h3><p>Android7.0之后系统做出的优化,<code>invalidate()</code>不再执行测量和布局动作</p>
<p><img src="/images/%E9%87%8D%E5%90%88%E5%8C%BA%E5%9F%9F%E8%BF%87%E5%BA%A6%E7%BB%98%E5%88%B6%E6%83%85%E5%86%B5.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void drawDroidCard(Canvas canvas,List&lt;DroidCard&gt; mDroidCards,int i) &#123;</span><br><span class="line">    DroidCard c &#x3D; mDroidCards.get(i);</span><br><span class="line">    canvas.save();</span><br><span class="line">    canvas.clipRect((float)c.x,0f,(float)(mDroidCards.get(i+1).x),(float)c.height);</span><br><span class="line">    canvas.drawBitmap(c.bitmap,c.x,0f,paint);</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-布局优化-减少CPU工作量"><a href="#5-布局优化-减少CPU工作量" class="headerlink" title="5.布局优化(减少CPU工作量)"></a><code>5.布局优化(减少CPU工作量)</code></h1><h2 id="5-1-布局查看常用工具"><a href="#5-1-布局查看常用工具" class="headerlink" title="5.1.布局查看常用工具"></a>5.1.布局查看常用工具</h2><ol>
<li>Tool—&gt;<code>Layout Inspector</code>,<code>AndroidStudio自带</code></li>
<li>sdk目录/tools/bin/uiautomatorviewer.bat</li>
<li>sdk目录tools\monitor.bat打开<code>Device Monitor</code>中Hierarchy view，<code>AndroidStudio3.1过后已经遗弃，但是真的好用</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">三个点也是代表着View的Measure, Layout和Draw。</span><br><span class="line">绿: 表示该View的此项性能比该View Tree中超过50%的View都要快；例如,代表Measure的是绿点,意味着这个视图的测量时间快于树中的视图对象的50%。</span><br><span class="line">黄: 表示该View的此项性能比该View Tree中超过50%的View都要慢； </span><br><span class="line">红: 表示该View的此项性能是View Tree中最慢的；。</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><img src="/images/AndroidDeviceMonitor.png" alt></p>
<h2 id="5-2-优化方案"><a href="#5-2-优化方案" class="headerlink" title="5.2.优化方案"></a><code>5.2.优化方案</code></h2><ol>
<li>能在一个平面显示的内容，尽量只用一个容器。</li>
<li>尽可能把相同的容器合并merge。</li>
<li>能复用的代码，用include处理，可以减少GPU重复工。</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构和算法：03.冒泡、选择、插入排序</title>
    <url>/28.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E3%80%81%E9%80%89%E6%8B%A9%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure28bubbleselectsort" target="_blank" rel="noopener">NDKPractice项目的datastructure</a></strong></p>
<h1 id="1-Ndk中，宏定义Log打印"><a href="#1-Ndk中，宏定义Log打印" class="headerlink" title="1. Ndk中，宏定义Log打印"></a>1. Ndk中，宏定义<code>Log</code>打印</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAG <span class="meta-string">"TAG"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__)</span></span><br><span class="line"><span class="comment">// 其他方法的定义 __android_log_print 取了一个别名（参数固定，可变）</span></span><br></pre></td></tr></table></figure>

<h1 id="2-c-中的rand-随机"><a href="#2-c-中的rand-随机" class="headerlink" title="2. c++ 中的rand() 随机"></a>2. c++ 中的rand() 随机</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  输出 0 到 49 之间的随机数</span></span><br><span class="line"> rand() % <span class="number">50</span></span><br></pre></td></tr></table></figure>

<h1 id="3-冒泡排序"><a href="#3-冒泡排序" class="headerlink" title="3. 冒泡排序"></a>3. 冒泡排序</h1><ul>
<li><code>思想</code>：相邻两个数进行比较，如果前面的比后面的大，就进行交换，否则不需要交换。<strong><code>每次循环完毕都会在末尾选出一个最大的数</code></strong>  </li>
<li><code>时间复杂度</code>：<strong>O($n^2$)</strong></li>
<li><code>空间复杂度</code>：<strong>O(1)</strong></li>
</ul>
<p>看图：<br><img src="/images/%E5%86%92%E6%B3%A1%E6%80%9D%E6%83%B3.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123; <span class="comment">// 外循环代表循环次数 n - 1 步</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; ++j) &#123; <span class="comment">// 内循环代表一次循环对比的次数 n-1,n-2,n-3,1</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">// 交换 一次交换是三次赋值</span></span><br><span class="line">                swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-选择排序"><a href="#4-选择排序" class="headerlink" title="4. 选择排序"></a>4. 选择排序</h1><ul>
<li><code>思想</code>： 遍历找出最小的位置，最后与第一个位置交换。<strong><code>每次循环完毕都会在开始位置选出一个最小的数</code></strong>  </li>
<li><code>时间复杂度</code>：<strong>O($n^2$)</strong></li>
<li><code>空间复杂度</code>：<strong>O(1)</strong></li>
</ul>
<p>耗费的时间比上边未优化的冒泡排序要少很多</p>
<p>看图：<br><img src="/images/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%80%9D%E6%83%B3.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123; <span class="comment">// 外循环代表循环次数 n - 1 步</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; ++j) &#123;  <span class="comment">// 内循环代表一次循环对比的次数</span></span><br><span class="line">            <span class="keyword">if</span>(arr[<span class="built_in">min</span>] &gt; arr[j])&#123;</span><br><span class="line">                <span class="built_in">min</span> = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[<span class="built_in">min</span>],arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-插入排序"><a href="#5-插入排序" class="headerlink" title="5. 插入排序:"></a>5. 插入排序:</h1><p><img src="/images/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt></p>
<p><strong>像打扑克牌摸排后插入一样</strong></p>
<ul>
<li><code>思想</code>： <strong><code>每次循环完毕index在(循环次数+1)前面的数都是排好序的</code></strong>  </li>
<li><code>时间复杂度</code>：最差情况：<strong>O($n^2$)</strong>，最好情况：<strong>O(n)</strong></li>
<li><code>空间复杂度</code>：<strong>O(1)</strong></li>
</ul>
<p>特点：<code>适用于数组中大部分是排好序的数组</code>,如果大部分都没排好序，那么花费的时间比原来的冒泡排序还多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;<span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j<span class="number">-1</span>] ; --j) &#123;</span><br><span class="line">            swap(arr[j],arr[j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;<span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[j<span class="number">-1</span>] )</span><br><span class="line">                swap(arr[j],arr[j<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-两个整数交换不额外开辟新内存"><a href="#6-两个整数交换不额外开辟新内存" class="headerlink" title="6.两个整数交换不额外开辟新内存"></a>6.两个整数交换不额外开辟新内存</h1><p>有以下两种方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line"></span><br><span class="line">    a = a + b;<span class="comment">// a = 300</span></span><br><span class="line">    b = a - b;<span class="comment">// b = 200</span></span><br><span class="line">    a = a - b;<span class="comment">// a = 100</span></span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"交换后ab的值分别是：%d,%d"</span>,a,b); <span class="comment">// 交换后ab的值分别是：200,100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;  <span class="comment">// 二进制 10</span></span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;  <span class="comment">// 二进制 11</span></span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line"></span><br><span class="line">    a = a ^ b; <span class="comment">// 二进制：10 ^ 11 = 01 = a = 十进制：1</span></span><br><span class="line">    b = a ^ b; <span class="comment">// 二进制：01 ^ 11 = 10 = b = 十进制：2</span></span><br><span class="line">    a = a ^ b; <span class="comment">// 二进制：01 ^ 10 = 11 = a = 十进制：3</span></span><br><span class="line"></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">"交换后ab的值分别是：%d,%d"</span>,a,b); <span class="comment">// 交换后ab的值分别是：3,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











































]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：04.冒泡优化、插入和希尔排序</title>
    <url>/29.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%86%92%E6%B3%A1%E4%BC%98%E5%8C%96%E3%80%81%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96%E5%92%8C%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="冒泡优化、插入优化和希尔排序"><a href="#冒泡优化、插入优化和希尔排序" class="headerlink" title="冒泡优化、插入优化和希尔排序"></a><center>冒泡优化、插入优化和希尔排序<center></center></center></h1><p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure28bubbleselectsort" target="_blank" rel="noopener">NDKPractice项目的datastructure</a></strong></p>
<h1 id="1-冒泡排序优化"><a href="#1-冒泡排序优化" class="headerlink" title="1. 冒泡排序优化"></a>1. 冒泡排序优化</h1><p>引用个<a href="https://blog.csdn.net/hansionz/article/details/80822494" target="_blank" rel="noopener">冒泡排序优化</a> 的链接</p>
<p>思维：<br><img src="/images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96.png" alt></p>
<p>特点：<code>适用于数组中大部分是排好序的数组</code>,如果大部分都没排好序，那么花费的时间比原来的冒泡排序还多</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序的优化（适用于数组中大部分是排好序的数组）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optimizeBubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 记录上一次最后遍历的位置</span></span><br><span class="line">    <span class="keyword">int</span> n = len;</span><br><span class="line">    <span class="keyword">int</span> lastchangeIndex = <span class="number">0</span>; <span class="comment">//  最后交换的位置，控制位置</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        lastchangeIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i<span class="number">-1</span>] &gt; arr[i])&#123; <span class="comment">// 后一个跟前一个对比</span></span><br><span class="line">                swap(arr[i<span class="number">-1</span>],arr[i]);</span><br><span class="line">                <span class="comment">// 记录交换的位置，</span></span><br><span class="line">                lastchangeIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n = lastchangeIndex; <span class="comment">// 记录最后一次交换的位置，证明了后面的不用交换，顺序是对的，可以避免下次循环的判断</span></span><br><span class="line">    &#125;<span class="keyword">while</span> (n &gt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;<span class="comment">//用来记录最后一次交换的位置</span></span><br><span class="line">	<span class="keyword">int</span> k = len - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)<span class="comment">//确定排序趟数</span></span><br><span class="line">	&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">		flag = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; k; j++)<span class="comment">//确定比较次数</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j]&gt;arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//交换</span></span><br><span class="line">				swap(arr[j],arr[j+<span class="number">1</span>]);</span><br><span class="line">				flag = <span class="number">1</span>;<span class="comment">//加入标记</span></span><br><span class="line">				pos = j;<span class="comment">//交换元素，记录最后一次交换的位置</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="comment">//如果没有交换过元素，则已经有序</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		k = pos;<span class="comment">//下一次比较到记录位置即可</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-插入排序优化"><a href="#2-插入排序优化" class="headerlink" title="2. 插入排序优化"></a>2. 插入排序优化</h1><p><img src="/images/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96.png" alt></p>
<p>特点:<code>适用于数组中大部分是排好序的数组</code>,比选择排序快很多(时间复杂度上是 O(n)级别)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,j,i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="comment">// 当前的位置</span></span><br><span class="line">        temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt;<span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt;temp ; --j) &#123;</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入合适的位置 (这个时候的j 是 -- 了的哦 注意看循环的最后一个条件)</span></span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序优化1(这样会跳出循环更快)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort1</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp,j,i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="comment">// 当前的位置</span></span><br><span class="line">        temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt;<span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j<span class="number">-1</span>] &gt;temp)</span><br><span class="line">                arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入合适的位置 (这个时候的j 是 -- 了的哦 注意看循环的最后一个条件)</span></span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-对比插入排序和选择排序"><a href="#3-对比插入排序和选择排序" class="headerlink" title="3.对比插入排序和选择排序"></a>3.对比插入排序和选择排序</h1><table>
<thead>
<tr>
<th></th>
<th>最好情况</th>
<th>最坏情况</th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>比较N*（N-1）/2次，交换0次</td>
<td>比较N<em>（N-1）/2次，交换N</em>（N-1）/2次，赋值N*（N-1）/2次</td>
</tr>
<tr>
<td>插入排序</td>
<td>比较N-1次，交换0次</td>
<td>比较N<em>（N-1）/2次，交换N</em>（N-1）/2次，赋值3<em>N</em>（N-1）/2次</td>
</tr>
<tr>
<td>改进插入排序</td>
<td>比较N-1次，交换0次</td>
<td>比较N<em>（N-1）/2次，交换N</em>（N-1）/2次，赋值N*（N-1）/2 + 2（N-1）次</td>
</tr>
</tbody></table>
<h1 id="4-希尔排序-插入排序优化的再次优化"><a href="#4-希尔排序-插入排序优化的再次优化" class="headerlink" title="4.希尔排序(插入排序优化的再次优化)"></a>4.希尔排序(插入排序优化的再次优化)</h1><p>引用个<a href="(https://www.cnblogs.com/chengxiao/p/6104371.html)">希尔排序链接</a></p>
<p>希尔排序在 <code>数据非常无序时</code>是<code>首选</code>,<code>数据很有序</code>的时候还是没有<code>改进插入排序</code> 快</p>
<p>思想: <code>分治</code><br><img src="/images/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 希尔排序思想：对插入排序分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellInsertSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">// 思考 ： 求算法的复杂度</span></span><br><span class="line">    <span class="keyword">int</span> increment = len / <span class="number">2</span>; <span class="comment">// 4组</span></span><br><span class="line">    <span class="keyword">int</span> i, j ,k;</span><br><span class="line">    <span class="keyword">while</span>(increment &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">// 希尔排序</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; increment; ++i)&#123; <span class="comment">// i = 0, increment = 2</span></span><br><span class="line">            <span class="keyword">for</span>(j = i + increment; j &lt; len; j += increment)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j]; <span class="comment">// 5</span></span><br><span class="line">                <span class="comment">// k = j = 6;</span></span><br><span class="line">                <span class="keyword">for</span>(k = j; k &gt; i  &amp;&amp; arr[k - increment] &gt; tmp; k -= increment)&#123;</span><br><span class="line">                    <span class="comment">// 往后挪动</span></span><br><span class="line">                    arr[k] = arr[k - increment];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[k] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        increment /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellInsertSort1</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123; <span class="comment">// 8</span></span><br><span class="line">    <span class="comment">// 思考 ： 求算法的复杂度</span></span><br><span class="line">    <span class="keyword">int</span> i, j ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> increment = len / <span class="number">2</span>;increment &gt;<span class="number">0</span>;increment /= <span class="number">2</span>)&#123; <span class="comment">// 4组</span></span><br><span class="line">        <span class="comment">// 希尔排序</span></span><br><span class="line">        <span class="keyword">for</span>(i = increment; i &lt; len; ++i)&#123; <span class="comment">// i = 0, increment = 2</span></span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i]; <span class="comment">// 5</span></span><br><span class="line">            <span class="keyword">for</span>(j = i ; j - increment &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; arr[j - increment]; j -= increment)&#123;</span><br><span class="line">                arr[j] = arr[j - increment];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















































]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：02.单链表与双链表</title>
    <url>/27.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E9%93%BE%E8%A1%A8(LinkedList)/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure27" target="_blank" rel="noopener">NDKPractice项目的datastructure</a></strong></p>
<h1 id="1-单链表和双链表的定义"><a href="#1-单链表和双链表的定义" class="headerlink" title="1.单链表和双链表的定义"></a>1.单链表和双链表的定义</h1><ul>
<li>单链表：<strong>只有一个指向下一结点的指针，也就是只能next</strong></li>
<li>双链表：<strong>除了有一个指向下一结点的指针外，还有一个指向前一结点的指针，可以通过prev()快速找到前一结点，顾名思义，单链表只能单向读取</strong></li>
</ul>
<h1 id="2-需要注意的地方"><a href="#2-需要注意的地方" class="headerlink" title="2.需要注意的地方:"></a>2.需要注意的地方:</h1><p><code>结构体或class 属性必须指定或者定义的时候给个默认对象这样才会有默认值,否则没有</code></p>
<h1 id="3-检测耗费的时间："><a href="#3-检测耗费的时间：" class="headerlink" title="3.检测耗费的时间："></a>3.检测耗费的时间：</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">time_t</span> start = clock();</span><br><span class="line">... <span class="comment">// 这块是需要检测耗费时间的步骤</span></span><br><span class="line"><span class="keyword">time_t</span> <span class="built_in">end</span> = clock();</span><br><span class="line">LOGE(<span class="string">"耗费时间:%d"</span>,(<span class="built_in">end</span>-start) / CLOCKS_PER_SEC);</span><br></pre></td></tr></table></figure>

<h1 id="4-单链表和双链表的关系"><a href="#4-单链表和双链表的关系" class="headerlink" title="4.单链表和双链表的关系"></a>4.单链表和双链表的关系</h1><ol>
<li>都是属于增删快的</li>
<li>双链表比单链表数据量大时查询要快一倍.(插入在链表中间时,可以根据需要从first,还是last查询,这样要快一倍)</li>
</ol>
<h1 id="5-手写c-中的LinkedList"><a href="#5-手写c-中的LinkedList" class="headerlink" title="5.手写c++中的LinkedList"></a>5.手写c++中的LinkedList</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 123 on 2020/7/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDKPRACTICE_LINKEDLIST_HPP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDKPRACTICE_LINKEDLIST_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单链表节点</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Node&lt;E&gt; *pre;</span><br><span class="line">    Node&lt;E&gt; *next;</span><br><span class="line">    E value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(E value, Node&lt;E&gt; *pre, Node&lt;E&gt; *next) : value(value), pre(pre), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// list</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkedList</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node&lt;E&gt; *first = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 集合的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 尾节点</span></span><br><span class="line">    Node&lt;E&gt; *last = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove insert</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~LinkedList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node&lt;E&gt; *<span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(Node&lt;E&gt; *pNode, E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; *pNode)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:push(E e) &#123;</span><br><span class="line">    <span class="comment">// 添加一个数据在列表的后面</span></span><br><span class="line">    linkLast(e);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是单链表的添加</span></span><br><span class="line">    <span class="comment">/*Node&lt;E&gt; *new_node = new Node&lt;E&gt;(e, NULL);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (head) &#123;// 0 -&gt; 1 -&gt; 2 -&gt; 3</span></span><br><span class="line"><span class="comment">        // ?</span></span><br><span class="line"><span class="comment">        // head-&gt;next = new_node;</span></span><br><span class="line"><span class="comment">        // 找到尾巴节点，有一个特定就是 next 节点为空</span></span><br><span class="line"><span class="comment">        */</span><span class="comment">/*Node&lt;E&gt;* h = head;</span></span><br><span class="line"><span class="comment">        while(h)&#123;</span></span><br><span class="line"><span class="comment">            if(h-&gt;next == NULL)&#123;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            h = h-&gt;next;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        h-&gt;next = new_node;*/</span><span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 每一次都需要找到最后一个节点  50000</span></span><br><span class="line"><span class="comment">        // 记录 last 节点</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        // Node&lt;E&gt; *last = node(len - 1);</span></span><br><span class="line"><span class="comment">        last-&gt;next = new_node;// O(1)</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        head = new_node;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    last = new_node;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Node</span>&lt;E&gt;* <span class="title">LinkedList</span>&lt;E&gt;:</span>:node(<span class="keyword">int</span> index) &#123; <span class="comment">// O(n)</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; (len &gt;&gt; <span class="number">1</span>))&#123; <span class="comment">// 从开头开始找要快点</span></span><br><span class="line">        Node&lt;E&gt; *x = first;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; index; i++)&#123;</span><br><span class="line">            x = x-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 从后往前遍历</span></span><br><span class="line">        Node&lt;E&gt; *x = last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len<span class="number">-1</span>; i &gt; index; i--)&#123;</span><br><span class="line">            x = x-&gt;pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:<span class="built_in">get</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    assert(index&gt;=<span class="number">0</span> &amp;&amp; index &lt; len);</span><br><span class="line">    <span class="keyword">return</span> node(index)-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:insert(<span class="keyword">int</span> index, E e) &#123; <span class="comment">// len = 4;</span></span><br><span class="line">    assert(index&gt;=<span class="number">0</span> &amp;&amp; index &lt;= len);</span><br><span class="line">    <span class="comment">// 考虑边界 0</span></span><br><span class="line">    <span class="keyword">if</span>(index == len)&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        linkBefore(node(index),e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面是单链表的插入</span></span><br><span class="line">    <span class="comment">/*Node&lt;E&gt; *new_node = new Node&lt;E&gt;(e, NULL);</span></span><br><span class="line"><span class="comment">    if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">        Node&lt;E&gt; *h = head;</span></span><br><span class="line"><span class="comment">        head = new_node;</span></span><br><span class="line"><span class="comment">        new_node-&gt;next = h;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        // 考虑最后一个位置</span></span><br><span class="line"><span class="comment">        Node&lt;E&gt; *prev = node(index - 1);</span></span><br><span class="line"><span class="comment">        Node&lt;E&gt; *next = prev-&gt;next;// NULL</span></span><br><span class="line"><span class="comment">        prev-&gt;next = new_node;</span></span><br><span class="line"><span class="comment">        new_node-&gt;next = next;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:<span class="built_in">remove</span>(<span class="keyword">int</span> index) &#123;</span><br><span class="line">    <span class="comment">// 考虑边界问题 0 , len ，mid</span></span><br><span class="line">    assert(index&gt;=<span class="number">0</span> &amp;&amp; index &lt; len);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单链表的移除</span></span><br><span class="line">    <span class="comment">/*if (index == 0) &#123;</span></span><br><span class="line"><span class="comment">    Node&lt;E&gt; *h = head;</span></span><br><span class="line"><span class="comment">    head = h-&gt;next;</span></span><br><span class="line"><span class="comment">    // 释放</span></span><br><span class="line"><span class="comment">    delete h;</span></span><br><span class="line"><span class="comment">    &#125; else &#123;</span></span><br><span class="line"><span class="comment">        Node&lt;E&gt; *prev = node(index - 1);</span></span><br><span class="line"><span class="comment">        // 删除的节点</span></span><br><span class="line"><span class="comment">        Node&lt;E&gt; *cur = prev-&gt;next;</span></span><br><span class="line"><span class="comment">        prev-&gt;next = cur-&gt;next;</span></span><br><span class="line"><span class="comment">        delete cur;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedList</span>&lt;E&gt;:</span>:~LinkedList() &#123;</span><br><span class="line">    <span class="comment">// 析构释放内存 ？</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">delete</span>(node(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头指针和尾指针置为NULL</span></span><br><span class="line">    first = <span class="literal">NULL</span>;</span><br><span class="line">    last = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:linkLast(E e) &#123;</span><br><span class="line">    Node&lt;E&gt; *l = last;</span><br><span class="line">    Node&lt;E&gt; *new_node = <span class="keyword">new</span> Node&lt;E&gt;(e,l,<span class="literal">NULL</span>);</span><br><span class="line">    last = new_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(l)&#123;</span><br><span class="line">        l-&gt;next = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        first = new_node;</span><br><span class="line">    len ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:linkBefore(Node&lt;E&gt; *pNode, E e) &#123;</span><br><span class="line">    Node&lt;E&gt; *pre = pNode-&gt;pre;<span class="comment">// NULL</span></span><br><span class="line">    Node&lt;E&gt; *new_node = <span class="keyword">new</span> Node&lt;E&gt;(e,pre,pNode);</span><br><span class="line">    <span class="comment">// 当前节点的上一个节点 = 新增的节点</span></span><br><span class="line">    pNode-&gt;pre = new_node;</span><br><span class="line">    <span class="comment">// 上一个节点的 next -&gt; 新增的节点 ， 0 特殊处理</span></span><br><span class="line">    <span class="keyword">if</span>(pre)&#123;</span><br><span class="line">        pre-&gt;next = new_node;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        first = new_node;</span><br><span class="line">    len ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">LinkedList</span>&lt;E&gt;:</span>:unlink(Node&lt;E&gt; *pNode) &#123;</span><br><span class="line">    E e = pNode-&gt;value;</span><br><span class="line">    <span class="comment">// 左右两个节点</span></span><br><span class="line">    Node&lt;E&gt; *pre = pNode-&gt;pre;</span><br><span class="line">    Node&lt;E&gt; *next = pNode-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有两个为空的情况，严谨，思维灵活</span></span><br><span class="line">    <span class="keyword">if</span>(pre)&#123;</span><br><span class="line">        pre-&gt;next = next;</span><br><span class="line">        pNode-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        first = next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(next)&#123;</span><br><span class="line">        next-&gt;pre = pre;</span><br><span class="line">        pNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        last = pre;</span><br><span class="line"></span><br><span class="line">    pNode -&gt; value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">delete</span> pNode;</span><br><span class="line">    len --;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//NDKPRACTICE_LINKEDLIST_HPP</span></span></span><br></pre></td></tr></table></figure>









































]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>LinkedList</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：01.定义</title>
    <url>/26.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<h1 id="1-数据结构算法基本概念"><a href="#1-数据结构算法基本概念" class="headerlink" title="1.数据结构算法基本概念"></a>1.数据结构算法基本概念</h1><h2 id="1-1-数据结构："><a href="#1-1-数据结构：" class="headerlink" title="1.1 数据结构："></a>1.1 数据结构：</h2><p>指相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系，简单的理解就是<code>元素之间的相互关系</code>。  </p>
<p>其中逻辑结构分为四类：  </p>
<ol>
<li>集合结构</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图形结构</li>
</ol>
<p>存储结构一般分为：  </p>
<ol>
<li>顺序存储</li>
<li>链式存储</li>
</ol>
<h2 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h2><p>指特定问题求解步骤的描述。算法的特性有：<code>输入，输出，有穷性，确定性和可行性</code>。</p>
<p>算法的优劣主要从算法的<code>执行时间</code>和所需要<code>占用的存储空间</code>两个方面衡量，也称之为<code>时间复杂度</code>和<code>空间复杂度</code>。</p>
<h1 id="2-算法的时间复杂度和空间复杂度"><a href="#2-算法的时间复杂度和空间复杂度" class="headerlink" title="2. 算法的时间复杂度和空间复杂度"></a>2. 算法的时间复杂度和空间复杂度</h1><p><code>时间复杂度</code>是一个函数，它定性描述了该算法的运行时间，时间复杂度常用大<code>O</code>符号表述，不包括这个函数的低阶项和首项系数。<br><code>空间复杂度(Space Complexity)</code>是对一个算法在运行过程中<code>临时占用存储空间大小</code>的量度。</p>
<p>常见的时间复杂度：</p>
<ul>
<li>常数阶O(1)，</li>
<li>对数阶O($\log_2 n$)，</li>
<li>线性阶O(n)，</li>
<li>线性对数阶O(n* $\log_2 n$)，</li>
<li>平方阶O($n^2$)，</li>
<li>立方阶O($n^3$)，</li>
<li>k次方阶O($n^K$)，</li>
<li>指数阶O ($2^n$)。</li>
</ul>
<p>举几个列：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如我们现在 求 1+2+3+4+***+n</span></span><br><span class="line"><span class="comment">// 任何算法在特定执行的 n 步骤下，我们都可以推演出算法的复杂度（时间，空间）</span></span><br><span class="line"><span class="comment">// 简单的理解为执行的步骤</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">// n + 2 步 O(n)</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 1步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n ; ++i) &#123; <span class="comment">// n 步</span></span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;<span class="comment">// 1步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum2</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span>+n)*n / <span class="number">2</span>; <span class="comment">// 1步</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空间复杂度 反转一个字符串 aaa222bbb -&gt; bbb222aaa</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">reverse1</span><span class="params">(<span class="keyword">char</span> str1[],<span class="keyword">int</span> n)</span></span>&#123; <span class="comment">// O(n)</span></span><br><span class="line">    <span class="comment">// 第一种写法</span></span><br><span class="line">    <span class="comment">// 创建一个新的数组</span></span><br><span class="line">    <span class="keyword">char</span>* res = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>)*n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        res[n - <span class="number">1</span> - i] = str1[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res; <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">char</span> str[],<span class="keyword">int</span> n)</span></span>&#123;<span class="comment">// 空间复杂度是 O(1) 时间复杂度是 O(n)</span></span><br><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++)&#123;</span><br><span class="line">        <span class="comment">// i 的位置和 i+mid 的位置进行交换</span></span><br><span class="line">        <span class="comment">// 交换 1 次交换是两次赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作业：读一篇英文文档统计字符出现的个数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//统计各字符的出现频bai率，只统du计ASC[0，127]的字符，中文字符不参加统计 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tongji</span><span class="params">(<span class="keyword">int</span> *c,FILE *fp)</span></span>&#123;</span><br><span class="line"> zhiintd;</span><br><span class="line">  <span class="keyword">while</span>((d=fgetc(fp))!=EOF)&#123;</span><br><span class="line">    <span class="keyword">if</span> (d&gt;=<span class="number">0</span> &amp;&amp; d&lt;<span class="number">128</span>) c[d]++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">128</span>],i;</span><br><span class="line">    <span class="keyword">if</span> ((fp=fopen(<span class="string">"d:\\temp.txt"</span>,<span class="string">"r"</span>))==<span class="literal">NULL</span>)&#123; <span class="comment">//自行dao指定打开的文件 </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"打开文件失败\n"</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">128</span>;i++)&#123;</span><br><span class="line">        c[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tongji(c,fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"字符\tASC码\t频率\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">32</span>;i&lt;<span class="number">128</span>;i++)&#123; <span class="comment">//显示ASC字符是32以上的统计结果 </span></span><br><span class="line">    <span class="keyword">if</span>(c[i]!=<span class="number">0</span>)</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%c\t%d\t%d\n"</span>,i,i,c[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：05.稳定和不稳定排序、归并排序和快速排序、三路快排</title>
    <url>/30.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E7%A8%B3%E5%AE%9A%E5%92%8C%E4%B8%8D%E7%A8%B3%E5%AE%9A%E6%8E%92%E5%BA%8F%E3%80%81%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E3%80%81%E4%B8%89%E8%B7%AF%E5%BF%AB%E6%8E%92/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure28bubbleselectsort" target="_blank" rel="noopener">NDKPractice项目的datastructure</a></strong></p>
<h1 id="1-稳定排序和不稳定排序："><a href="#1-稳定排序和不稳定排序：" class="headerlink" title="1. 稳定排序和不稳定排序："></a>1. 稳定排序和不稳定排序：</h1><p>稳定排序概念：<code>通俗地讲就是能保证排序前两个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</code></p>
<p>代表：</p>
<ul>
<li>稳定排序：<code>冒泡</code>、<code>插入</code>、<code>归并</code> </li>
<li>不稳定排序：<code>选择</code>、<code>希尔</code>、<code>快速排序(可以做到稳定但是比较难)</code>、<code>堆排序</code></li>
</ul>
<h1 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. <a href="https://www.cnblogs.com/chengxiao/p/6194356.html" target="_blank" rel="noopener">归并排序</a></h1><p>步骤：</p>
<ol>
<li>递归，分治的算法，每次都从中间分隔，然后排序。</li>
<li>最后把分别排好序的两个子数组合并，利用一个临时数据作为中转。</li>
</ol>
<ul>
<li><code>思想</code>： <strong><code>每次循环完毕index在(循环次数+1)前面的数都是排好序的</code></strong>  </li>
<li><code>时间复杂度</code>：<strong>O(N&#42;$\log_2 N$)</strong></li>
<li><code>空间复杂度</code>：<strong>O(N)</strong></li>
</ul>
<p>每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p>
<p>思想：<br><img src="/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F1.png" alt><br><img src="/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F2.png" alt><br><img src="/images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F3.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对数组区间 [l,mid] 和 [mid+1,r] 进行归并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> l,<span class="keyword">int</span> mid,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 对数组进行一次拷贝</span></span><br><span class="line">    <span class="keyword">int</span> temp[r - l + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l ;i &lt;= r; ++i)&#123;</span><br><span class="line">        temp[i -l] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 确定好分析之后的变量</span></span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = l;</span><br><span class="line">    <span class="keyword">for</span> (; k &lt;= r; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid)&#123;   <span class="comment">// 左边的数组已经全部填充好了，那么剩下的应该填充右边的数组了</span></span><br><span class="line">            arr[k] = temp[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( j &gt; r)&#123; <span class="comment">// 右边的数组已经全部填充好了，那么剩下的应该填充左边的数组了</span></span><br><span class="line">            arr[k] = temp[i -l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(temp[i - l] &lt; temp[j - l])&#123; <span class="comment">// 临时数据里面的 i 位置和 j 位置去比较</span></span><br><span class="line">            arr[k] = temp[i - l];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            arr[k] = temp[j - l];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组的 [l,r] 区间进行归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort_</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 递归到底的情况</span></span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = ( l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort_(arr,l,mid);<span class="comment">//左边归并排序，使得左子序列有序</span></span><br><span class="line">    mergeSort_(arr,mid + <span class="number">1</span>,r);<span class="comment">//右边归并排序，使得右子序列有序</span></span><br><span class="line">    <span class="comment">// 优化要根据具体的场景去做（因为mid前面和后面都是排好序的！！）</span></span><br><span class="line">    <span class="keyword">if</span>(arr[mid] &gt; arr[mid + <span class="number">1</span>])&#123;</span><br><span class="line">        merge_(arr, l, mid, r);<span class="comment">//将两个有序子数组合并操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    mergeSort_(arr,<span class="number">0</span>,len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2. 快速排序"></a>2. <a href="https://www.cnblogs.com/MOBIN/p/4681369.html" target="_blank" rel="noopener">快速排序</a></h1><p>以数组的第一个元素为基准元素(v)进行排序，<code>大于等于v的排在数组右边，小于v的排在数组左边</code>。最后返回v的下标，再次分为两个数组进行递归操作。</p>
<p><strong>如果&gt;v，和&lt;v 的左右规模接近，那么这个排序就类似归并排序，时间复杂度最优</strong></p>
<ul>
<li><code>思想</code>： <strong><code>每次返回排序后基准元素在数组的下标，也就是说每次只排好了一个数。</code></strong>  </li>
<li><code>时间复杂度</code>：最差情况：<strong>O($n^2$)</strong>，最好情况（随机快排）：<strong>O(N&#42;$\log_2 N$)</strong></li>
<li><code>空间复杂度</code>：最差情况：<strong>O(n)</strong>，最好情况（随机快排）：<strong>O($\log_2 N$)</strong></li>
</ul>
<p><img src="/images/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对数组 arr 区间[l,r] 进行分割操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition_</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;<span class="comment">// 10 , 20</span></span><br><span class="line">    <span class="comment">// 优化，跟区间[l,r]随机位置进行比较。(如果数组本身就是有序的，那么每次都拿第一个数作为基准元素，算出来的p就是在头尾位置，小于区域和等于区域就不是接近等规模的，这样还要递归N次，复杂度就是O(n2))</span></span><br><span class="line">    swap(arr[l], arr[rand() % (r - l + <span class="number">1</span>) + l]);</span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line">    <span class="comment">// 以 p 为分割，[l+1,p]&lt;v 和  [p+1,r] &gt; v</span></span><br><span class="line">    <span class="keyword">int</span> p = l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v) &#123;</span><br><span class="line">            <span class="comment">// 只需要处理小于的情况</span></span><br><span class="line">            swap(arr[p + <span class="number">1</span>], arr[i]);</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[l], arr[p]);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组 arr 区间[l,r] 进行快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort_</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归到底的情况</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = partition_(arr, l, r);</span><br><span class="line">    quickSort_(arr, l, p - <span class="number">1</span>); <span class="comment">// 对基准元素左边的元素进行递归排序（如果，左边规模没有，那么这个递归就无效）</span></span><br><span class="line">    quickSort_(arr, p + <span class="number">1</span>, r); <span class="comment">// 对基准元素右边的进行递归排序（如果，右边规模没有，那么这个递归就无效）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)); <span class="comment">// 初始化随机数发生器</span></span><br><span class="line">    quickSort_(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-三路快排"><a href="#3-三路快排" class="headerlink" title="3. 三路快排"></a>3. 三路快排</h1><p>以数组的第一个元素为基准元素(v)进行排序，<code>大于v的排在数组右边，小于v的排在数组左边，剩下的=v在中间</code>。最后返回<code>=v的数组头尾下标</code>，再次分为两个数组进行递归操作。</p>
<ul>
<li><code>思想</code>： <strong><code>每次返回排序后，=基准元素v在数组的头尾下标，也就是说每次只排好了所有=v的数</code></strong>  </li>
<li><code>时间复杂度</code>：最差情况：<strong>O($n^2$)</strong>，最好情况（随机快排）：<strong>O(N&#42;$\log_2 N$)</strong></li>
<li><code>空间复杂度</code>：最差情况：<strong>O(n)</strong>，最好情况（随机快排）：<strong>O($\log_2 N$)</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code_04_QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">			swap(arr, l + (<span class="keyword">int</span>) (Math.random() * (r - l + <span class="number">1</span>)), r);</span><br><span class="line">			<span class="keyword">int</span>[] p = partition(arr, l, r);</span><br><span class="line">			quickSort(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">			quickSort(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以最后一个元素为基准元素。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] partition(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r) &#123;</span><br><span class="line">		<span class="keyword">int</span> less = l - <span class="number">1</span>; </span><br><span class="line">		<span class="keyword">int</span> more = r;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; more) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[l] &lt; arr[r]) &#123;</span><br><span class="line">				swap(arr, ++less, l++);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[l] &gt; arr[r]) &#123;</span><br><span class="line">				swap(arr, --more, l);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				l++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		swap(arr, more, r);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; less + <span class="number">1</span>, more &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3ways_</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归到底的情况</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义变量</span></span><br><span class="line">    swap(arr[l], arr[rand() % (r - l + <span class="number">1</span>) + l]);</span><br><span class="line">    <span class="keyword">int</span> v = arr[l];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lt = l;<span class="comment">// 左边指针 lt [l+1, lt] &lt; v  </span></span><br><span class="line">    <span class="keyword">int</span> gt = r + <span class="number">1</span>;<span class="comment">// 右边指针 gt [gt,r] &gt;v</span></span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>;<span class="comment">// 循环开始位置 [lt + 1,i) = v</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (gt &gt; i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; v) &#123;</span><br><span class="line">            swap(arr[i], arr[gt - <span class="number">1</span>]);</span><br><span class="line">            gt--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &lt; v) &#123;</span><br><span class="line">            swap(arr[i], arr[lt + <span class="number">1</span>]); <span class="comment">// i左边的一定是小于或等于v的  </span></span><br><span class="line">            i++;</span><br><span class="line">            lt++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(arr[l], arr[lt]); <span class="comment">// 交换完毕后 [l,lt-1] &lt; v,[gt,r] &gt; v</span></span><br><span class="line">    quickSort3ways_(arr, l, lt - <span class="number">1</span>);</span><br><span class="line">    quickSort3ways_(arr, gt, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort3ways</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>)); <span class="comment">// 初始化随机数发生器</span></span><br><span class="line">    quickSort3ways_(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：08.HashMap 源码分析和手写</title>
    <url>/33.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-HashMap%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%92%8C%E6%89%8B%E5%86%99/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/JavaJNITest/tree/master/src/com/east/datastructure33hashmap" target="_blank" rel="noopener">JavaJniTest项目的datastructure33hashmap</a></strong></p>
<p>常见面试题：</p>
<ul>
<li>equals 和 == 的区别，hashCode 与它们之间的联系？</li>
<li>HashMap 的长度为什么是 2 的幂次？</li>
<li>五个线程同时往 HashMap 中 put 数据会发生什么？</li>
<li>ConcurrentHashMap 是怎么保证线程安全的？</li>
<li>HashMap在jdk1.8之后为何引入了红黑树</li>
</ul>
<h1 id="1-HashMap默认的一些参数："><a href="#1-HashMap默认的一些参数：" class="headerlink" title="1. HashMap默认的一些参数："></a>1. HashMap默认的一些参数：</h1><ul>
<li>HashMap <code>数组长度默认大小：16</code>、<code>默认阈值：12</code>、<code>加载因子：0.75f</code>，扩容为当前数组长度大小的<code>一倍</code></li>
<li>vector ：没指定大小的情况下，初始大小为 <code>10</code>,扩容为当前大小的<code>一倍</code></li>
<li>ArrayList ： 没指定大小的情况下，初始大小为 <code>10</code>,扩容为当前大小的<code>二分之一</code></li>
</ul>
<p>为什么加载因子是 <code>0.75</code></p>
<ul>
<li><p>加载因子越大，填满的元素越多，空间利用率越高，但发生冲突的机会变大了；</p>
</li>
<li><p>加载因子越小，填满的元素越少，冲突发生的机会减小，但空间浪费了更多了，而且还会提高扩容rehash操作的次数。</p>
</li>
</ul>
<h1 id="2-和-equals"><a href="#2-和-equals" class="headerlink" title="2. == 和 equals"></a>2. == 和 equals</h1><p>== 判断的是地址 </p>
<p>equals 也是判断两个对象相等，但是更多的是判断内容相等，多用于集合判断</p>
<h1 id="3-hashCode："><a href="#3-hashCode：" class="headerlink" title="3. hashCode："></a>3. hashCode：</h1><p><code>如果你复写了 equals 一般要复写 hashCode</code>,一般集合中都是通过<code>hashcode</code>去减少时间复杂度,获取的时候也会判断<code>hashcode是否相等</code></p>
<p><code>hashcode = 地址值 &gt;&gt; 16</code></p>
<p>总结:    </p>
<ol>
<li>hash 值相等两个对象不一定相等</li>
<li>两个对象不相等 hash 值有可能相等</li>
<li>hash 值不相等的两个对象，这两个对象肯定不相等</li>
</ol>
<h1 id="4-HashMap-的长度为什么是-2-的幂次？"><a href="#4-HashMap-的长度为什么是-2-的幂次？" class="headerlink" title="4. HashMap 的长度为什么是 2 的幂次？"></a>4. HashMap 的长度为什么是 2 的幂次？</h1><p>为了能让HashMap存取高效，尽量减少碰撞，也就是要尽量把数据分配均匀，Hash值的范围是-2147483648到2147483647，前后加起来有40亿的映射空间。</p>
<p>这个散列值是不能直接拿来用的。用之前需要<code>先对数组长度取模运算</code>，得到的才是在数组中存储的位置。</p>
<p>总结：<code>hash%length=hash&amp;(length-1)，但前提是length是2的n次方，并且采用&amp;运算比%运算效率高，且为了减少碰撞，分配均匀，所以长度才会是 2的幂次。</code></p>
<p>举例：<br>    例如长度为9时候，3&amp;(9-1)=0  2&amp;(9-1)=0 ，都在0上，碰撞了；<br>    例如长度为8时候，3&amp;(8-1)=3  2&amp;(8-1)=2 ，不同位置上，不碰撞；  </p>
<h1 id="5-手写HashMap时关键代码分析："><a href="#5-手写HashMap时关键代码分析：" class="headerlink" title="5. 手写HashMap时关键代码分析："></a>5. 手写HashMap时关键代码分析：</h1><pre><code class="java"><span class="comment">/**</span>
<span class="comment"> *  手写 HashMap 一些关键性的代码</span>
<span class="comment"> */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>{

    <span class="class"><span class="keyword">class</span> <span class="title">MapEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>{
        K key;
        V value;
        MapEntry&lt;K,V&gt; next;
        <span class="keyword">int</span> hash; <span class="comment">// Key 的 hash 值</span>

        <span class="function"><span class="keyword">public</span> <span class="title">MapEntry</span><span class="params">(<span class="keyword">int</span> hash,K key, V value,MapEntry&lt;K, V&gt; next)</span> </span>{
            <span class="keyword">this</span>.hash = hash;
            <span class="keyword">this</span>.key = key;
            <span class="keyword">this</span>.value = value;
            <span class="keyword">this</span>.next = next;
        }
    }

    <span class="comment">/**</span>
<span class="comment">     *  散列 table （桶）</span>
<span class="comment">     */</span>
    <span class="keyword">transient</span> MapEntry[] table;

    <span class="comment">/**</span>
<span class="comment">     *  总共多少的键值对</span>
<span class="comment">     */</span>
    <span class="keyword">int</span> size;


    <span class="comment">/**</span>
<span class="comment">     *  初始大小为 16</span>
<span class="comment">     */</span>
    <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY =  <span class="number">1</span> &lt;&lt; <span class="number">4</span>;

    <span class="comment">/**</span>
<span class="comment">     *  扩容阈值（满足这个条件时扩容）</span>
<span class="comment">     */</span>
    <span class="keyword">int</span> threshold;

    <span class="comment">/**</span>
<span class="comment">     *  扩容因子，如何扩容</span>
<span class="comment">     */</span>
    <span class="keyword">final</span> <span class="keyword">float</span> loadFactory = <span class="number">0.75f</span>;

    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key,V value)</span></span>{
        <span class="keyword">if</span>(table == <span class="keyword">null</span>){
            table = <span class="keyword">new</span> MapEntry[DEFAULT_INITIAL_CAPACITY];
            threshold = (<span class="keyword">int</span>) (DEFAULT_INITIAL_CAPACITY * loadFactory);
        }

        <span class="comment">// 是不是空</span>
        <span class="keyword">if</span>(key == <span class="keyword">null</span>){
            <span class="comment">// 自行看 hashMap 的源码</span>
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }

        <span class="comment">// 1. 找到 table 的位置</span>
        <span class="keyword">int</span> hash = hash(key);
        <span class="keyword">int</span> index = getIndex(hash,table.length);

        <span class="comment">// 2. 判断有没有存在该key</span>
        <span class="keyword">for</span> (MapEntry&lt;K,V&gt; e = table[index]; e!=<span class="keyword">null</span>; e = e.next){
            K k;
            <span class="keyword">if</span>(e.hash == hash &amp;&amp; ((k = e.key) == key || (key!=<span class="keyword">null</span> &amp;&amp; key.equals(k)))){
                V oldValue = e.value;
                e.value = value;
                <span class="keyword">return</span> oldValue;
            }
        }
        <span class="comment">// 3. 添加一个新的 MapEntry</span>
        addEntry(hash,key,value,index);
        <span class="keyword">return</span> <span class="keyword">null</span>;

    }

    <span class="comment">/**</span>
<span class="comment">     * 添加一个新的 Entry</span>
<span class="comment">     * <span class="doctag">@param</span> hash</span>
<span class="comment">     * <span class="doctag">@param</span> key</span>
<span class="comment">     * <span class="doctag">@param</span> value</span>
<span class="comment">     * <span class="doctag">@param</span> index</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>{
        <span class="comment">// hash_shift 16 value() &gt;&gt; 16</span>
        <span class="comment">// 判断要不要扩容 jni 源码记住 mask_bits(value() &gt;&gt; hash_shift,hash_mask)</span>
        <span class="comment">// 1. hash 值相等两个对象不一定相等，（两个对象不相等，hash值可能相等）</span>
        <span class="comment">// 2. hash 值不相等的两个对象肯定不相等</span>
        <span class="keyword">if</span>(size &gt;= threshold &amp;&amp; table[index] != <span class="keyword">null</span>){
            resize(table.length &lt;&lt; <span class="number">1</span>);
            <span class="comment">// 重新计算 index</span>
            index = getIndex(hash,table.length);
        }
        <span class="comment">// 添加</span>
        createEntry(hash,key,value,index);

        size++;
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>{
        MapEntry&lt;K,V&gt;[] newTable = <span class="keyword">new</span> MapEntry[newCapacity];
        <span class="comment">// 直接把之前的数组搬过来，不行！！ 扩容之后 Index 会变 复杂度 O(n)</span>
        transform(newTable);
        table = newTable;
        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactory);
    }

    <span class="comment">/**</span>
<span class="comment">     * 重新计算 挪动，散列</span>
<span class="comment">     * <span class="doctag">@param</span> newTable</span>
<span class="comment">     */</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">transform</span><span class="params">(MapEntry&lt;K, V&gt;[] newTable)</span> </span>{
        <span class="keyword">int</span> newCapacity = newTable.length;

        <span class="keyword">for</span> (MapEntry&lt;K, V&gt; entry : table) {
            <span class="keyword">while</span> (entry!=<span class="keyword">null</span>){
                <span class="comment">// 从原来的数组中获取数据 Entry , 保证新的数组能链上</span>
                MapEntry&lt;K,V&gt; next = entry.next;

                <span class="comment">// 重新计算 index</span>
                <span class="keyword">int</span> index = getIndex(entry.hash,newCapacity);
                <span class="comment">// 保证新的数组能链上</span>
                entry.next = newTable[index];
                newTable[index] = entry;

                entry = next;
            }
        }
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>{
        MapEntry&lt;K,V&gt; newEntry = <span class="keyword">new</span> MapEntry&lt;&gt;(hash,key,value,table[index]);
        table[index] = newEntry;
    }


    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span></span>{
        <span class="keyword">int</span> h;
        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h=key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span> hash,<span class="keyword">int</span> length)</span></span>{
        <span class="keyword">return</span> hash &amp; length -<span class="number">1</span>; <span class="comment">// - 运算符比 &amp; 优先级高</span>
    }

    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span></span>{
        <span class="keyword">if</span>(key == <span class="keyword">null</span>){
            <span class="keyword">return</span> <span class="keyword">null</span>;
        }

        MapEntry&lt;K,V&gt; entry = getEntry(key);
        <span class="keyword">return</span> entry == <span class="keyword">null</span> ? <span class="keyword">null</span> : entry.value;
    }

    <span class="function"><span class="keyword">private</span> MapEntry&lt;K, V&gt; <span class="title">getEntry</span><span class="params">(K key)</span> </span>{
        <span class="comment">// 1. 找到 table 的位置</span>
        <span class="keyword">int</span> hash = hash(key);
        <span class="keyword">int</span> index = getIndex(hash, table.length);

        <span class="comment">// 2. 判断有没有存在该 key</span>
        <span class="keyword">for</span>(MapEntry&lt;K,V&gt; e = table[index]; e!=<span class="keyword">null</span>; e = e.next){
            K k;
            <span class="keyword">if</span>(hash == e.hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))){
                <span class="keyword">return</span> e;
            }
        }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>{
        <span class="keyword">return</span> size;
    }

}</code></pre>
]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据结构和算法学习</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：07.汉诺塔、数组实现队列和双向队列</title>
    <url>/32.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E6%B1%89%E8%AF%BA%E5%A1%94%E3%80%81%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E5%92%8C%E5%8F%8C%E5%90%91%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure32queue" target="_blank" rel="noopener">NDKPractice项目的datastructure32queue</a></strong></p>
<h1 id="1-汉诺塔："><a href="#1-汉诺塔：" class="headerlink" title="1. 汉诺塔："></a>1. 汉诺塔：</h1><p>如下图所示，从左到右有A、B、C三根柱子，其中A柱子上面有从小叠到大的n个圆盘，现要求将A柱子上的圆盘移到C柱子上去，<br>期间只有一个原则：一次只能移到一个盘子且大盘子不能在小盘子上面，求移动的步骤和移动的次数</p>
<p><img src="/images/32.%E6%B1%89%E8%AF%BA%E5%A1%94.jpg" alt></p>
<p>步骤：</p>
<ol>
<li>n-1个盘子借助 C 从 A 挪动到 B 上面</li>
<li>直接把 n 盘子从 A 挪动到 C</li>
<li>n-1 个盘子借助A 从 B 挪动到 C</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hannuota</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> start,<span class="keyword">char</span> help,<span class="keyword">char</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"把第 %d 个盘子从 %c 挪动到 %c"</span>,n,start,<span class="built_in">end</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 又是 n-1 汉诺塔</span></span><br><span class="line">        hannuota(n<span class="number">-1</span>,start,<span class="built_in">end</span>,help);</span><br><span class="line">        LOGE(<span class="string">"把第 %d 个盘子从 %c 挪动到 %c"</span>,n,start,<span class="built_in">end</span>);</span><br><span class="line">        hannuota(n<span class="number">-1</span>,help,start,<span class="built_in">end</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hannuota(<span class="number">3</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>);</span><br></pre></td></tr></table></figure>

<p>打印结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E&#x2F;TAG: 把第 1 个盘子从 A 挪动到 C</span><br><span class="line">E&#x2F;TAG: 把第 2 个盘子从 A 挪动到 B</span><br><span class="line">E&#x2F;TAG: 把第 1 个盘子从 C 挪动到 B</span><br><span class="line">E&#x2F;TAG: 把第 3 个盘子从 A 挪动到 C</span><br><span class="line">E&#x2F;TAG: 把第 1 个盘子从 B 挪动到 A</span><br><span class="line">E&#x2F;TAG: 把第 2 个盘子从 B 挪动到 C</span><br><span class="line">E&#x2F;TAG: 把第 1 个盘子从 A 挪动到 C</span><br></pre></td></tr></table></figure>


<h1 id="2-位运算知识："><a href="#2-位运算知识：" class="headerlink" title="2. 位运算知识："></a>2. 位运算知识：</h1><p>负数转二进制 = 原码的补码</p>
<ul>
<li><p>原码：<code>一个正数，按照绝对值大小转换成的二进制数；一个负数按照绝对值大小转换成的二进制数，然后最高位补1，称为原码。</code></p>
<p>  比如 00000000 00000000 00000000 00000101 是 5的 原码；10000000 00000000 00000000 00000101 是 -5的 原码。 　</p>
</li>
<li><p>反码：<code>正数的反码与原码相同，负数的反码为对该数的原码除符号位外各位取反。</code></p>
<p>  取反操作指：原为1，得0；原为0，得1。（1变0; 0变1）</p>
<p>  比如：正数00000000 00000000 00000000 00000101 的反码还是 00000000 00000000 00000000 00000101 ；</p>
<p>  负数10000000 00000000 00000000 00000101每一位取反（除符号位），得11111111 11111111 11111111 11111010。</p>
<p>  称：10000000 00000000 00000000 00000101 和 11111111 11111111 11111111 11111010互为反码。　</p>
</li>
<li><p>补码：<code>正数的补码与原码相同，负数的补码为对该数的原码除符号位外各位取反，然后在最后一位加1.</code></p>
<p>  比如：10000000 00000000 00000000 00000101 的反码是：11111111 11111111 11111111 11111010。</p>
<p>  那么，补码为：</p>
<p>  11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011</p>
<p>  所以，-5 在计算机中表达为：11111111 11111111 11111111 11111011。转换为十六进制：0xFFFFFFFB。</p>
</li>
</ul>
<h1 id="3-数组实现队列："><a href="#3-数组实现队列：" class="headerlink" title="3. 数组实现队列："></a>3. 数组实现队列：</h1><p><code>cap</code> 可以乱传，以下代码，保证size 为 2 的 幂次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// -1 二进制为：-1的源码的补码</span></span><br><span class="line">head = (head - <span class="number">1</span>) &amp; (<span class="built_in">size</span> - <span class="number">1</span>); <span class="comment">//(-1 &amp; size -1  = size - 1) 这样head的取值才是：size-1,size-2,size-3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayQueue</span>&lt;E&gt;:</span>:ArrayQueue(<span class="keyword">int</span> cap)&#123;</span><br><span class="line">    <span class="comment">// cap 可以乱传，以下代码保证是 2 的幂次</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cap &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">    LOGE(<span class="string">"size = %d"</span>,n);</span><br><span class="line">    <span class="built_in">size</span> = n;</span><br><span class="line">    <span class="built_in">array</span> = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思想：<code>head，和tail</code>用来标记队列的头尾，<code>从尾部开始插入修改head，从尾部拿去修改tail</code>。</p>
<p>完整代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ArrayQueue</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 必须是 2 的幂次</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队列的头索引（是反向的添加，从 size - 1 ,size -2,...添加）</span></span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队尾索引</span></span><br><span class="line">    <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数组地址</span></span><br><span class="line">    E *<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ArrayQueue();</span><br><span class="line"></span><br><span class="line">    ArrayQueue(<span class="keyword">int</span> <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">    ~ArrayQueue();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加到队尾巴</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除队首的元素（指的是 tail的位置）</span></span><br><span class="line">    <span class="function">E <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队首的位置，但不移除</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">growArray</span><span class="params">()</span></span>; <span class="comment">// 扩容数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copyElement</span><span class="params">(E *src,<span class="keyword">int</span> sPo, E *dest,<span class="keyword">int</span> dPo,<span class="keyword">int</span> len)</span></span>; <span class="comment">// 拷贝数组元素到新的数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayQueue</span>&lt;E&gt;:</span>:ArrayQueue():ArrayQueue(<span class="number">4</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayQueue</span>&lt;E&gt;:</span>:ArrayQueue(<span class="keyword">int</span> cap)&#123;</span><br><span class="line">    <span class="comment">// cap 可以乱传，以下代码保证是 2 的幂次</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(cap &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt; <span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    n += <span class="number">1</span>;</span><br><span class="line">    LOGE(<span class="string">"size = %d"</span>,n);</span><br><span class="line">    <span class="built_in">size</span> = n;</span><br><span class="line">    <span class="built_in">array</span> = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * <span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">array</span>[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayQueue</span>&lt;E&gt;:</span>:~ArrayQueue() &#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayQueue</span>&lt;E&gt;:</span>:enqueue(E e) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(head == tail &amp;&amp; <span class="built_in">array</span>[head]!=<span class="literal">NULL</span>)&#123; <span class="comment">// 弹出的时候把对应的元素置为 NULL,这样好判断能否扩容</span></span><br><span class="line">        LOGE(<span class="string">"扩容了 head = %d,tail = %d"</span>,head,tail);</span><br><span class="line">        <span class="comment">// 扩容，双端队列，头部增加删除，也可以在尾部增加删除</span></span><br><span class="line">        growArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -1 二进制为：-1的源码的补码</span></span><br><span class="line">    head = (head - <span class="number">1</span>) &amp; (<span class="built_in">size</span> - <span class="number">1</span>); <span class="comment">//(-1 &amp; size -1  = size - 1) 这样head的取值才是：size-1,size-2,size-3</span></span><br><span class="line">    <span class="built_in">array</span>[head] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">ArrayQueue</span>&lt;E&gt;:</span>:<span class="built_in">peek</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[(tail - <span class="number">1</span>) &amp; (<span class="built_in">size</span> - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">ArrayQueue</span>&lt;E&gt;:</span>:dequeue() &#123;</span><br><span class="line">    tail = (tail - <span class="number">1</span>) &amp; (<span class="built_in">size</span> - <span class="number">1</span>);</span><br><span class="line">    E value = <span class="built_in">array</span>[tail];</span><br><span class="line">    <span class="built_in">array</span>[tail] = <span class="literal">NULL</span>; <span class="comment">// 弹出去的元素置为 NULL;</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">ArrayQueue</span>&lt;E&gt;:</span>:isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> head == tail &amp;&amp; <span class="built_in">array</span>[head]==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayQueue</span>&lt;E&gt;:</span>:growArray() &#123;</span><br><span class="line">    <span class="keyword">int</span> new_size = <span class="built_in">size</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩容为原来的两倍</span></span><br><span class="line"></span><br><span class="line">    E *new_array = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * new_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数据进行 copy, 将 tail 后面的拷贝到前面，将tail 前面的拷贝到后面</span></span><br><span class="line">    <span class="keyword">int</span> rightLen = <span class="built_in">size</span> - tail;</span><br><span class="line">    copyElement(<span class="built_in">array</span>,tail,new_array,<span class="number">0</span>,rightLen);</span><br><span class="line">    copyElement(<span class="built_in">array</span>,<span class="number">0</span>,new_array,rightLen,tail);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>);</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    tail = <span class="built_in">size</span>;</span><br><span class="line">    <span class="built_in">size</span> = new_size;</span><br><span class="line">    <span class="built_in">array</span> = new_array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayQueue</span>&lt;E&gt;:</span>:copyElement(E *src, <span class="keyword">int</span> sPo, E *dest, <span class="keyword">int</span> dPo, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;len; ++i) &#123;</span><br><span class="line">        dest[dPo+i] = src[sPo+i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>Queue</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：10.二叉树常见操作、平衡二叉树</title>
    <url>/35.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure35binarytree" target="_blank" rel="noopener">NDKPractice项目的datastructure35binarytree</a></strong></p>
<h1 id="1-二叉树分类"><a href="#1-二叉树分类" class="headerlink" title="1. 二叉树分类"></a>1. 二叉树分类</h1><ol>
<li><code>普通二叉树</code></li>
<li><code>完全二叉树</code></li>
<li><code>满二叉树</code></li>
</ol>
<h2 id="完全二叉树："><a href="#完全二叉树：" class="headerlink" title="完全二叉树："></a><code>完全二叉树</code>：</h2><p>概念：<code>叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。</code><br><img src="/images/35.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<h2 id="满二叉树："><a href="#满二叉树：" class="headerlink" title="满二叉树："></a><code>满二叉树</code>：</h2><p>概念：<code>所有叶结点同处于最底层（非底层结点均是内部结点），一个深度为k(&gt;=-1)且有2^(k+1) - 1个结点</code><br><img src="/images/35.%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<h2 id="1-1-常用的操作树："><a href="#1-1-常用的操作树：" class="headerlink" title="1.1 常用的操作树："></a>1.1 常用的操作树：</h2><ol>
<li>二叉搜索树（Binary Search Tree）又称 B 树 （SQL）</li>
<li>哈夫曼树</li>
<li><font color="red">平衡二叉树(AVL树)：<code>可以是一棵空树，左右子树的高度差不会超过 1 ，并且左右两棵子树都是一棵平衡二叉树</code></font></li>
<li>红黑树</li>
</ol>
<h1 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2. 二叉树的遍历"></a>2. 二叉树的遍历</h1><p><img src="/images/35.%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">char</span> data)</span></span>&#123;</span><br><span class="line">    LOGE(<span class="string">"%c"</span>,data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-前序遍历"><a href="#2-1-前序遍历" class="headerlink" title="2.1 前序遍历"></a>2.1 前序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">preOrderTraverse</span>(<span class="title">TreeNode</span>&lt;T&gt; *<span class="title">pNode</span>,<span class="title">void</span>(*<span class="title">visit</span>)(<span class="title">T</span>))&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!pNode)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先根节点</span></span><br><span class="line">    visit(pNode-&gt;data);</span><br><span class="line">    <span class="comment">// 再左节点</span></span><br><span class="line">    preOrderTraverse(pNode-&gt;left,visit);</span><br><span class="line">    <span class="comment">// 再右节点</span></span><br><span class="line">    preOrderTraverse(pNode-&gt;right,visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-中序遍历"><a href="#2-2-中序遍历" class="headerlink" title="2.2 中序遍历"></a>2.2 中序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">infixOrderTraverse</span>(<span class="title">TreeNode</span>&lt;T&gt; *<span class="title">pNode</span>,<span class="title">void</span>(*<span class="title">visit</span>)(<span class="title">T</span>))&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!pNode)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先左节点</span></span><br><span class="line">    infixOrderTraverse(pNode-&gt;left,visit);</span><br><span class="line">    <span class="comment">// 再根节点</span></span><br><span class="line">    visit(pNode-&gt;data);</span><br><span class="line">    <span class="comment">// 再右节点</span></span><br><span class="line">    infixOrderTraverse(pNode-&gt;right,visit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-后序遍历"><a href="#2-3-后序遍历" class="headerlink" title="2.3 后序遍历"></a>2.3 后序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">afterOrderTraverse</span>(<span class="title">TreeNode</span>&lt;T&gt; *<span class="title">pNode</span>,<span class="title">void</span>(*<span class="title">visit</span>)(<span class="title">T</span>))&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!pNode)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先左节点</span></span><br><span class="line">    afterOrderTraverse(pNode-&gt;left,visit);</span><br><span class="line">    <span class="comment">// 再右节点</span></span><br><span class="line">    afterOrderTraverse(pNode-&gt;right,visit);</span><br><span class="line">    <span class="comment">// 再根节点</span></span><br><span class="line">    visit(pNode-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-层序遍历"><a href="#2-4-层序遍历" class="headerlink" title="2.4 层序遍历"></a>2.4 层序遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">levelOrderTraverse</span>(<span class="title">TreeNode</span>&lt;T&gt; *<span class="title">pNode</span>,<span class="title">void</span>(*<span class="title">visit</span>)(<span class="title">T</span>))&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!pNode)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode&lt;T&gt;*&gt; <span class="built_in">queue</span>;</span><br><span class="line">    <span class="built_in">queue</span>.push(pNode);</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">queue</span>.empty())&#123;</span><br><span class="line">        TreeNode&lt;T&gt; *front = <span class="built_in">queue</span>.front();</span><br><span class="line">        <span class="built_in">queue</span>.pop();</span><br><span class="line">        visit(front-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(front-&gt;left)</span><br><span class="line">            <span class="built_in">queue</span>.push(front-&gt;left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(front-&gt;right)</span><br><span class="line">            <span class="built_in">queue</span>.push(front-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-根据前序和中序遍历-或-后序和中序遍历还原二叉树"><a href="#3-根据前序和中序遍历-或-后序和中序遍历还原二叉树" class="headerlink" title="3. 根据前序和中序遍历 或 后序和中序遍历还原二叉树"></a>3. 根据<code>前序和中序遍历</code> 或 <code>后序和中序遍历</code>还原二叉树</h1><p>中序遍历 和 前序或后序任一种都可还原二叉树</p>
<p>前序：ABCDEFGH<br>中序：BDCEAFHG</p>
<p><img src="/images/35.%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E8%BF%98%E5%8E%9F%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<h1 id="4-二叉树的深度："><a href="#4-二叉树的深度：" class="headerlink" title="4. 二叉树的深度："></a>4. 二叉树的深度：</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取树的深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">getDepthTree</span>(<span class="title">TreeNode</span>&lt;T&gt; *<span class="title">pNode</span>)&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!pNode)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = getDepthTree(pNode-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = getDepthTree(pNode-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left,right) + <span class="number">1</span>; <span class="comment">// 需要加上自己</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-判断是否是平衡二叉树"><a href="#5-判断是否是平衡二叉树" class="headerlink" title="5. 判断是否是平衡二叉树"></a>5. 判断是否是平衡二叉树</h1><p><code>可以是一棵空树，左右子树的高度差不会超过 1 ，并且左右两棵子树都是一棵平衡二叉树</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  判断一棵树是否是平衡二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">isBalanceTree</span>(<span class="title">TreeNode</span>&lt;T&gt; *<span class="title">pNode</span>)&#123;</span></span><br><span class="line">    <span class="comment">// 可以是一棵空树，左右子树的高度差不会超过 1 ，并且左右两棵子树都是一棵平衡二叉树</span></span><br><span class="line">    <span class="keyword">if</span>(!pNode)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右子树的高度差不会超过 1</span></span><br><span class="line">    <span class="keyword">int</span> left = getDepthTree(pNode-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = getDepthTree(pNode-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并且左右两棵子树都是一棵平衡二叉树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(left-right) &lt;= <span class="number">1</span> &amp;&amp; isBalanceTree(pNode-&gt;left) &amp;&amp; isBalanceTree(pNode-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：11.二叉树序列化、优先级队列和堆排序</title>
    <url>/36.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure36heapsorting" target="_blank" rel="noopener">NDKPractice项目的datastructure36heapsorting</a></strong></p>
<h1 id="1-二叉树的序列化和反序列化"><a href="#1-二叉树的序列化和反序列化" class="headerlink" title="1. 二叉树的序列化和反序列化"></a>1. 二叉树的序列化和反序列化</h1><p><img src="/images/36.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt></p>
<h2 id="1-1-序列化"><a href="#1-1-序列化" class="headerlink" title="1.1 序列化"></a>1.1 序列化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serializeTree</span><span class="params">(TreeNode&lt;<span class="keyword">char</span>&gt; *pNode, <span class="built_in">string</span> &amp;str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pNode)&#123;</span><br><span class="line">        str.append(<span class="string">"#"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先添加根节点</span></span><br><span class="line">    str.append(<span class="built_in">string</span>(<span class="number">1</span>,pNode-&gt;data));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再左节点</span></span><br><span class="line">    serializeTree(pNode-&gt;left,str);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再右节点</span></span><br><span class="line">    serializeTree(pNode-&gt;right,str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-2-反序列化"><a href="#1-2-反序列化" class="headerlink" title="1.2 反序列化"></a>1.2 反序列化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化 (ABD##E##C#F##)</span></span><br><span class="line"><span class="comment"> * 注意：必须要传 2 级指针，如果是一级指针这只是传过来的数组，++的时候是不会对数组有影响的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">TreeNode&lt;<span class="keyword">char</span>&gt; *<span class="title">deserializeTree</span><span class="params">(<span class="keyword">char</span> **str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(**str == <span class="string">'#'</span>)&#123;</span><br><span class="line">        *str += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;<span class="keyword">char</span>&gt; *node = <span class="keyword">new</span> TreeNode&lt;<span class="keyword">char</span>&gt;(**str);</span><br><span class="line">    *str += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析左边的</span></span><br><span class="line">    node-&gt;left = deserializeTree(str);</span><br><span class="line">    <span class="comment">// 解析右边的</span></span><br><span class="line">    node-&gt;right = deserializeTree(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-优先级队列"><a href="#2-优先级队列" class="headerlink" title="2. 优先级队列"></a>2. 优先级队列</h1><p>数组转二叉树规律(前提：<code>index 从 1 开始</code>)：</p>
<p>left(左节点) = 父节点角标 * 2<br>right（右节点） = 父节点角标 * 2 + 1</p>
<ul>
<li><code>最大堆</code>：父节点永远比子节点大。</li>
<li><code>最小堆</code>：父节点永远比子节点小。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">PriorityQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 数组的大小，不够要扩容</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 当前数组的角标位置</span></span><br><span class="line">    E *<span class="built_in">array</span> = <span class="literal">NULL</span>; <span class="comment">// 数据数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向上调整为大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">array</span>[index] &gt; <span class="built_in">array</span>[index/<span class="number">2</span>])&#123;</span><br><span class="line">            swap(<span class="built_in">array</span>[index],<span class="built_in">array</span>[index/<span class="number">2</span>]);</span><br><span class="line">            shiftUp(index/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向下调整为大根堆</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k * <span class="number">2</span> &lt;= index)&#123; <span class="comment">// 到底的情况</span></span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">max</span> = k*<span class="number">2</span>; <span class="comment">// 先假设左孩子是最大的</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">max</span> + <span class="number">1</span> &lt;= index &amp;&amp; <span class="built_in">array</span>[<span class="built_in">max</span>] &lt; <span class="built_in">array</span>[<span class="built_in">max</span> + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">max</span> = <span class="built_in">max</span> + <span class="number">1</span>; <span class="comment">// 右孩子比左孩子大</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为没弹出之前就是大根堆，所以如果比子孩子最大的都还要大就不用排序了</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[k] &gt; <span class="built_in">array</span>[<span class="built_in">max</span>])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 交换，最大的往上冒</span></span><br><span class="line">            swap(<span class="built_in">array</span>[k],<span class="built_in">array</span>[<span class="built_in">max</span>]);</span><br><span class="line"></span><br><span class="line">            k = <span class="built_in">max</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PriorityQueue(<span class="keyword">int</span> count) : count(count) &#123;</span><br><span class="line">        <span class="built_in">array</span> = <span class="keyword">new</span> E[count];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        E <span class="built_in">max</span> = <span class="built_in">array</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 把最后一个赋值到第一个</span></span><br><span class="line">        <span class="built_in">array</span>[<span class="number">1</span>] = <span class="built_in">array</span>[index];</span><br><span class="line">        <span class="built_in">array</span>[index] = <span class="literal">NULL</span>;</span><br><span class="line">        index --;</span><br><span class="line">        shiftDown(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        <span class="built_in">array</span>[index + <span class="number">1</span>] = e;</span><br><span class="line">        index ++;</span><br><span class="line">        <span class="comment">// 不断的调整堆</span></span><br><span class="line">        shiftUp(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="3-堆排序-升序采用大根堆，降序采用小根堆"><a href="#3-堆排序-升序采用大根堆，降序采用小根堆" class="headerlink" title="3. 堆排序(升序采用大根堆，降序采用小根堆)"></a>3. 堆排序(升序采用大根堆，降序采用小根堆)</h1><p>将一个数组想象成一棵完全二叉树：</p>
<p>如果把一个数组排成完全二叉树，则是下标循环时，是从上到下，<code>从左到右</code>,进行填充</p>
<ol>
<li><code>i</code>的左子节点下标：<code>2*i+1</code> ,如果越界，证明左孩子不存在</li>
<li><code>i</code>的右子节点下标：<code>2*i+2</code>，如果越界，证明右孩子不存在</li>
<li><code>i</code>的父节点下标：<code>(i-1)/2</code>,注意下标0位置求父节点，(0-1)/2 = 0</li>
<li>第一个非叶子结点 <code>arr.length/2-1</code></li>
</ol>
<p>堆就是一棵完全二叉树。</p>
<ul>
<li><p><code>最大堆</code>：父节点永远比子节点大。</p>
</li>
<li><p><code>最小堆</code>：父节点永远比子节点小。</p>
</li>
<li><p>思想是：<code>将待排序序列构造成一个大根堆，此时，整个序列的最大值就是堆顶的根节点。  
将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个大根堆，再将堆顶的根节点和最后一个元素n-1交换。如此反复执行，便能得到一个有序序列了</code></p>
</li>
<li><p><code>时间复杂度</code>：<strong>O(N&#42;$\log_2 N$)</strong></p>
</li>
<li><p><code>空间复杂度</code>：<strong>O(1)</strong></p>
</li>
</ul>
<p><img src="/images/%E5%A0%86%E6%8E%92%E5%BA%8F.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整为大根堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjuastHeap</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = k * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; n)&#123; <span class="comment">// 到底的情况</span></span><br><span class="line">        <span class="comment">// 先假设左孩子最大</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">max</span> = left;</span><br><span class="line">        <span class="comment">// 有右孩子且右孩子大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">max</span> + <span class="number">1</span> &lt; n &amp;&amp; arr[<span class="built_in">max</span> + <span class="number">1</span>] &gt; arr[<span class="built_in">max</span>])&#123;</span><br><span class="line">            <span class="built_in">max</span> = <span class="built_in">max</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr[k] &gt; arr[<span class="built_in">max</span>]) <span class="comment">// 左右两个孩子都比父亲小，不用调整了</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将最大的和父亲进行交换</span></span><br><span class="line">        swap(arr[k],arr[<span class="built_in">max</span>]);</span><br><span class="line">        k = <span class="built_in">max</span>; <span class="comment">// 交换后接着往下调整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 从最后一个不是叶子节点的节点（叶结点自然不用调整），开始调整为大根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        adjuastHeap(arr,i,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 第一个与最后一个进行交换，最后一个值自然就是最大值了，接着把剩下的再进行大根堆排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>],arr[i]);<span class="comment">// 将最大的与末尾交换，这时末尾的就是最大值了</span></span><br><span class="line">        adjuastHeap(arr,<span class="number">0</span>,i); <span class="comment">// 对 第 0 个位置进行调整。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>排序</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：12.二叉搜索树</title>
    <url>/37.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure37binarysearchtree" target="_blank" rel="noopener">NDKPractice项目的datastructure37binarysearchtree</a></strong></p>
<h1 id="1-二叉搜索树的定义："><a href="#1-二叉搜索树的定义：" class="headerlink" title="1. 二叉搜索树的定义："></a>1. 二叉搜索树的定义：</h1><p>定义：<code>比它（当前根节点）小的放左边，比它（当前根节点）大的放右边</code></p>
<p><code>普通二叉搜索树的中序遍历，就是从小到大的排序  （数据排序）</code></p>
<h1 id="2-删除"><a href="#2-删除" class="headerlink" title="2.删除"></a>2.删除</h1><p>当删除节点的左右两个子节点都不为 NULL 的情况下，<code>从左边找最大值来替代</code>，<code>或者从右边找最小值</code></p>
<h1 id="3-代码"><a href="#3-代码" class="headerlink" title="3.代码"></a>3.代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode&lt;K,V&gt; *left = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; *right = <span class="literal">NULL</span>;</span><br><span class="line">    K key = <span class="literal">NULL</span>;</span><br><span class="line">    V value = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode(TreeNode&lt;K,V&gt; *pNode)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = pNode-&gt;left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = pNode-&gt;key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = pNode-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(K key, V value):key(key),value(value)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉搜索树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">BST</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 总个数</span></span><br><span class="line">    TreeNode&lt;K,V&gt; *root = <span class="literal">NULL</span>; <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BST()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~BST()&#123;</span><br><span class="line">        deleteAllNode(root);</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        root = addNode(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key == key)</span><br><span class="line">                <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &gt; key)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &lt; key)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key == key)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &gt; key)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &lt; key)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        root = removeNode(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历 就是相当于从小到大的升序遍历了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">infixOrderTraverse</span><span class="params">(<span class="keyword">void</span>(*<span class="built_in">log</span>)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">        infixOrderTraverse(root,<span class="built_in">log</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 删除所有的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllNode</span><span class="params">(TreeNode&lt;K,V&gt; *pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;left)</span><br><span class="line">            deleteAllNode(pNode-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right)</span><br><span class="line">            deleteAllNode(pNode-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span>(pNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; *addNode(TreeNode&lt;K,V&gt; *pNode,K key,V value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pNode)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;K,V&gt;(key,value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;key &gt; key)&#123;</span><br><span class="line">            pNode-&gt;left = addNode(pNode-&gt;left,key,value);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;key &lt; key)&#123;</span><br><span class="line">            pNode-&gt;right = addNode(pNode-&gt;right,key,value);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pNode-&gt;value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; *removeNode(TreeNode&lt;K,V&gt; *pNode,K key)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;key &gt; key)</span><br><span class="line">            pNode-&gt;left = removeNode(pNode-&gt;left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;key &lt; key)</span><br><span class="line">            pNode-&gt;right = removeNode(pNode-&gt;right);</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 相等找到了</span></span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left == <span class="literal">NULL</span> &amp;&amp; pNode-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span>(pNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; *right = pNode-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> (pNode);</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; *left = pNode-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> (pNode);</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左右两子树都不为空（把左子树的最大值作为根，或者右子树的最小值作为根）</span></span><br><span class="line">                TreeNode&lt;K, V&gt; *successor = <span class="keyword">new</span> TreeNode&lt;K, V&gt;(maximum(pNode-&gt;left));</span><br><span class="line">                successor-&gt;left = deleteMax(pNode-&gt;left);</span><br><span class="line">                count++;</span><br><span class="line">                successor-&gt;right = pNode-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> (pNode);</span><br><span class="line">                <span class="keyword">return</span> successor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K, V&gt; *deleteMax(TreeNode&lt;K, V&gt; *pNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode&lt;K, V&gt; *left = pNode-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> (pNode);</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode-&gt;right = deleteMax(pNode-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找当前树的左边的最大值 （右边的最小值怎么找？）</span></span><br><span class="line">    TreeNode&lt;K, V&gt; *maximum(TreeNode&lt;K, V&gt; *pNode) &#123;</span><br><span class="line">        <span class="comment">// 不断的往右边找，直到找到右子树为空节点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maximum(pNode-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">infixOrderTraverse</span><span class="params">(TreeNode&lt;K,V&gt; *pNode,<span class="keyword">void</span>(*<span class="built_in">log</span>)(<span class="keyword">int</span>,<span class="keyword">int</span>))</span></span>&#123;</span><br><span class="line">        <span class="comment">// 先左孩子</span></span><br><span class="line">        infixOrderTraverse(pNode-&gt;left,<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再根节点</span></span><br><span class="line">        <span class="built_in">log</span>(pNode-&gt;key,pNode-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再右孩子</span></span><br><span class="line">        infixOrderTraverse(pNode-&gt;right,<span class="built_in">log</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：14.红黑树</title>
    <url>/40%E3%80%81%2041.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure40redblacktree" target="_blank" rel="noopener">NDKPractice项目的datastructure40redblacktree</a></strong></p>
<h1 id="1-红黑树的定义："><a href="#1-红黑树的定义：" class="headerlink" title="1. 红黑树的定义："></a>1. 红黑树的定义：</h1><p>红黑树是一棵自平衡的二叉搜索树</p>
<p>特性：</p>
<ol>
<li>每个节点或者是黑色，或者是红色。</li>
<li>根节点是黑色。</li>
<li>每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</li>
<li>如果一个节点是红色的，则它的子节点必须是黑色的。</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ol>
<h1 id="2-新增逻辑："><a href="#2-新增逻辑：" class="headerlink" title="2. 新增逻辑："></a>2. 新增逻辑：</h1><p>分情况分析：</p>
<ol>
<li>如果没有出现双红现象，父亲是黑色的不需要修正；</li>
<li>叔叔是红色的 ，将叔叔和父亲染黑，然后爷爷染红；指针回到爷爷</li>
<li>叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的右孩子，将“父节点”作为“新的当前节点”，以“新的当前节点”为支点进行左旋。然后将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行右旋；</li>
<li>叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的左孩子，将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行右旋；</li>
<li>叔叔是黑色的，父亲是爷爷的右节点，且当前节点是其父节点的左孩子，将“父节点”作为“新的当前节点”，以“新的当前节点”为支点进行右旋。然后将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行左旋；</li>
<li>叔叔是黑色的，父亲是爷爷的右节点，且当前节点是其父节点的右孩子，将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行左旋；</li>
</ol>
<p>上面的双红修正现象看似比较复杂，但实际上只有三种情况，一种是没有双红现象，另一种是父亲和叔叔都是红色的，最后一种是叔叔是黑色的。我们来画个实例看下：以 [3,2,1,4,5] 为例</p>
<p><img src="/images/40.%E7%BA%A2%E9%BB%91%E6%A0%91%E6%96%B0%E5%A2%9E.png" alt></p>
<h1 id="3-删除逻辑："><a href="#3-删除逻辑：" class="headerlink" title="3. 删除逻辑："></a><a href="https://blog.csdn.net/a944750471/article/details/92384553" target="_blank" rel="noopener">3. 删除逻辑：</a></h1><p>讨论下：</p>
<ol>
<li>删除一个红色节点不影响；</li>
<li>加入删除一个黑色节点那么肯定会破坏性质 5</li>
<li>假设左右子树都不为空的情况下，需要找到后继节点来代替，其实删除的就是后继节点</li>
<li>假设删除的左右两棵子树上有一颗不为空的情况，会找左右的一棵子树来代替</li>
</ol>
<p><code>左右子树不为null的情况下实际删除的是后继节点</code></p>
<ol>
<li>如果兄弟节点是红色的，把兄弟节点染黑，父节点染红，左/右旋父节点；</li>
<li>如果兄弟节点是黑色的，并且两个侄子节点都是黑色的，将兄弟节点染红，指针回溯至父亲节点；</li>
<li>如果兄弟节点是黑色，的并且远侄子是黑色的，近侄子是红色的，将进侄子染黑，兄弟染红，左/右旋兄弟节点，进入下面情况 4 ；</li>
<li>如果兄弟节点是黑色的，并且远侄子是红色的，近侄子随意，将兄弟节点染成父亲节点的颜色，父亲节点染黑，远侄子染黑，左/右旋父亲节点。</li>
</ol>
<p><img src="/images/40.%E7%BA%A2%E9%BB%91%E6%A0%91%E5%88%A0%E9%99%A4.png" alt></p>
<h1 id="4-红黑树与-AVL-树的对比"><a href="#4-红黑树与-AVL-树的对比" class="headerlink" title="4.红黑树与 AVL 树的对比"></a>4.红黑树与 AVL 树的对比</h1><p>AVL : 插入的思想，在插入的过程中不断去调整树，最坏的情况下可能每次回溯都需要调整（回溯到父亲节点）<br>红黑树：可能会出现双红现象，如果叔叔是黑色的只需要调整一次或者两次 ，最坏的情况下就是叔叔节点是红色，但每次回溯的时候是两层（回溯到爷爷节点）</p>
<p>查找：AVL 复杂度是 log(N)，红黑树复杂度是 Log(2N)<br>新增：AVL 复杂度是 log(N)，红黑树复杂度是 Log(N) / 2<br>删除：AVL 复杂度是 log(N)，红黑树复杂度是 Log(N) / 2 </p>
<p><code>红黑树的查询性能略微逊色于AVL树</code>，因为其比AVL树会稍微不平衡最多一层，也就是说红黑树的查询性能只比相同内容的AVL树最多多一次比较。<br>但是，<code>红黑树在插入和删除上优于AVL树</code>，AVL树每次插入删除会进行大量的平衡度计算，而红黑树为了维持红黑性质所做的红黑变换和旋转的开销，相较于AVL树为了维持平衡的开销要小得多。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>总结：实际应用中，若搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。</p>
<h1 id="6-代码："><a href="#6-代码：" class="headerlink" title="6. 代码："></a>6. 代码：</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> rb_color;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> black false <span class="comment">// 黑色  define 后面一定不能带分号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> red true <span class="comment">// 红色</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">map</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    TreeNode *root = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">map</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iterator</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">parent</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode ? pNode-&gt;parent : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">left</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode ? pNode-&gt;left : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">right</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode ? pNode-&gt;right : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">brother</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left(parent(pNode)) == pNode ? right(parent(pNode)) : left(parent(pNode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">rb_color <span class="title">getColor</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode ? pNode-&gt;color : black;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setColor</span><span class="params">(TreeNode *pNode, rb_color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode)</span><br><span class="line">            pNode-&gt;color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">l_rotation</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        TreeNode *right = pNode-&gt;right;</span><br><span class="line">        TreeNode *left = right-&gt;left;</span><br><span class="line">        pNode-&gt;right = left;</span><br><span class="line">        right-&gt;left = pNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整pNode 父亲指向</span></span><br><span class="line">        <span class="keyword">if</span> (!parent(pNode)) &#123;</span><br><span class="line">            root = right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;parent-&gt;left == pNode) &#123;</span><br><span class="line">            parent(pNode)-&gt;left = right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent(pNode)-&gt;right = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改父亲</span></span><br><span class="line">        right-&gt;parent = parent(pNode);</span><br><span class="line">        pNode-&gt;parent = right;</span><br><span class="line">        <span class="keyword">if</span> (left)</span><br><span class="line">            left-&gt;parent = pNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">r_rotation</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        TreeNode *left = pNode-&gt;left;</span><br><span class="line">        TreeNode *right = left-&gt;right;</span><br><span class="line">        pNode-&gt;left = right;</span><br><span class="line">        left-&gt;right = pNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整pNode 父亲指向</span></span><br><span class="line">        <span class="keyword">if</span> (!parent(pNode)) &#123;</span><br><span class="line">            root = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;parent-&gt;left == pNode) &#123;</span><br><span class="line">            parent(pNode)-&gt;left = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parent(pNode)-&gt;right = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改父亲</span></span><br><span class="line">        left-&gt;parent = parent(pNode);</span><br><span class="line">        pNode-&gt;parent = left;</span><br><span class="line">        <span class="keyword">if</span> (right)</span><br><span class="line">            right-&gt;parent = pNode;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调整顺序</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveDoubleRed</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pNode-&gt;parent &amp;&amp; pNode-&gt;parent-&gt;color == red) &#123; <span class="comment">// 父亲是红色</span></span><br><span class="line">            <span class="keyword">if</span> (getColor(brother(parent(pNode))) == red) &#123; <span class="comment">// 情况2：叔叔是红色的 ，将叔叔和父亲染黑，然后爷爷染红；</span></span><br><span class="line">                setColor(parent(pNode), black);</span><br><span class="line">                setColor(brother(parent(pNode)), black);</span><br><span class="line">                setColor(parent(parent(pNode)), red);</span><br><span class="line">                pNode = parent(parent(pNode));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 叔叔是黑色</span></span><br><span class="line">                <span class="keyword">if</span> (left(parent(parent(pNode))) == parent(pNode)) &#123;</span><br><span class="line">                    <span class="comment">// 情况3：叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的右孩子，将“父节点”作为“新的当前节点”，以“新的当前节点”为支点进行左旋。</span></span><br><span class="line">                    <span class="keyword">if</span> (right(parent(pNode)) == pNode) &#123;</span><br><span class="line">                        pNode = parent(pNode);</span><br><span class="line">                        l_rotation(pNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况4：叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的左孩子，将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行右旋；</span></span><br><span class="line">                    setColor(parent(pNode), black);</span><br><span class="line">                    setColor(parent(parent(pNode)), red);</span><br><span class="line">                    r_rotation(parent(parent(pNode)));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 情况3：叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的右孩子，将“父节点”作为“新的当前节点”，以“新的当前节点”为支点进行左旋。</span></span><br><span class="line">                    <span class="keyword">if</span> (left(parent(pNode)) == pNode) &#123;</span><br><span class="line">                        pNode = parent(pNode);</span><br><span class="line">                        r_rotation(pNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况4：叔叔是黑色的，父亲是爷爷的左节点，且当前节点是其父节点的左孩子，将“父节点”设为“黑色”，将“祖父节点”设为“红色”，以“祖父节点”为支点进行右旋；</span></span><br><span class="line">                    setColor(parent(pNode), black);</span><br><span class="line">                    setColor(parent(parent(pNode)), red);</span><br><span class="line">                    l_rotation(parent(parent(pNode)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root-&gt;color = black;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> TreeNode(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, key, value, black);</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> iterator(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最好我们插入红色节点，它不会违反性质 5 ，但是有可能违反性质 4</span></span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        TreeNode *parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            parent = node;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;key &gt; key)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;key &lt; key)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node-&gt;value = value;</span><br><span class="line">                <span class="keyword">return</span> iterator(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode *new_node = <span class="keyword">new</span> TreeNode(<span class="literal">NULL</span>, <span class="literal">NULL</span>, parent, key, value, red);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &lt; parent-&gt;key)</span><br><span class="line">            parent-&gt;left = new_node;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parent-&gt;right = new_node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调整顺序</span></span><br><span class="line">        solveDoubleRed(new_node);</span><br><span class="line"></span><br><span class="line">        count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> iterator(new_node);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode *<span class="title">findTree</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key == node-&gt;key) &#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key) &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键代码</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveLostBlack</span><span class="params">(TreeNode *pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (pNode != root &amp;&amp; pNode-&gt;color == black) &#123;</span><br><span class="line">            <span class="keyword">if</span> (left(parent(pNode)) == pNode) &#123;<span class="comment">// 当前节点是父亲节点的左节点</span></span><br><span class="line">                TreeNode *sib = brother(pNode);</span><br><span class="line">                <span class="keyword">if</span> (getColor(sib) == red) &#123; <span class="comment">// 想办法把兄弟节点变成黑色  情况 1</span></span><br><span class="line">                    setColor(sib, black);</span><br><span class="line">                    setColor(parent(pNode), red);</span><br><span class="line">                    l_rotation(parent(pNode));</span><br><span class="line">                    sib = brother(pNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (getColor(left(sib)) == black &amp;&amp; getColor(right(sib)) == black) &#123; <span class="comment">// 情况2</span></span><br><span class="line">                    setColor(sib, red);</span><br><span class="line">                    pNode = parent(pNode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 情况 3</span></span><br><span class="line">                    <span class="keyword">if</span> (getColor(right(sib)) == black) &#123;</span><br><span class="line">                        setColor(sib, red);</span><br><span class="line">                        setColor(left(sib), black);</span><br><span class="line">                        r_rotation(sib);</span><br><span class="line">                        sib = brother(pNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况 4</span></span><br><span class="line">                    setColor(sib, getColor(parent(pNode)));</span><br><span class="line">                    setColor(parent(pNode), black);</span><br><span class="line">                    setColor(right(sib), black);</span><br><span class="line">                    l_rotation(parent(pNode));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 相当于两行代码 ：break ，将根节点染黑</span></span><br><span class="line">                    pNode = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 当前节点是父亲节点的右节点</span></span><br><span class="line">                TreeNode *sib = brother(pNode);</span><br><span class="line">                <span class="keyword">if</span> (getColor(sib) == red) &#123; <span class="comment">// 想办法把兄弟节点变成黑色</span></span><br><span class="line">                    setColor(sib, black);</span><br><span class="line">                    setColor(parent(pNode), red);</span><br><span class="line">                    r_rotation(parent(pNode));</span><br><span class="line">                    sib = brother(pNode);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (getColor(left(sib)) == black &amp;&amp; getColor(right(sib)) == black) &#123;</span><br><span class="line">                    setColor(sib, red);</span><br><span class="line">                    pNode = parent(pNode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 情况 3  远侄子是 黑</span></span><br><span class="line">                    <span class="keyword">if</span> (getColor(left(sib)) == black) &#123;</span><br><span class="line">                        setColor(sib, red);</span><br><span class="line">                        setColor(right(sib), black);</span><br><span class="line">                        l_rotation(sib);</span><br><span class="line">                        sib = brother(pNode);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 情况 4</span></span><br><span class="line">                    setColor(sib, getColor(parent(pNode)));</span><br><span class="line">                    setColor(parent(pNode), black);</span><br><span class="line">                    setColor(left(sib), black);</span><br><span class="line">                    r_rotation(parent(pNode));</span><br><span class="line"></span><br><span class="line">                    pNode = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当遇到一个红色节点，把红色节点染黑即可</span></span><br><span class="line">        pNode-&gt;color = black;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        TreeNode *current = findTree(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current-&gt;left != <span class="literal">NULL</span> &amp;&amp; current-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode *successor = current-&gt;successor();</span><br><span class="line">            current-&gt;key = successor-&gt;key;</span><br><span class="line">            current-&gt;value = successor-&gt;value;</span><br><span class="line">            current = successor;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode *replace = current-&gt;left ? current-&gt;left : current-&gt;right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (replace != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 父亲  , current-&gt;parent 会不会有空的情况？</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;parent == <span class="literal">NULL</span>) &#123; <span class="comment">// 根节点</span></span><br><span class="line">                root = replace;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;parent-&gt;left == current) &#123;</span><br><span class="line">                current-&gt;parent-&gt;left = replace;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                current-&gt;parent-&gt;right = replace;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            replace-&gt;parent = current-&gt;parent;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;color == black) &#123;</span><br><span class="line">                solveLostBlack(replace);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">delete</span> (current);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current-&gt;parent == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除根节点的情况</span></span><br><span class="line">            <span class="keyword">delete</span> (root);</span><br><span class="line">            root = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 为什么不先移除，是因为在修正的时候需要去获取叔叔和侄子节点来分情况判断</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;color == black) &#123;</span><br><span class="line">                solveLostBlack(current);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再来移除</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;parent) &#123;</span><br><span class="line">                <span class="keyword">if</span> (current-&gt;parent-&gt;left == current) &#123;</span><br><span class="line">                    current-&gt;parent-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    current-&gt;parent-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">delete</span> (current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count == <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(<span class="keyword">void</span>(*<span class="built_in">log</span>)(K, V, <span class="keyword">bool</span>))</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode *node = root;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; nodes;</span><br><span class="line">        nodes.push(node);</span><br><span class="line">        <span class="keyword">while</span> (!nodes.empty()) &#123;</span><br><span class="line">            node = nodes.front();</span><br><span class="line">            <span class="built_in">log</span>(node-&gt;key, node-&gt;value, node-&gt;color);</span><br><span class="line">            nodes.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                nodes.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                nodes.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">map</span>&lt;K, V&gt;:</span>:TreeNode &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="comment">// 颜色</span></span><br><span class="line">    rb_color color;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode(TreeNode *left, TreeNode *right, TreeNode *parent, K key, V value, rb_color color)</span><br><span class="line">            : left(left), right(right), parent(parent), key(key), value(value), color(color) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到前驱</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">precursor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left) &#123;</span><br><span class="line">            TreeNode *node = left;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;right) &#123;</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (right) &#123; <span class="comment">// 左子树为NULL，右子树不为NULL</span></span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右子树都为 NULL 的情况</span></span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;right = <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode *myp = <span class="keyword">this</span>;</span><br><span class="line">                    <span class="keyword">while</span> (myp) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (myp-&gt;parent-&gt;left = myp)<span class="comment">// 在左子树</span></span><br><span class="line">                            myp = myp-&gt;parent;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 在根节点的右子树中</span></span><br><span class="line">                            <span class="keyword">return</span> myp-&gt;parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> myp;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找后驱</span></span><br><span class="line">    <span class="function">TreeNode *<span class="title">successor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right) &#123;</span><br><span class="line">            TreeNode *node = right;</span><br><span class="line">            <span class="keyword">while</span> (node-&gt;left) &#123;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (left) &#123; <span class="comment">// 左子树不为NULL，右子树为NULL</span></span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 左右子树都为 NULL 的情况</span></span><br><span class="line">                <span class="keyword">if</span> (parent-&gt;left = <span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> parent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    TreeNode *myp = <span class="keyword">this</span>;</span><br><span class="line">                    <span class="keyword">while</span> (myp) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (myp-&gt;parent-&gt;right = myp)<span class="comment">// 在右子树</span></span><br><span class="line">                            myp = myp-&gt;parent;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 在根节点的左子树中</span></span><br><span class="line">                            <span class="keyword">return</span> myp-&gt;parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> myp;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">map</span>&lt;K, V&gt;:</span>:iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode *node;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    iterator(TreeNode *node) : node(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找前驱</span></span><br><span class="line">    iterator &amp;<span class="keyword">operator</span>--() &#123;</span><br><span class="line">        node = node-&gt;precursor();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找后继</span></span><br><span class="line">    iterator &amp;<span class="keyword">operator</span>++() &#123;</span><br><span class="line">        node = node-&gt;successor();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    V <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
























]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：13.AVL树</title>
    <url>/38%E3%80%8139.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-AVL%E6%A0%91/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure38avl" target="_blank" rel="noopener">NDKPractice项目的datastructure38avl</a></strong></p>
<h1 id="1-AVL树的定义："><a href="#1-AVL树的定义：" class="headerlink" title="1. AVL树的定义："></a>1. AVL树的定义：</h1><p>定义：<code>左右两个子树高度不超过1</code></p>
<p>也称为<code>平衡二叉搜索树</code>,意义：</p>
<ol>
<li>普通二叉搜索树会出现极度不平衡的情况，复杂度有可能退化成O(n)</li>
<li>平衡二叉搜索树可确保复杂度在O(logn)</li>
</ol>
<h1 id="2-旋转操作"><a href="#2-旋转操作" class="headerlink" title="2.旋转操作"></a>2.旋转操作</h1><p>[3,2,1,4,5,6,7,10,9,8]</p>
<h2 id="2-1-左旋"><a href="#2-1-左旋" class="headerlink" title="2.1 左旋"></a>2.1 左旋</h2><p><img src="/images/38.%E5%B7%A6%E6%97%8B.png" alt></p>
<h2 id="2-2-右旋"><a href="#2-2-右旋" class="headerlink" title="2.2 右旋"></a>2.2 右旋</h2><p><img src="/images/38.%E5%8F%B3%E6%97%8B.png" alt></p>
<h2 id="2-3-先左旋再右旋"><a href="#2-3-先左旋再右旋" class="headerlink" title="2.3 先左旋再右旋"></a>2.3 先左旋再右旋</h2><p><img src="/images/38.%E5%85%88%E5%B7%A6%E6%97%8B%E5%86%8D%E5%8F%B3%E6%97%8B.png" alt></p>
<h2 id="2-4-先右旋再左旋"><a href="#2-4-先右旋再左旋" class="headerlink" title="2.4 先右旋再左旋"></a>2.4 先右旋再左旋</h2><p><img src="/images/38.%E5%85%88%E5%8F%B3%E6%97%8B%E5%86%8D%E5%B7%A6%E6%97%8B.png" alt></p>
<h1 id="3-移除"><a href="#3-移除" class="headerlink" title="3.移除"></a>3.移除</h1><p><code>比较复杂： 1. 当左右不为空，最大或者最小值会作为后继，要确保在删除最大或者最小值的时候要更新节点的高度</code></p>
<p>看项目工程代码的 <code>removeNode</code> 方法</p>
<h1 id="4-具体代码"><a href="#4-具体代码" class="headerlink" title="4. 具体代码"></a>4. 具体代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++ map multiMap 红黑树</span></span><br><span class="line"><span class="comment">// java Map 和 c++ Map 比较</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode&lt;K,V&gt; *left = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode&lt;K,V&gt; *right = <span class="literal">NULL</span>;</span><br><span class="line">    K key = <span class="literal">NULL</span>;</span><br><span class="line">    V value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">1</span>; <span class="comment">//自己算上，所以为1</span></span><br><span class="line"></span><br><span class="line">    TreeNode(TreeNode&lt;K,V&gt; *pNode):<span class="built_in">height</span>(pNode-&gt;<span class="built_in">height</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = pNode-&gt;left;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = pNode-&gt;right;</span><br><span class="line">        <span class="keyword">this</span>-&gt;key = pNode-&gt;key;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = pNode-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode(K key, V value):key(key),value(value),<span class="built_in">height</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉搜索树</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="title">class</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">AVL</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">// 总个数</span></span><br><span class="line">    TreeNode&lt;K,V&gt; *root = <span class="literal">NULL</span>; <span class="comment">// 根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AVL()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~AVL()&#123;</span><br><span class="line">        deleteAllNode(root);</span><br><span class="line">        root = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(K key,V value)</span></span>&#123;</span><br><span class="line">        root = addNode(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key == key)</span><br><span class="line">                <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &gt; key)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &lt; key)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">contains</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;key == key)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &gt; key)</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;key &lt; key)</span><br><span class="line">                node = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(K key)</span></span>&#123;</span><br><span class="line">        root = removeNode(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历 就是相当于从小到大的升序遍历了</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">infixOrderTraverse</span><span class="params">(<span class="keyword">void</span>(*<span class="built_in">log</span>)(K,V))</span></span>&#123;</span><br><span class="line">        infixOrderTraverse(root,<span class="built_in">log</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层序排列</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrderTraverse</span><span class="params">(<span class="keyword">void</span>(*<span class="built_in">log</span>)(K,V))</span></span>&#123;</span><br><span class="line">        levelOrderTraverse(root,<span class="built_in">log</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode&lt;K,V&gt; *pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pNode ? pNode-&gt;<span class="built_in">height</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 右旋</span></span><br><span class="line">    TreeNode&lt;K,V&gt;* r_rotation(TreeNode&lt;K,V&gt; *pNode)&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; *left = pNode-&gt;left;</span><br><span class="line">        TreeNode&lt;K,V&gt; *right = left-&gt;right;</span><br><span class="line"></span><br><span class="line">        left-&gt;right = pNode;</span><br><span class="line">        pNode-&gt;left = right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        pNode-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(pNode-&gt;left),getHeight(pNode-&gt;right))+<span class="number">1</span>;</span><br><span class="line">        left-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(left-&gt;left),getHeight(left-&gt;right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左旋</span></span><br><span class="line">    TreeNode&lt;K,V&gt;* l_rotation(TreeNode&lt;K,V&gt; *pNode)&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; *right = pNode-&gt;right;</span><br><span class="line">        TreeNode&lt;K,V&gt; *left = right-&gt;left;</span><br><span class="line"></span><br><span class="line">        right-&gt;left = pNode;</span><br><span class="line">        pNode-&gt;right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新高度</span></span><br><span class="line">        pNode-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(pNode-&gt;left),getHeight(pNode-&gt;right))+<span class="number">1</span>;</span><br><span class="line">        right-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(right-&gt;left),getHeight(right-&gt;right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先左旋再右旋</span></span><br><span class="line">    TreeNode&lt;K,V&gt;* l_r_rotation(TreeNode&lt;K,V&gt; *pNode)&#123;</span><br><span class="line">        pNode-&gt;left = l_rotation(pNode-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> r_rotation(pNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先右旋再左旋</span></span><br><span class="line">    TreeNode&lt;K,V&gt;* r_l_rotation(TreeNode&lt;K,V&gt; *pNode)&#123;</span><br><span class="line">        pNode-&gt;right = r_rotation(pNode-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> l_rotation(pNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除所有的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteAllNode</span><span class="params">(TreeNode&lt;K,V&gt; *pNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;left)</span><br><span class="line">            deleteAllNode(pNode-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right)</span><br><span class="line">            deleteAllNode(pNode-&gt;right);</span><br><span class="line">        <span class="keyword">delete</span>(pNode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; *addNode(TreeNode&lt;K,V&gt; *pNode,K key,V value)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!pNode)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode&lt;K,V&gt;(key,value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;value &gt; key)&#123;</span><br><span class="line">            pNode-&gt;left = addNode(pNode-&gt;left,key,value);</span><br><span class="line">            <span class="keyword">if</span>(getHeight(pNode-&gt;left) - getHeight(pNode-&gt;right) == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 调整</span></span><br><span class="line">                <span class="keyword">if</span>(getHeight(pNode-&gt;left-&gt;right) &gt; getHeight(pNode-&gt;left-&gt;left))&#123;</span><br><span class="line">                    <span class="comment">// 先左旋再右旋</span></span><br><span class="line">                    pNode = l_r_rotation(pNode);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pNode = r_rotation(pNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;value &lt; key)&#123;</span><br><span class="line">            pNode-&gt;right = addNode(pNode-&gt;right,key,value);</span><br><span class="line">            <span class="keyword">if</span>(getHeight(pNode-&gt;right) - getHeight(pNode-&gt;left) == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 调整</span></span><br><span class="line">                <span class="keyword">if</span>(getHeight(pNode-&gt;right-&gt;left)&gt;getHeight(pNode-&gt;right-&gt;right))&#123;</span><br><span class="line">                    <span class="comment">// 先右旋再左旋</span></span><br><span class="line">                    pNode = r_l_rotation(pNode);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pNode = l_rotation(pNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pNode-&gt;value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新二叉树高度</span></span><br><span class="line">        pNode-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(pNode-&gt;left),getHeight(pNode-&gt;right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K,V&gt; *removeNode(TreeNode&lt;K,V&gt; *pNode,K key)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!pNode)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;key &gt; key)&#123;</span><br><span class="line">            pNode-&gt;left = removeNode(pNode-&gt;left,key);</span><br><span class="line">            <span class="keyword">if</span>(getHeight(pNode-&gt;right) - getHeight(pNode-&gt;left) == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 调整</span></span><br><span class="line">                <span class="keyword">if</span>(getHeight(pNode-&gt;right-&gt;left)&gt;getHeight(pNode-&gt;right-&gt;right))&#123;</span><br><span class="line">                    <span class="comment">// 先右旋再左旋</span></span><br><span class="line">                    pNode = r_l_rotation(pNode);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pNode = l_rotation(pNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;key &lt; key)&#123;</span><br><span class="line">            pNode-&gt;right = removeNode(pNode-&gt;right,key);</span><br><span class="line">            <span class="keyword">if</span>(getHeight(pNode-&gt;left) - getHeight(pNode-&gt;right) == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 调整</span></span><br><span class="line">                <span class="keyword">if</span>(getHeight(pNode-&gt;left-&gt;right) &gt; getHeight(pNode-&gt;left-&gt;left))&#123;</span><br><span class="line">                    <span class="comment">// 先左旋再右旋</span></span><br><span class="line">                    pNode = l_r_rotation(pNode);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pNode = r_rotation(pNode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// 相等找到了</span></span><br><span class="line">            count --;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;left == <span class="literal">NULL</span> &amp;&amp; pNode-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="keyword">delete</span>(pNode);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;left == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; *right = pNode-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> (pNode);</span><br><span class="line">                <span class="keyword">return</span> right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                TreeNode&lt;K, V&gt; *left = pNode-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> (pNode);</span><br><span class="line">                <span class="keyword">return</span> left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 左右子树都不为 NULL</span></span><br><span class="line">                <span class="keyword">if</span>(getHeight(pNode-&gt;left) &gt; getHeight(pNode-&gt;right))&#123;</span><br><span class="line">                    <span class="comment">// 左右两子树都不为空（把左子树的最大值作为根，或者右子树的最小值作为根），因为下面会删除这个节点所以需要重新赋值创建</span></span><br><span class="line">                    TreeNode&lt;K, V&gt; *<span class="built_in">max</span> = maximum(pNode-&gt;left);</span><br><span class="line">                    TreeNode&lt;K, V&gt; *successor = <span class="keyword">new</span> TreeNode&lt;K, V&gt;(<span class="built_in">max</span>);</span><br><span class="line">                    <span class="comment">// 删除左边最大的node，并更新高度</span></span><br><span class="line">                    successor-&gt;left = removeNode(pNode-&gt;left,<span class="built_in">max</span>-&gt;key);</span><br><span class="line">                    count++;</span><br><span class="line">                    successor-&gt;right = pNode-&gt;right;</span><br><span class="line">                    <span class="keyword">delete</span> (pNode);</span><br><span class="line">                    pNode = successor;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 左右两子树都不为空（把左子树的最大值作为根，或者右子树的最小值作为根），因为下面会删除这个节点所以需要重新赋值创建</span></span><br><span class="line">                    TreeNode&lt;K, V&gt; *<span class="built_in">min</span> = minimum(pNode-&gt;right);</span><br><span class="line">                    TreeNode&lt;K, V&gt; *successor = <span class="keyword">new</span> TreeNode&lt;K, V&gt;(<span class="built_in">min</span>);</span><br><span class="line">                    <span class="comment">// 删除右边最小的node，并更新高度</span></span><br><span class="line">                    successor-&gt;right = removeNode(pNode-&gt;right,<span class="built_in">min</span>-&gt;key);</span><br><span class="line">                    count++;</span><br><span class="line">                    successor-&gt;left = pNode-&gt;left;</span><br><span class="line">                    <span class="keyword">delete</span> (pNode);</span><br><span class="line">                    pNode = successor;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(getHeight(pNode-&gt;left),getHeight(pNode-&gt;right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    TreeNode&lt;K, V&gt; *deleteMax(TreeNode&lt;K, V&gt; *pNode) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            TreeNode&lt;K, V&gt; *left = pNode-&gt;left;</span><br><span class="line">            <span class="keyword">delete</span> (pNode);</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        pNode-&gt;right = deleteMax(pNode-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> pNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找当前树的左边的最大值 （右边的最小值怎么找？）</span></span><br><span class="line">    TreeNode&lt;K, V&gt; *maximum(TreeNode&lt;K, V&gt; *pNode) &#123;</span><br><span class="line">        <span class="comment">// 不断的往右边找，直到找到右子树为空节点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maximum(pNode-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找当前树的右边的最小值 （右边的最小值怎么找？）</span></span><br><span class="line">    TreeNode&lt;K, V&gt; *minimum(TreeNode&lt;K, V&gt; *pNode) &#123;</span><br><span class="line">        <span class="comment">// 不断的往右边找，直到找到右子树为空节点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maximum(pNode-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">infixOrderTraverse</span><span class="params">(TreeNode&lt;K,V&gt; *pNode,<span class="keyword">void</span>(*<span class="built_in">log</span>)(K,V))</span></span>&#123;</span><br><span class="line">        <span class="comment">// 所有递归都应有递归到底的情况</span></span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先左孩子</span></span><br><span class="line">        infixOrderTraverse(pNode-&gt;left,<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再根节点</span></span><br><span class="line">        <span class="built_in">log</span>(pNode-&gt;key,pNode-&gt;value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再右孩子</span></span><br><span class="line">        infixOrderTraverse(pNode-&gt;right,<span class="built_in">log</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelOrderTraverse</span><span class="params">(TreeNode&lt;K,V&gt; *pNode,<span class="keyword">void</span>(*<span class="built_in">log</span>)(K,V))</span></span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode&lt;K,V&gt; *&gt; que;</span><br><span class="line">        que.push(pNode);</span><br><span class="line">        <span class="keyword">while</span> (!que.empty())&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; *node = que.front();</span><br><span class="line">            <span class="built_in">log</span>(node-&gt;key,node-&gt;value);</span><br><span class="line">            que.pop(); <span class="comment">// 弹出</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                que.push(node-&gt;left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                que.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：16.ConcurrentHashMap分析</title>
    <url>/43.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-ConcurrentHashMap%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-HashMap-5-个线程-put-数据会发生什么？-（阿里面试第一面）"><a href="#1-HashMap-5-个线程-put-数据会发生什么？-（阿里面试第一面）" class="headerlink" title="1. HashMap 5 个线程 put 数据会发生什么？ （阿里面试第一面）"></a>1. HashMap 5 个线程 put 数据会发生什么？ （阿里面试第一面）</h1><p><img src="/images/43.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9CHashMap.png" alt></p>
<p><code>数据丢失</code>，<code>死循环 （扩容）</code></p>
<p>解决方案：</p>
<ol>
<li>hashTable</li>
<li>Collections.synchronizedMap()</li>
<li>ConcurrentHashMap</li>
</ol>
<p>前两种是锁着整个方法，分段锁 Lock , 分段锁 （synchronized，CAS）<br>先来分析一下 java的多线程内存模型</p>
<h1 id="2-Java-多线程的内存模型"><a href="#2-Java-多线程的内存模型" class="headerlink" title="2. Java 多线程的内存模型"></a>2. Java 多线程的内存模型</h1><p><img src="/images/43.java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt></p>
<p>Java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，<br>而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，线程、主内存和工作内存的交互关系如上图所示。</p>
<p>现在我们来想象一下，假设线程 1 把数据读到了自己的工作内存中，在 tab 角标为 1 的链表头插入了一条新的数据，倘若这时还没来得及将新增的数据刷新到主内中。接着线程 2 就把数据读到了自己的工作内存中，在 tab 角标为 1 的链表头插入了一条新的数据。接着线程 1 把新增数据刷新到主内存中，<br>线程 2 也把数据新增数据刷新到主内存中，那么线程 2 就会覆盖线程 1 的新增数据，从而导致数据丢失的情况。这里需要注意的是，只有两个线程都是操作 tab 的同一个 index 链表才会导致数据丢失的情况，如果不是同一个 index 链表就不会有覆盖和丢失这一说。</p>
<h1 id="3-synchronized-的底层实现原理"><a href="#3-synchronized-的底层实现原理" class="headerlink" title="3. synchronized 的底层实现原理"></a>3. synchronized 的底层实现原理</h1><p><img src="/images/43.synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt></p>
<p>关于 HashMap 的线程不安全问题，Java 给我们提供了三种方案，第一种是 HashTable ，第二种是 Collections.synchronizedMap() ，第三种是 ConcurrentHashMap 。而第一种和第二种都是通过用 synchronized 同步方法来保证线程安全，性能上有所欠缺不推荐大家使用。<br>ConcurrentHashMap 在 JDK 1.8 之前采用的是 Segment 分段锁来实现的，而 JDK 1.8 之后则采用 synchronized 和 CAS 来实现。</p>
<p>HashTable 通过锁住整个 put 和 get 方法来实现线程安全并不是很合理，因为一个线程在 put 的时候，另外一个线程不能再 put 和 get 必须进入等待状态。同理一个线程在 get 的时候，另外一个线程也不能再 get 和 put 。<br>上面通过分析只有两个线程都是操作 tab 的同一个 index 链表才会导致数据丢失的情况，如果不是同一个 index 链表就不会有覆盖和丢失这一说。因此也没必要锁住整个方法，只需要锁住每个 tab 的 index 链即可。</p>
<p>ConcurrentHashMap 在 JDK 1.8 之前采用的是 Segment 继承自 ReentrantLock 来锁住 tab 的 index 链，而 JDK 1.8 之后则采用 synchronized 来实现</p>
<h1 id="4-ConcurrentHashMap-源码分析"><a href="#4-ConcurrentHashMap-源码分析" class="headerlink" title="4. ConcurrentHashMap 源码分析"></a>4. ConcurrentHashMap 源码分析</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// volatile 保证可见性</span></span><br><span class="line">transient <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == null || value == null) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">// 二次 hash </span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">// 如果 tab 为空，初始化 tab</span></span><br><span class="line">            <span class="keyword">if</span> (tab == null || (n = tab.length) == <span class="number">0</span>)&#123;</span><br><span class="line">                tab = initTable();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前 tab 的 index 链表为 null</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, null, <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, null)))</span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                V oldVal = null;</span><br><span class="line">                <span class="comment">// 锁住当前 tab 的 index 链表（分段锁）</span></span><br><span class="line">                synchronized (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != null &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            <span class="comment">// CAS 操作</span></span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != null) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.<span class="built_in">find</span>(h, key)) != null ? p.val : null;</span><br><span class="line">            <span class="comment">// 遍历当前列表</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != null) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>ConcurrentHashMap</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>数据结构和算法学习</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：17.图</title>
    <url>/43.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%9B%BE/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure43graph" target="_blank" rel="noopener">NDKPractice项目的datastructure43graph</a></strong></p>
<h1 id="1-图的基本概念："><a href="#1-图的基本概念：" class="headerlink" title="1. 图的基本概念："></a>1. 图的基本概念：</h1><p>图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<p>图就是由 点 和 边组成。</p>
<p><code>注意：线性表中可以没有元素，称为空表。树中可以没有结点，叫做空树。但是在图中不允许没有顶点，可以没有边。</code></p>
<h1 id="2-基本术语："><a href="#2-基本术语：" class="headerlink" title="2. 基本术语："></a>2. 基本术语：</h1><ul>
<li><p>无向边：若顶点V1和V2之间的边没有方向，称这条边为无向边（Edge），用（V1，V2）来表示。</p>
</li>
<li><p>无向图（Undirected graphs）：图中任意两个顶点的边都是无向边。</p>
</li>
</ul>
<p><img src="/images/43.%E6%97%A0%E5%90%91%E5%9B%BE.png" alt></p>
<ul>
<li><p>有向边：若从顶点V1到V2的边有方向，称这条边为有向边，也称为弧（Arc），用&lt;V2, V1&gt;来表示，其中V1称为弧尾（Tail），V2称为弧头（Head）。</p>
</li>
<li><p>有向图（Directed graphs）：图中任意两个顶点的边都是有向边。</p>
</li>
</ul>
<p><img src="/images/43.%E6%9C%89%E5%90%91%E5%9B%BE.png" alt></p>
<ul>
<li><p>无向完全图：无向图中，任意两个顶点之间都存在边。</p>
</li>
<li><p>有向完全图：有向图中，任意两个顶点之间都存在方向相反的两条弧。</p>
</li>
<li><p>稀疏图；有很少条边或弧的图称为稀疏图 n*log(n)，反之称为稠密图。  相对的概念  （头发稀疏） 完全图肯定是稠密</p>
</li>
<li><p>权（Weight）：表示从图中一个顶点到另一个顶点的距离或耗费。</p>
</li>
<li><p>网：带有权重的图</p>
</li>
<li><p>度：与特定顶点相连接的边数；</p>
</li>
<li><p>出度、入度：有向图中的概念，出度表示以此顶点为起点的边的数目，入度表示以此顶点为终点的边的数目；</p>
</li>
<li><p>连通图：任意两个顶点都相互连通的图；</p>
</li>
<li><p>生成树：n个顶点，n-1条边 ，的图可以看成树 （生成树）</p>
</li>
<li><p>最小生成树：此生成树的边的权重之和是所有生成树中最小的；</p>
</li>
</ul>
<h1 id="3-图的存储结构"><a href="#3-图的存储结构" class="headerlink" title="3. 图的存储结构"></a>3. 图的存储结构</h1><h2 id="3-1-无向边存储图如下："><a href="#3-1-无向边存储图如下：" class="headerlink" title="3.1 无向边存储图如下："></a>3.1 无向边存储图如下：</h2><p><img src="/images/43.%E6%97%A0%E5%90%91%E8%BE%B9%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt></p>
<h2 id="3-2-有向边存储图如下："><a href="#3-2-有向边存储图如下：" class="headerlink" title="3.2 有向边存储图如下："></a>3.2 有向边存储图如下：</h2><p><img src="/images/43.%E6%9C%89%E5%90%91%E8%BE%B9%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.png" alt></p>
<h2 id="3-3-邻接表"><a href="#3-3-邻接表" class="headerlink" title="3.3  邻接表"></a>3.3  邻接表</h2><p><img src="/images/43.%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt></p>
<h2 id="3-4-十字链表"><a href="#3-4-十字链表" class="headerlink" title="3.4 十字链表"></a>3.4 十字链表</h2><p><img src="/images/43.%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8.png" alt></p>
<h1 id="4-深度优先遍历和广度优先遍历"><a href="#4-深度优先遍历和广度优先遍历" class="headerlink" title="4. 深度优先遍历和广度优先遍历"></a>4. 深度优先遍历和广度优先遍历</h1><p><img src="/images/43.%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt></p>
<h1 id="5-最小生成树和最短路径"><a href="#5-最小生成树和最短路径" class="headerlink" title="5. 最小生成树和最短路径"></a>5. 最小生成树和最短路径</h1><p><code>普里姆算法</code> : 每次都找最近的，与它相连的考虑进去，边修路边淘汰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 最小生成树（普里姆算法）</span><br><span class="line">    public void prim()&#123;</span><br><span class="line">        &#x2F;&#x2F; 定义一个数组内存，当前修好村庄，lowcost &#x3D; 0 代表已经修了</span><br><span class="line">        int[] lowcost &#x3D; new int[vertexSize];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 第一行的数据先放到 lowcost</span><br><span class="line">        for (int i &#x3D; 0; i &lt; vertexSize; i++) &#123;</span><br><span class="line">            lowcost[i] &#x3D; matrix[0][i];        &#x2F;&#x2F; [0,1,5,max,max,max,max,max,max]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 1; i &lt; vertexSize; i++) &#123;</span><br><span class="line">            int min &#x3D; MAX_WEIGHT;</span><br><span class="line">            int minId &#x3D; 0;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; 找最小的，之间是否连通</span><br><span class="line">            for (int j &#x3D; 1; j &lt; vertexSize; j++) &#123;</span><br><span class="line">                if(lowcost[j] &lt; min &amp;&amp; lowcost[j] !&#x3D; 0)&#123;</span><br><span class="line">                    min &#x3D; lowcost[j];</span><br><span class="line">                    minId &#x3D; j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; min &#x3D; 1, minId &#x3D; 1;</span><br><span class="line"></span><br><span class="line">            Log.e(&quot;TAG&quot;,&quot;找到村庄：&quot;+vertexs[minId] + &quot;, 修路距离：&quot; + min);</span><br><span class="line">            lowcost[minId] &#x3D; 0;</span><br><span class="line">            sum +&#x3D; min;</span><br><span class="line"></span><br><span class="line">            for (int k &#x3D; 0; k &lt; vertexSize; k++) &#123;</span><br><span class="line">                &#x2F;&#x2F; 边考虑边淘汰</span><br><span class="line">                if(matrix[minId][k] &lt; lowcost[k] &amp;&amp; lowcost[k] &gt; 0)&#123;</span><br><span class="line">                    lowcost[k] &#x3D; matrix[minId][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;            for (int o &#x3D; 0; o&lt; vertexSize; o++)&#123;</span><br><span class="line">&#x2F;&#x2F;                Log.e(&quot;TAG&quot;,&quot;i &#x3D; &quot;+o+&quot;,  number &#x3D; &quot; + lowcost[o]); &#x2F;&#x2F;[0,0,3,7,5,max,max,max,max]</span><br><span class="line">&#x2F;&#x2F;            &#125;</span><br><span class="line">&#x2F;&#x2F;            Log.e(&quot;TAG&quot;,&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Log.e(&quot;TAG&quot;,&quot;最短路径是：&quot; + sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>迪杰斯特拉算法</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成最短路径（迪杰斯特拉算法）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有没找到最短路径</span></span><br><span class="line">    <span class="keyword">boolean</span>[] isPath = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexSize];</span><br><span class="line">    <span class="comment">// 存放每个村庄的最短路径</span></span><br><span class="line">    <span class="keyword">int</span>[] shortPath = <span class="keyword">new</span> <span class="keyword">int</span>[vertexSize];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;vertexSize; i++) &#123;</span><br><span class="line">        shortPath[i] = matrix[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shortPath[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    isPath[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vertexSize; i++) &#123; <span class="comment">// 外循环每次找到下一个村庄最短的路径</span></span><br><span class="line">        <span class="keyword">int</span> minId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = MAX_WEIGHT;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; vertexSize; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(shortPath[j] &lt; min &amp;&amp; !isPath[j])&#123;</span><br><span class="line">                min = shortPath[j];   <span class="comment">// 1 4</span></span><br><span class="line">                minId = j;            <span class="comment">// 1 2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isPath[minId] = <span class="keyword">true</span>; <span class="comment">// 已经找到了最短的路径</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; vertexSize; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!isPath[k] &amp;&amp; (matrix[minId][k] + min) &lt; shortPath[k])&#123;</span><br><span class="line">                shortPath[k] = matrix[minId][k] + min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; vertexSize; k++) &#123;</span><br><span class="line">            Log.e(<span class="string">"TAG"</span>, shortPath[k]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"==================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexSize; i++) &#123;</span><br><span class="line">        Log.e(<span class="string">"TAG"</span>, <span class="string">"顶点 0 到顶点 "</span> + i + <span class="string">" 的最短距离为："</span> + shortPath[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






















]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：09.树、二叉树和森林</title>
    <url>/34.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<h1 id="1-工作中的一个小例子：登录后自动跳转到目标页面"><a href="#1-工作中的一个小例子：登录后自动跳转到目标页面" class="headerlink" title="1. 工作中的一个小例子：登录后自动跳转到目标页面"></a>1. 工作中的一个小例子：登录后自动跳转到目标页面</h1><p>需求例子：跳转到直播页，首先跳转到登录页，登录成功之后再跳转到直播页<br>比较好的解决方案，随着业务逻辑越来越复杂的情况下，不需要去刻意的去修改原来的代码  </p>
<p>解决办法：<br>1、传参数和Intent（复杂）<br>2、使用路由：Arouter、Drouter<br>3、拦截 Activity 的 <code>startActivityForResult</code> 方法（最好），使用 aspectJ 面向切面</p>
<h1 id="2-树的定义"><a href="#2-树的定义" class="headerlink" title="2. 树的定义"></a>2. 树的定义</h1><ol>
<li>有且只有一个根节点。</li>
<li>有若干互不相交的子树，这些子树本身也是一棵树（所有：树的算法求解一般可以采用<code>递归</code>）</li>
</ol>
<h1 id="3-树的名词解释"><a href="#3-树的名词解释" class="headerlink" title="3. 树的名词解释"></a>3. 树的名词解释</h1><ol>
<li><code>双亲节点（父节点）</code>：有子节点的位置</li>
<li><code>子节点</code>：有父节点</li>
<li><code>兄弟节点</code>：同一个父类下有很多的子节点，他们互相成为兄弟节点</li>
<li><code>度</code>：一个父节点下有多少个子节点</li>
<li><code>叶子节点</code>：没有子节点的节点</li>
</ol>
<h1 id="4-树的分类"><a href="#4-树的分类" class="headerlink" title="4. 树的分类"></a>4. 树的分类</h1><ol>
<li><code>一般树</code>:任意一个节点的子节点都不受限制。</li>
<li><code>二叉树</code>：任意一个节点的子节点最多<code>2</code>个，且子节点位置不能更改（左右子节点）。</li>
<li><code>森林</code>：n 棵互补相交的树的集合。</li>
</ol>
<h1 id="5-树的操作（树的存储）"><a href="#5-树的操作（树的存储）" class="headerlink" title="5. 树的操作（树的存储）"></a>5. 树的操作（树的存储）</h1><p>树的存储：<code>顺序存储</code>、<code>链式存储</code>，总共有以下几种方法：</p>
<ol>
<li>双亲表示法（找父亲比较简单，找孩子比较麻烦）</li>
<li>孩子表示法（找孩子比较简单，找父亲比较麻烦）</li>
<li>孩子双亲表示法（找父亲和孩子都比较简单）</li>
<li>二叉树表示法（一般树、森林与二叉树之间互转）</li>
</ol>
<h2 id="5-1-孩子双亲表示法"><a href="#5-1-孩子双亲表示法" class="headerlink" title="5.1 孩子双亲表示法"></a>5.1 孩子双亲表示法</h2><p><img src="/images/34.%E5%AD%A9%E5%AD%90%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95.png" alt></p>
<h2 id="5-2-二叉树表示法（一般树、森林与二叉树之间互转）"><a href="#5-2-二叉树表示法（一般树、森林与二叉树之间互转）" class="headerlink" title="5.2 二叉树表示法（一般树、森林与二叉树之间互转）"></a>5.2 二叉树表示法（一般树、森林与二叉树之间互转）</h2><h3 id="5-2-1一般树-转-二叉树"><a href="#5-2-1一般树-转-二叉树" class="headerlink" title="5.2.1一般树 转 二叉树"></a>5.2.1一般树 转 二叉树</h3><p>第一种方式：<br>　　1. 左节点当做左节点<br>　　2. <code>谁</code>的兄弟节点，就当做<code>谁</code>的右节点  </p>
<p>第二种方式：<br><img src="/images/34.%E6%A0%91%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
<h3 id="5-2-2-二叉树-转-树"><a href="#5-2-2-二叉树-转-树" class="headerlink" title="5.2.2 二叉树 转 树"></a>5.2.2 二叉树 转 树</h3><p><img src="/images/34.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%A0%91.png" alt></p>
<h3 id="5-2-3-森林转二叉树"><a href="#5-2-3-森林转二叉树" class="headerlink" title="5.2.3 森林转二叉树"></a>5.2.3 森林转二叉树</h3><p><img src="/images/34.%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：15.哈夫曼编码</title>
    <url>/42.%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure42huffman" target="_blank" rel="noopener">NDKPractice项目的datastructure42huffman</a></strong></p>
<ul>
<li>定长编码： 1 字节 8 位代表一个字符   a</li>
<li>变长编码： utf   哈夫曼编码</li>
</ul>
<h1 id="1-哈夫曼树定义："><a href="#1-哈夫曼树定义：" class="headerlink" title="1. 哈夫曼树定义："></a>1. 哈夫曼树定义：</h1><p>哈夫曼树（霍夫曼树）：外国大学生发现的，主要用于压缩，变长的编码，最优的前缀码二叉树</p>
<ul>
<li>路径长度：根节点到该节点的边的条数 = 节点个数 - 1</li>
<li>节点的权：出现的次数</li>
<li>带权路径长度：= 权（次数） * 路径的长度</li>
<li>树的带权路径长度（WLP）： = 所有节点的带权路径长度之和</li>
</ul>
<h1 id="2-如何构建一棵最优的哈夫曼树"><a href="#2-如何构建一棵最优的哈夫曼树" class="headerlink" title="2. 如何构建一棵最优的哈夫曼树"></a>2. 如何构建一棵最优的哈夫曼树</h1><p><code>怎样才是最优的？ 就是树的带权路径长度最小</code></p>
<p><code>aaaabbcccccccd</code></p>
<h2 id="2-1-统计字符出现的个数"><a href="#2-1-统计字符出现的个数" class="headerlink" title="2.1 统计字符出现的个数"></a>2.1 统计字符出现的个数</h2><p>a -&gt; 4， d -&gt; 1 , b -&gt; 2 , c -&gt; 7,</p>
<h2 id="2-2-构建赫夫曼树"><a href="#2-2-构建赫夫曼树" class="headerlink" title="2.2 构建赫夫曼树"></a>2.2 构建赫夫曼树</h2><p>首先拿两个频率出现最低的出来，然后再拿两个出现频率最小的出来</p>
<p>a -&gt; 4，  (d -&gt; 1 , b-&gt;2) -&gt; 3 , c -&gt; 7,<br>(d -&gt; 1 , b-&gt;2, a-&gt;4) -&gt; 7, c -&gt; 7,</p>
<h2 id="2-3-前缀码"><a href="#2-3-前缀码" class="headerlink" title="2.3. 前缀码"></a>2.3. 前缀码</h2><p>前缀编码 是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀。<br>例如：设有abcd需要编码表示（其中，a=0、b=10、c=110、d=11,则表示110的前缀可以是c或者da，不唯一）</p>
<p>很多地方用到：图片，音视频 ，霍夫曼</p>
<h2 id="2-4-哈夫曼编码和解码实现"><a href="#2-4-哈夫曼编码和解码实现" class="headerlink" title="2.4. 哈夫曼编码和解码实现"></a>2.4. 哈夫曼编码和解码实现</h2><p>思想：</p>
<ol>
<li>统计字符出现的次数</li>
<li>构建出这棵最优的前缀码二叉树</li>
<li>统计字符的编码，生成映射表</li>
<li>根据字符去映射表中查找生成最终的霍夫曼编码</li>
</ol>
<p><img src="/images/42.%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.png" alt></p>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：19.leetcode刷题-常用算法思想</title>
    <url>/47.leetcode%E5%88%B7%E9%A2%98-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="1-贪心算法思想"><a href="#1-贪心算法思想" class="headerlink" title="1. 贪心算法思想"></a>1. 贪心算法思想</h1><p>每次都选择正确的最优的解，不断反复</p>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">分发饼干-455</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/wiggle-subsequence/" target="_blank" rel="noopener">摆动序列-376</a></p>
</li>
</ul>
<h1 id="2-回溯算法思想"><a href="#2-回溯算法思想" class="headerlink" title="2. 回溯算法思想"></a>2. 回溯算法思想</h1><p>就是不断的试探，试探完就退回去重新选择，回溯  （都与递归有关系）</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/subsets/" target="_blank" rel="noopener">子集-78</a></li>
<li><a href="https://leetcode-cn.com/problems/subsets-ii/" target="_blank" rel="noopener">子集2-90</a></li>
</ul>
<h1 id="3-分治算法思想"><a href="#3-分治算法思想" class="headerlink" title="3. 分治算法思想"></a>3. 分治算法思想</h1><p>把 n 的问题分解成 K 个较小的子问题，这些问题是相互独立，求出子问题的解进行合并，就可以得到原问题的解 （归并排序，快速排序）</p>
<ul>
<li><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">计算右侧小于当前元素的个数-315</a></li>
</ul>
<h1 id="4-动态规划算法思想"><a href="#4-动态规划算法思想" class="headerlink" title="4. 动态规划算法思想"></a>4. 动态规划算法思想</h1><p>多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解 ， 原问题和子问题的问题 ，但是相互依赖   dp 求解</p>
<ul>
<li><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">爬楼梯-70</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">打家劫舍-198</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>leetcode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：02.android滤镜(不用opencv来写)</title>
    <url>/49.%20opencv-android%E6%BB%A4%E9%95%9C(%E4%B8%8D%E7%94%A8opencv%E6%9D%A5%E5%86%99)/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv49androidfiltereffects" target="_blank" rel="noopener">NDKPractice项目的opencv49androidfiltereffects</a></strong></p>
<h1 id="1-使用ColorMatrix颜色矩阵："><a href="#1-使用ColorMatrix颜色矩阵：" class="headerlink" title="1. 使用ColorMatrix颜色矩阵："></a>1. 使用ColorMatrix颜色矩阵：</h1><p>看下如何运算的：<br><img src="/images/49.ColorMatrix%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">public static Bitmap gray(@Nullable Bitmap src) &#123;</span><br><span class="line"></span><br><span class="line">    Bitmap dst &#x3D; Bitmap.createBitmap(src.getWidth(),src.getHeight(),src.getConfig());</span><br><span class="line">    Canvas canvas &#x3D; new Canvas(dst);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 通过 ColorMatrix 改变颜色矩阵</span><br><span class="line">    Paint paint &#x3D; new Paint();</span><br><span class="line">    paint.setDither(true);</span><br><span class="line">    paint.setAntiAlias(true);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ColorMatrix colorMatrix &#x3D; new ColorMatrix();</span><br><span class="line">    &#x2F;&#x2F; colorMatrix.setSaturation(0); &#x2F;&#x2F; 修改饱和度为0 也就是把颜色矩阵转成了灰度图,相当于下面的矩阵</span><br><span class="line"></span><br><span class="line">    &#x2F;*ColorMatrix colorMatrix &#x3D; new ColorMatrix(new float[]&#123; &#x2F;&#x2F; 灰度图效果</span><br><span class="line">            0.213f,0.715f,0.072f,0,0,</span><br><span class="line">            0.213f,0.715f,0.072f,0,0,</span><br><span class="line">            0.213f,0.715f,0.072f,0,0,</span><br><span class="line">            0,0,0,1,0</span><br><span class="line">    &#125;);*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*ColorMatrix colorMatrix &#x3D; new ColorMatrix(new float[]&#123; &#x2F;&#x2F; 原图效果</span><br><span class="line">            1,0,0,0,0,</span><br><span class="line">            0,1,0,0,0,</span><br><span class="line">            0,0,1,0,0,</span><br><span class="line">            0,0,0,1,0</span><br><span class="line">    &#125;);*&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;*ColorMatrix colorMatrix &#x3D; new ColorMatrix(new float[]&#123; &#x2F;&#x2F; 底片效果</span><br><span class="line">            -1,0,0,0,255,</span><br><span class="line">            0,-1,0,0,255,</span><br><span class="line">            0,0,-1,0,255,</span><br><span class="line">            0,0,0,1,0</span><br><span class="line">    &#125;);*&#x2F;</span><br><span class="line"></span><br><span class="line">    ColorMatrix colorMatrix &#x3D; new ColorMatrix(new float[]&#123; &#x2F;&#x2F; 提高亮度</span><br><span class="line">            1.2f,0,0,0,0,</span><br><span class="line">            0,1.2f,0,0,0,</span><br><span class="line">            0,0,1.2f,0,0,</span><br><span class="line">            0,0,0,1,0</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    paint.setColorFilter(new ColorMatrixColorFilter(colorMatrix)); &#x2F;&#x2F; 设置颜色矩阵</span><br><span class="line">    </span><br><span class="line">    canvas.drawBitmap(src,0,0,paint);</span><br><span class="line">    return dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-使用Bitmap的getPixels-和setPixels修改像素"><a href="#2-使用Bitmap的getPixels-和setPixels修改像素" class="headerlink" title="2. 使用Bitmap的getPixels()和setPixels修改像素"></a>2. 使用Bitmap的<code>getPixels()</code>和<code>setPixels</code>修改像素</h1><p>如果需要修改Bitmap本身的像素，复用则需要做调整：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var options &#x3D; BitmapFactory.Options()</span><br><span class="line">options.inMutable &#x3D; true &#x2F;&#x2F; 是否能修改</span><br><span class="line"></span><br><span class="line">var bitmap  &#x3D; BitmapFactory.decodeResource(resources,R.mipmap.copy,options)</span><br></pre></td></tr></table></figure>

<p>具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Bitmap gray2(@Nullable Bitmap src) &#123;</span><br><span class="line">    &#x2F;&#x2F; Bitmap dst &#x3D; Bitmap.createBitmap(src.getWidth(), src.getHeight(), src.getConfig());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; java层像素操作</span><br><span class="line">    int[] pixels &#x3D; new int[src.getWidth() * src.getHeight()];</span><br><span class="line"></span><br><span class="line">    src.getPixels(pixels, 0, src.getWidth(), 0, 0, src.getWidth(), src.getHeight());</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; pixels.length; i++) &#123;</span><br><span class="line">        int pixel &#x3D; pixels[i];</span><br><span class="line"></span><br><span class="line">        int a &#x3D; pixel &gt;&gt; 24 &amp; 0xFF;</span><br><span class="line">        int r &#x3D; pixel &gt;&gt; 16 &amp; 0xFF;</span><br><span class="line">        int g &#x3D; pixel &gt;&gt; 8 &amp; 0xFF;</span><br><span class="line">        int b &#x3D; pixel &amp; 0xFF;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 灰色</span><br><span class="line">        int gray &#x3D; (int) (0.213f * r + 0.715f * g + 0.072f * b);</span><br><span class="line">        &#x2F;&#x2F; pixels[i] &#x3D; a &lt;&lt; 24 | gray &lt;&lt; 16 | gray &lt;&lt; 8 | gray;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 黑白</span><br><span class="line">        int bw &#x3D; (r + g + b) &#x2F; 3 &gt; 125 ? 255 : 0;</span><br><span class="line">        pixels[i] &#x3D; a &lt;&lt; 24 | bw &lt;&lt; 16 | bw &lt;&lt; 8 | bw;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; dst.setPixels(pixels, 0, src.getWidth(), 0, 0, src.getWidth(), src.getHeight());</span><br><span class="line">    &#x2F;&#x2F; return dst;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 自己设置给自己，能复用不？,需要 BitmapFactory.Options.inMutable &#x3D; true</span><br><span class="line">    src.setPixels(pixels, 0, src.getWidth(), 0, 0, src.getWidth(), src.getHeight());</span><br><span class="line">    return src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-jni中操作（最好的方法）"><a href="#3-jni中操作（最好的方法）" class="headerlink" title="3. jni中操作（最好的方法）"></a>3. jni中操作（最好的方法）</h1><p>BitmapFactory.Options可以修改图片的颜色属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var options &#x3D; BitmapFactory.Options()</span><br><span class="line">options.inMutable &#x3D; true &#x2F;&#x2F; 是否能修改</span><br><span class="line">options.inPreferredConfig &#x3D; Bitmap.Config.RGB_565 &#x2F;&#x2F; 将图片转为 rgb_565格式</span><br><span class="line">&#x2F;&#x2F; RGB_565 747  ARGB_8888 1494  1 倍</span><br><span class="line">&#x2F;&#x2F; ARGB_8888 -&gt; RGB 565 RGB 5位R 6位G 5位B   16位</span><br><span class="line">var src  &#x3D; BitmapFactory.decodeResource(resources,R.mipmap.copy,options)</span><br></pre></td></tr></table></figure>

<p>jni中修改图片为黑白或者灰度的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv49androidfiltereffects_BitmapUtils_gray3(JNIEnv *env, jclass clazz,</span><br><span class="line">                                                             jobject src) &#123;</span><br><span class="line"></span><br><span class="line">    AndroidBitmapInfo info;</span><br><span class="line"></span><br><span class="line">    int result &#x3D; AndroidBitmap_getInfo(env,src,&amp;info);</span><br><span class="line">    if(result!&#x3D;0)</span><br><span class="line">        return -1;</span><br><span class="line"></span><br><span class="line">    void *pixels;</span><br><span class="line">    &#x2F;&#x2F; 锁定画布</span><br><span class="line">    AndroidBitmap_lockPixels(env,src,&amp;pixels);</span><br><span class="line"></span><br><span class="line">    if(info.format &#x3D;&#x3D; ANDROID_BITMAP_FORMAT_RGBA_8888)&#123;</span><br><span class="line">        uint32_t *pixels_p &#x3D; reinterpret_cast&lt;uint32_t*&gt;(pixels);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; info.width*info.height; ++i) &#123;</span><br><span class="line">            if(i !&#x3D; 0)</span><br><span class="line">                pixels_p+&#x3D;1;</span><br><span class="line"></span><br><span class="line">            int a &#x3D; *pixels_p &gt;&gt; 24 &amp; 0xFF;</span><br><span class="line">            int r &#x3D; *pixels_p &gt;&gt; 16 &amp; 0xFF;</span><br><span class="line">            int g &#x3D; *pixels_p &gt;&gt; 8 &amp; 0xFF;</span><br><span class="line">            int b &#x3D; *pixels_p &amp; 0xFF;</span><br><span class="line"></span><br><span class="line">            int gray &#x3D; (int) (0.213f * r + 0.715f * g + 0.072f * b);</span><br><span class="line"></span><br><span class="line">            *pixels_p &#x3D; a&lt;&lt;24 | gray &lt;&lt; 16 | gray &lt;&lt; 8 | gray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(info.format &#x3D;&#x3D; ANDROID_BITMAP_FORMAT_RGB_565)&#123;</span><br><span class="line">        uint16_t *pixels_p &#x3D; reinterpret_cast&lt;uint16_t*&gt;(pixels);</span><br><span class="line">        for (int i &#x3D; 0; i &lt; info.width*info.height; ++i) &#123;</span><br><span class="line">            if(i !&#x3D; 0)</span><br><span class="line">                pixels_p+&#x3D;1;</span><br><span class="line">            &#x2F;&#x2F; 8888 -&gt; 565</span><br><span class="line">            int r &#x3D; *pixels_p &gt;&gt; 11 &lt;&lt; 3 &amp; 0xFF;</span><br><span class="line">            int g &#x3D; *pixels_p &gt;&gt; 5 &lt;&lt; 2 &amp; 0xFF;</span><br><span class="line">            int b &#x3D; *pixels_p &lt;&lt; 3 &amp; 0xFF;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; f &#x3D; 0.213f * r + 0.715f * g + 0.072f * b  (32位来讲的  255,255,255),所以需要补齐8位</span><br><span class="line">            int gray &#x3D; (int) (0.213f * r + 0.715f * g + 0.072f * b);&#x2F;&#x2F; 8位</span><br><span class="line"></span><br><span class="line">            *pixels_p &#x3D; gray &gt;&gt;3 &lt;&lt; 11 | gray &gt;&gt;2 &lt;&lt;5 | gray &gt;&gt; 3;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 解锁画布</span><br><span class="line">    AndroidBitmap_unlockPixels(env,src);</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：04.图像的形状绘制和卷积掩膜操作</title>
    <url>/51.OpenCV-%E5%9B%BE%E5%83%8F%E7%9A%84%E5%BD%A2%E7%8A%B6%E7%BB%98%E5%88%B6%E5%92%8C%E5%8D%B7%E7%A7%AF%E6%8E%A9%E8%86%9C%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="1-inline-和-define"><a href="#1-inline-和-define" class="headerlink" title="1. inline 和 define"></a>1. inline 和 define</h1><p>inline是内联函数，类似于 define 都可以做到<code>编译时替换</code></p>
<p>区别：<code>define 并没有严格的检测,inline函数的参数有确切的类型所以会有严格的类型检测</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Max(a,b) a&gt;b ? a :b </span></span><br><span class="line"><span class="comment">// inline 内联函数，类似于 define 做到编译时替换</span></span><br><span class="line"><span class="comment">// 区别：define 并没有严格的检测,inline函数的参数有确切的类型所以会有严格的类型检测</span></span><br><span class="line"><span class="comment">// inline 使用场景：不涉及过于复杂的函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"E:/test.jpg"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max1(<span class="number">2</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    imshow(<span class="string">"src"</span>, src);</span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="2-形状和文件绘制"><a href="#2-形状和文件绘制" class="headerlink" title="2.形状和文件绘制"></a>2.形状和文件绘制</h1><ul>
<li>线 line</li>
<li>椭圆 ellipse</li>
<li>矩形 rectangle</li>
<li>圆 cicle</li>
<li>填充 fillPloy</li>
<li>文字 putText </li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断读取是否正确</span></span><br><span class="line">	<span class="keyword">if</span> (src.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"src read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.1 绘制线</span></span><br><span class="line">	<span class="comment">// LINE_8: 8联通线（8-connected）,即下一个点连接上一个点的边或角</span></span><br><span class="line">	<span class="comment">// LINE_4: 下一个点和上一个点边相连（没有角了）</span></span><br><span class="line">	<span class="built_in">line</span>(src,Point(<span class="number">10</span>,<span class="number">10</span>),Point(<span class="number">300</span>,<span class="number">300</span>),Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">5</span>,LINE_8);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.2 绘制矩形</span></span><br><span class="line">	rectangle(src, Point(<span class="number">20</span>, <span class="number">20</span>), Point(<span class="number">100</span>, <span class="number">100</span>), Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">5</span>, LINE_8);</span><br><span class="line">	rectangle(src, Rect(<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">50</span>), Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">5</span>, LINE_8);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.3 绘制椭圆</span></span><br><span class="line">	<span class="comment">// 第二个参数是：椭圆的中心点</span></span><br><span class="line">	<span class="comment">// 第三个参数: Size 第一个值是椭圆 x width 的半径， 第二个是 y height 的半径</span></span><br><span class="line">	ellipse(src,Point(src.cols/<span class="number">2</span>,src.rows/<span class="number">4</span>),Size(src.cols/<span class="number">8</span>,src.rows/<span class="number">4</span>),<span class="number">180</span>,<span class="number">0</span>,<span class="number">360</span>,Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">3</span>,LINE_AA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.4 园</span></span><br><span class="line">	<span class="built_in">circle</span>(src,Point(src.cols<span class="number">-500</span>,src.rows<span class="number">-500</span>),<span class="number">50</span>,Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">5</span>,LINE_AA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.5 填充 fillpoly 多边形</span></span><br><span class="line">	<span class="comment">/*CV_EXPORTS void fillPoly(InputOutputArray img, const Point** pts,</span></span><br><span class="line"><span class="comment">		const int* npts, int ncontours,</span></span><br><span class="line"><span class="comment">		const Scalar&amp; color, int lineType = LINE_8, int shift = 0,</span></span><br><span class="line"><span class="comment">		Point offset = Point());*/</span></span><br><span class="line">	Point pots[] = &#123; Point(<span class="number">100</span>, <span class="number">100</span>), Point(<span class="number">100</span>, <span class="number">200</span>), Point(<span class="number">200</span>, <span class="number">200</span>), Point(<span class="number">100</span>, <span class="number">100</span>) &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> Point* potss[] = &#123; pots &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> npts[] = &#123; <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">	fillPoly(src, potss, npts, <span class="number">1</span>, Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), LINE_8);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2,6 画文字</span></span><br><span class="line">	<span class="comment">// fontFace 字体</span></span><br><span class="line">	<span class="comment">// fontScale 缩放，大小</span></span><br><span class="line">	putText(src, <span class="string">"HI，OpenCV"</span>, Point(<span class="number">100</span>, <span class="number">100</span>), QT_FONT_BLACK,<span class="number">1</span>,Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>,LINE_AA);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.7 随机画 srand 画线</span></span><br><span class="line">	<span class="comment">// opencv 做随机 srand random 效果一样</span></span><br><span class="line">	<span class="function">RNG <span class="title">rng</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line">	<span class="comment">// 创建一张图片,与 src 的宽高和颜色通道一直，所有的点都是 0</span></span><br><span class="line">	Mat dst = Mat::zeros(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Point sp;</span><br><span class="line">		sp.x = rng.uniform(<span class="number">0</span>,dst.cols);</span><br><span class="line">		sp.y = rng.uniform(<span class="number">0</span>, dst.rows);</span><br><span class="line">		Point ep;</span><br><span class="line">		ep.x = rng.uniform(<span class="number">0</span>, dst.cols);</span><br><span class="line">		ep.y = rng.uniform(<span class="number">0</span>, dst.rows);</span><br><span class="line">		<span class="built_in">line</span>(dst, sp, ep, Scalar(rng.uniform(<span class="number">0</span>, <span class="number">255</span>), rng.uniform(<span class="number">0</span>, <span class="number">255</span>),rng.uniform(<span class="number">0</span>, <span class="number">255</span>)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, dst);</span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-图像卷积和滤波操作"><a href="#3-图像卷积和滤波操作" class="headerlink" title="3.图像卷积和滤波操作"></a>3.图像卷积和滤波操作</h1><p><img src="/images/51.%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C.png" alt></p>
<h2 id="3-1-图像矩阵掩膜操作-（可以过滤图像信息）"><a href="#3-1-图像矩阵掩膜操作-（可以过滤图像信息）" class="headerlink" title="3.1 图像矩阵掩膜操作 （可以过滤图像信息）"></a>3.1 图像矩阵掩膜操作 （可以过滤图像信息）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line">	<span class="keyword">if</span> (src.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"src read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面是掩膜操作</span></span><br><span class="line">	<span class="comment">// 生成一个和源图像大小相等类型相同的全 0 矩阵</span></span><br><span class="line">	<span class="comment">/*Mat dst = Mat::zeros(src.size(),src.type());</span></span><br><span class="line"><span class="comment">	int rows = src.rows;</span></span><br><span class="line"><span class="comment">	int cols = src.cols;</span></span><br><span class="line"><span class="comment">	int channels = src.channels();</span></span><br><span class="line"><span class="comment">	for (int i = 1; i &lt; rows - 1; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		// 上一行</span></span><br><span class="line"><span class="comment">		uchar* previous = src.ptr&lt;uchar&gt;(i-1);</span></span><br><span class="line"><span class="comment">		// 当前行</span></span><br><span class="line"><span class="comment">		uchar* current = src.ptr&lt;uchar&gt;(i);</span></span><br><span class="line"><span class="comment">		// 下一行</span></span><br><span class="line"><span class="comment">		uchar* next = src.ptr&lt;uchar&gt;(i+1);</span></span><br><span class="line"><span class="comment">		// 输出</span></span><br><span class="line"><span class="comment">		uchar* output = dst.ptr&lt;uchar&gt;(i);</span></span><br><span class="line"><span class="comment">		for (int j = channels; j &lt; (cols-1)*channels; j++)</span></span><br><span class="line"><span class="comment">		&#123;</span></span><br><span class="line"><span class="comment">			output[j] = saturate_cast&lt;uchar&gt;(5 * current[j] - (previous[j] + next[j] + current[j - channels] + current[j + channels]));</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// opencv 自带的掩膜操作</span></span><br><span class="line">	Mat dst;</span><br><span class="line">	Mat kernel = (Mat_&lt;<span class="keyword">char</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	filter2D(src,dst,src.depth(),kernel);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



















]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：18.leetcode刷题-数字和位运算、树</title>
    <url>/44.45.46.leetcode%E5%88%B7%E9%A2%98-%E6%95%B0%E5%AD%97%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%81%E6%A0%91/</url>
    <content><![CDATA[<h1 id="1-数字篇"><a href="#1-数字篇" class="headerlink" title="1. 数字篇"></a>1. 数字篇</h1><ol>
<li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和-1</a></li>
<li><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">整数反转-7</a></li>
</ol>
<h1 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2. 位运算"></a>2. 位运算</h1><ol>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">两数相加-2</a></li>
<li><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂-231</a></li>
<li><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">3的幂-326</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">位1的个数-191</a></li>
<li><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes/" target="_blank" rel="noopener">阶乘后的零-172</a></li>
</ol>
<h1 id="3-树"><a href="#3-树" class="headerlink" title="3. 树"></a>3. 树</h1><ol>
<li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历-94</a></li>
</ol>
<p>递归方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;           </span><br><span class="line">         <span class="keyword">return</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问</span></span><br><span class="line">    inorderTraversal(root-&gt;left,res);</span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    res-&gt;push_back(root-&gt;val);</span><br><span class="line">    inorderTraversal(root-&gt;right,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    inorderTraversal(root,&amp;res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   TreeNode left;</span><br><span class="line">   TreeNode right;</span><br><span class="line">   TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123; </span><br><span class="line">        Stack&lt;TraversalOperate&gt; operates = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        operates.push(<span class="keyword">new</span> TraversalOperate(<span class="number">1</span>,root));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!operates.isEmpty())&#123;</span><br><span class="line">            TraversalOperate top = operates.pop();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(top.root == null)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(top.operate == <span class="number">0</span>)</span><br><span class="line">                res.add(top.root.val);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 从下往上看</span></span><br><span class="line">                operates.add(<span class="keyword">new</span> TraversalOperate(<span class="number">1</span>,top.root.right));</span><br><span class="line">                operates.add(<span class="keyword">new</span> TraversalOperate(<span class="number">0</span>,top.root));</span><br><span class="line">                operates.add(<span class="keyword">new</span> TraversalOperate(<span class="number">1</span>,top.root.left));                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TraversalOperate</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> operate; <span class="comment">// 0 print  1 visit    </span></span><br><span class="line">        TreeNode root; <span class="comment">// 节点</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TraversalOperate</span><span class="params">(<span class="keyword">int</span> operate,TreeNode root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.operate = operate;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几个题</p>
<ul>
<li><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">第一题</a></li>
<li><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">第二题</a></li>
<li><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">第三题</a></li>
<li><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">第四题</a></li>
</ul>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>leetcode刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：01.OpenCV安装和转灰度图提升饱和度</title>
    <url>/48.OpenCV-%E5%AE%89%E8%A3%85%E5%92%8C%E8%BD%AC%E7%81%B0%E5%BA%A6%E5%9B%BE%E6%8F%90%E5%8D%87%E9%A5%B1%E5%92%8C%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="1-VS-安装、配置Opencv的环境"><a href="#1-VS-安装、配置Opencv的环境" class="headerlink" title="1. VS 安装、配置Opencv的环境"></a>1. VS 安装、配置Opencv的环境</h1><p>我们是在 windows的<code>VS</code>中开发 使用功能的方式是：<code>头文件+dll文件</code>的方式来学习opencv的一些常见使用方法。</p>
<ol>
<li>下载 <a href="https://github.com/opencv/opencv/releases" target="_blank" rel="noopener">opencv.exe</a> 并解压</li>
<li>生成-&gt;配置管理器-&gt;平台修改为<code>x64</code></li>
<li>配置windows环境变量：path : <code>opencv解压目录\build\x64\vc14\bin</code></li>
<li>配置头文件包含目录：<code>调试</code>-&gt;<code>xx属性</code>-&gt; <code>配置属性</code> -&gt;<code>VC++ 目录</code>-&gt; <code>包含目录</code>: <code>opencv解压目录\build\include</code></li>
<li>配置库目录：<code>调试</code>-&gt;<code>xx属性</code> -&gt; <code>配置属性</code> -&gt;<code>VC++ 目录</code>-&gt; <code>库目录</code>：<code>opencv解压目录\build\x64\vc14\lib</code></li>
<li>链接器：<code>opencv解压目录\build\x64\vc14\lib</code> 中的 <code>opencv_world440d.lib</code> 复制文件名至<br> <code>调试</code>-&gt;<code>xx属性</code> -&gt; <code>配置属性</code> -&gt;<code>VC++ 目录</code>-&gt; <code>链接器</code> -&gt; <code>输入</code> -&gt; <code>附加依赖项</code>。<br> <font color="red">注意：带d的适用于debug模式，不带d的使用于release模式</font></li>
<li>.dll 系统适配，如果第6步完成后报错<code>xxx.dll</code>未找到，则先把<code>opencv解压目录\build\x64\vc14\bin</code>中的dll文件<br> 复制到<code>系统盘\windows\System32</code>和<code>系统盘\windows\SysWOW54</code>,如果还是不是，则将第6步的文件换成release模式下的文件</li>
</ol>
<h1 id="c-中-uchar"><a href="#c-中-uchar" class="headerlink" title="c++ 中 uchar"></a>c++ 中 uchar</h1><p>char 是有符号的 unsigned char 是无符号的,char 整数范围为-128到127( 0x80__0x7F)， 而unsigned char 整数范围为0到255( 0__0xFF )<br>有时候想把整数数值限在255范围内，也用unsigned char，这个类型在嵌入式用的多,<code>所以 uchar 一般用于图片处理</code></p>
<h1 id="2-opencv方法介绍："><a href="#2-opencv方法介绍：" class="headerlink" title="2. opencv方法介绍："></a>2. opencv方法介绍：</h1><ul>
<li>Mat src = cv::imread(“图片路径”) ：读取读片，注意 windows 中路径分隔符一定得修改为：<code>/</code></li>
<li>cv::imwrite(“保存路径”,mat); 把 mat 写入文件,注意 windows 中路径分隔符一定得修改为：<code>/</code></li>
<li>cv::imshow(“test pic”,mat); 显示图片</li>
<li>int height = cv::mat.rows  // 获取 mat 的行高</li>
<li>int width = cv::mat.cols  // 获取 mat 的列宽</li>
<li>int channels= mat.channels() // 颜色通道，一个像素点几个信息 3（BGR） 4（BGRA）</li>
<li>saturate_cast<uchar>(b_w); // 大于 255 就变成 255 ，如果小于 0 就变成 0 </uchar></li>
</ul>
<h1 id="3-彩色图转灰度图及黑白图（手写）"><a href="#3-彩色图转灰度图及黑白图（手写）" class="headerlink" title="3. 彩色图转灰度图及黑白图（手写）"></a>3. 彩色图转灰度图及黑白图（手写）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; src.rows; i++)&#123;</span><br><span class="line">	<span class="comment">// 读取当前行的首地址</span></span><br><span class="line">	uchar* start_pixels = src.ptr&lt;uchar&gt;(i);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.cols; j++)&#123;</span><br><span class="line">		uchar b = start_pixels[<span class="number">0</span>];</span><br><span class="line">		uchar g = start_pixels[<span class="number">1</span>];</span><br><span class="line">		uchar r = start_pixels[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 彩色转灰度</span></span><br><span class="line">		<span class="comment">// 公式计算 f =  0.11R + 0.59G + 0.30B   gery 最大255 ，其他处理可能会超过 255</span></span><br><span class="line">		<span class="comment">// uchar gery = 0.11f*r + 0.59f*g + 0.30f*b;</span></span><br><span class="line">		uchar gray = <span class="number">0.11f</span>*r + <span class="number">0.59f</span>*g + <span class="number">0.30f</span>*b;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 彩色转黑白</span></span><br><span class="line">		uchar bw = (b + g + r) / <span class="number">3</span> &gt; <span class="number">125</span> ? <span class="number">255</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// saturate_cast 大于 255就变成255 ，小于0 就变成0</span></span><br><span class="line">		<span class="comment">/* start_pixels[0] = saturate_cast&lt;uchar&gt;(bw);</span></span><br><span class="line"><span class="comment">		start_pixels[1] = saturate_cast&lt;uchar&gt;(bw);</span></span><br><span class="line"><span class="comment">		start_pixels[2] = saturate_cast&lt;uchar&gt;(bw);*/</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 饱和度提升会更亮些</span></span><br><span class="line">		start_pixels[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(<span class="number">1.2f</span> * b);</span><br><span class="line">		start_pixels[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(<span class="number">1.2f</span> * g);</span><br><span class="line">		start_pixels[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(<span class="number">1.2f</span> * r);</span><br><span class="line"></span><br><span class="line">		start_pixels += <span class="number">3</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：05.Bitmap性能优化(LruCache)和高斯模糊</title>
    <url>/52.OpenCV-Bitmap%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96(LruCache)%E5%92%8C%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A/</url>
    <content><![CDATA[<h1 id="1-Bitmap-占用内存分析及常见优化"><a href="#1-Bitmap-占用内存分析及常见优化" class="headerlink" title="1. Bitmap 占用内存分析及常见优化"></a>1. Bitmap 占用内存分析及常见优化</h1><p>分析工具：AS3.0以上使用 <code>Android Profile</code>,以下可以使用 <code>Android Device Monitor</code></p>
<p>优化：  </p>
<ol>
<li>耗时操作可以通过 <code>Rxjava</code> 去切换到子线程处理</li>
<li>如果涉及到高斯模糊，从网络上下载的大图，根据ui需求，通过 Glide 重新调整其大小（这样减少高斯模糊的计算时间）</li>
<li>使用LruCache 缓存，根据不同机型分配 不同的缓存 大小</li>
</ol>
<h2 id="1-1-Lrucache-两个点记录"><a href="#1-1-Lrucache-两个点记录" class="headerlink" title="1.1 Lrucache 两个点记录"></a>1.1 Lrucache 两个点记录</h2><ol>
<li>记得重写 Lrucache 的 <code>sizeOf(K key, V value)</code>方法为缓存的单个对象的大小，不然默认为 1</li>
<li>内存大小可以根据不同手机等条件动态设置</li>
</ol>
<p>Glide 的 <code>MemoryCache</code>的缓存大小为：<code>(一个屏幕图片大小=widthPixels*heightPixels*4)* 2</code>  </p>
<p>LruCache实际上就是一个 <code>LinkedHashMap( 补充知识：LinkedHashMap是一个双向循环列表，不支持线程安全，LruCache对它进行了封装添加了线程安全操作)，里面保存了一定数量的对象强引用</code>，<br>每次添加的新对象都是在链表的头，当分配的空间用完的时候会把末尾的对象移除，移除的对象就可以被gc回收了</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存图片</span></span><br><span class="line">Lrucache cache = Lrucache(<span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果不重写 Lrucache 的 `sizeOf(K key, V value)`方法 ，则默认可以缓存 4*1024*1024 张图片</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> LruCache&lt;<span class="keyword">String</span>, Bitmap&gt; mMemoryCache;<span class="comment">//声明缓存空间</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);<span class="comment">//获取应用在系统中的最大内存分配</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//分配1/8的应用内存作为缓存空间</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</span><br><span class="line"> </span><br><span class="line">mMemoryCache = <span class="keyword">new</span> LruCache&lt;<span class="keyword">String</span>, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> sizeOf(<span class="keyword">String</span> key, Bitmap bitmap) &#123;</span><br><span class="line">    <span class="comment">//重写sizeOf方法，返回图片的占用字节数而不是图片的个数，每次添加图片是会被调用</span></span><br><span class="line">    <span class="keyword">return</span> bitmap.getByteCount() / <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="2-图像模糊"><a href="#2-图像模糊" class="headerlink" title="2. 图像模糊"></a>2. 图像模糊</h1><p><img src="/images/52.%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E5%92%8C%E5%9D%87%E5%80%BC%E6%A8%A1%E7%B3%8A.png" alt></p>
<h2 id="2-1-均值模糊"><a href="#2-1-均值模糊" class="headerlink" title="2.1 均值模糊"></a>2.1 均值模糊</h2><p>操作：对当前像素点的周边半径，进行相加然后取平均值，赋值给当前像素点。</p>
<h2 id="2-2-高斯模糊"><a href="#2-2-高斯模糊" class="headerlink" title="2.2 高斯模糊"></a>2.2 高斯模糊</h2><p>操作： 对当前像素点的周边半径，求权重计算周边像素值，然后相加赋值给当前像素点。</p>
<p><font color="red">每个像素点都要处理，还有就是要去计算我们的正太分布的值（卷积核）</font><br><font color="red">如果半径越大，算法的复杂度越大，如果图片的宽高像素点越多，算法的复杂度也越大</font></p>
<p>高斯和均值模糊的区别：<code>高斯保留了一些轮廓，毛玻璃的效果</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (src.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"src read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 均值模糊</span></span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="comment">// Size（w,h）只能是基数，这样才能找到中心点</span></span><br><span class="line">	<span class="comment">// Point(-1,-1) 代表中心店</span></span><br><span class="line">	blur(src,dst,Size(<span class="number">151</span>,<span class="number">151</span>),Point(<span class="number">-1</span>,<span class="number">-1</span>));</span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高斯模糊</span></span><br><span class="line">	Mat gaussian;</span><br><span class="line">	<span class="comment">// sigmaX sigmaY 代表 作用</span></span><br><span class="line">	<span class="comment">// sigmaY 不传代表和 sigmaX 一样</span></span><br><span class="line">	<span class="comment">// 如果 sigmaX &lt;= 0 ,自己会计算 0.3*((ksize-1)*0.5 - 1) + 0.8</span></span><br><span class="line">	<span class="comment">// sigmaX 越小越没效果</span></span><br><span class="line">	GaussianBlur(src, gaussian, Size(<span class="number">151</span>, <span class="number">151</span>), <span class="number">0</span>);</span><br><span class="line">	imshow(<span class="string">"gaussian"</span>, gaussian);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>OpenCV</category>
        <category>LruCache</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>OpenCV</tag>
        <tag>LruCache</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构和算法：06.递归和数组实现栈结构</title>
    <url>/31.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E5%92%8C%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/datastructure31recursionandstack" target="_blank" rel="noopener">NDKPractice项目的datastructure31recursionandstack</a></strong></p>
<h1 id="1-递归和循环的区别："><a href="#1-递归和循环的区别：" class="headerlink" title="1. 递归和循环的区别："></a>1. 递归和循环的区别：</h1><ul>
<li>循环： <code>高效一些</code>,<code>循环能解决的问题递归也能解决</code></li>
<li>递归： <code>低效一些</code>，<code>递归能解决的问题循环不一定能解决</code></li>
</ul>
<h1 id="2-java-中的-stack（继承至-Vector）"><a href="#2-java-中的-stack（继承至-Vector）" class="headerlink" title="2. java 中的 stack（继承至 Vector）"></a>2. java 中的 stack（继承至 Vector）</h1><ul>
<li>vector ：没指定大小的情况下，初始大小为 <code>10</code>,扩容为当前大小的<code>一倍</code></li>
<li>ArrayList ： 没指定大小的情况下，初始大小为 <code>10</code>,扩容为当前大小的<code>二分之一</code></li>
</ul>
<h1 id="2-数组实现栈结构"><a href="#2-数组实现栈结构" class="headerlink" title="2. 数组实现栈结构"></a>2. 数组实现栈结构</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ArrayStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 栈顶元素的角标位置</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    E *<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">10</span>; <span class="comment">// 栈的初始大小</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造和析构</span></span><br><span class="line">    ArrayStack();</span><br><span class="line">    ~ArrayStack();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将元素压入栈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取栈顶的元素，不弹出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  栈是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">growArray</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayStack</span>&lt;E&gt;:</span>:ArrayStack() &#123;</span><br><span class="line">    <span class="built_in">array</span> = (E*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E)*<span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ArrayStack</span>&lt;E&gt;:</span>:~ArrayStack() &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] <span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayStack</span>&lt;E&gt;:</span>:growArray()&#123;</span><br><span class="line">    <span class="built_in">size</span> = <span class="built_in">size</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 改变内存空间大小</span></span><br><span class="line">    <span class="built_in">array</span> = (E*) <span class="built_in">realloc</span>(<span class="built_in">array</span>,<span class="built_in">size</span> * <span class="keyword">sizeof</span>(E));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ArrayStack</span>&lt;E&gt;:</span>:push(E e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(top + <span class="number">1</span> &gt;= <span class="built_in">size</span>)</span><br><span class="line">        growArray(); <span class="comment">// 扩容</span></span><br><span class="line">    <span class="built_in">array</span>[top++] = e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">ArrayStack</span>&lt;E&gt;:</span>:<span class="built_in">peek</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">ArrayStack</span>&lt;E&gt;:</span>:pop() &#123;</span><br><span class="line">    assert(top &gt;= <span class="number">0</span>);</span><br><span class="line">    E e = <span class="built_in">peek</span>();</span><br><span class="line">    <span class="built_in">array</span>[top--] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">ArrayStack</span>&lt;E&gt;:</span>:isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> top &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-链表实现栈结构"><a href="#3-链表实现栈结构" class="headerlink" title="3. 链表实现栈结构"></a>3. 链表实现栈结构</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    E value = <span class="literal">NULL</span>;</span><br><span class="line">    Node&lt;E&gt; *next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node(E value, Node&lt;E&gt; *next) : value(value), next(next) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">LinkedStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;E&gt; *first = <span class="literal">NULL</span>; <span class="comment">// 头结点</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    Node&lt;E&gt; *top = <span class="literal">NULL</span>; <span class="comment">// 栈顶元素</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LinkedStack();</span><br><span class="line"></span><br><span class="line">    ~LinkedStack();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将元素压入栈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取栈顶的元素，不弹出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弹出栈顶元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  栈是否为空</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">Node&lt;E&gt; *<span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Node</span>&lt;E&gt; *<span class="title">LinkedStack</span>&lt;E&gt;:</span>:node(<span class="keyword">int</span> index) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; *h = first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        h = h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">LinkedStack</span>&lt;E&gt;:</span>:push(E e) &#123;</span><br><span class="line">    Node&lt;E&gt; *new_node = <span class="keyword">new</span> Node&lt;E&gt;(e, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!first)</span><br><span class="line">        first = new_node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        top-&gt;next = new_node;</span><br><span class="line">    top = new_node;</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">LinkedStack</span>&lt;E&gt;:</span>:<span class="built_in">peek</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">E</span> <span class="title">LinkedStack</span>&lt;E&gt;:</span>:pop() &#123;</span><br><span class="line">    assert(index &gt;= <span class="number">0</span>);</span><br><span class="line">    E e = top-&gt;value;</span><br><span class="line">    <span class="keyword">delete</span> top;</span><br><span class="line"></span><br><span class="line">    top = node(--index);</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">LinkedStack</span>&lt;E&gt;:</span>:isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> index &lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedStack</span>&lt;E&gt;:</span>:LinkedStack() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">LinkedStack</span>&lt;E&gt;:</span>:~LinkedStack() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span>(node(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    first = <span class="literal">NULL</span>;</span><br><span class="line">    top = <span class="literal">NULL</span>;</span><br><span class="line">    index = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>Stack</category>
      </categories>
      <tags>
        <tag>数据结构和算法学习</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>Bitmap全面解析</title>
    <url>/53.OpenCV-Bitmap%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="1-dp-dip-dpi-px"><a href="#1-dp-dip-dpi-px" class="headerlink" title="1. dp dip  dpi  px"></a>1. dp dip  dpi  px</h1><ul>
<li>dp = dip：Android 为了适配不同的设备弄出来的单位 1dp = dpi（像素密度） / 160</li>
<li>dpi(dots per inch)：像素密度  = px / 英寸</li>
<li>px：像素</li>
</ul>
<p>他们之间的换算：<code>屏幕的总 dp = px / (dpi/160)</code></p>
<h1 id="2-Bitmap-大小计算-看源码"><a href="#2-Bitmap-大小计算-看源码" class="headerlink" title="2. Bitmap 大小计算 看源码"></a>2. Bitmap 大小计算 看源码</h1><p>以下是 java 层的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类:&#96;BitmapFactory&#96;.&#96;decodeResource&#96;(Resources res, int id)</span><br><span class="line"></span><br><span class="line">-&gt; 类:&#96;BitmapFactory&#96;.decodeResource(Resources res, int id, Options opts)</span><br><span class="line"></span><br><span class="line">-&gt; 类:&#96;BitmapFactory&#96;.decodeResourceStream(@Nullable Resources res, @Nullable TypedValue value,</span><br><span class="line">            @Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)&#123;</span><br><span class="line">                        if (opts &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            opts &#x3D; new Options();</span><br><span class="line">                        &#125;</span><br><span class="line">                </span><br><span class="line">                        if (opts.inDensity &#x3D;&#x3D; 0 &amp;&amp; value !&#x3D; null) &#123;</span><br><span class="line">                            final int density &#x3D; value.density;</span><br><span class="line">                            if (density &#x3D;&#x3D; TypedValue.DENSITY_DEFAULT) &#123;</span><br><span class="line">                                opts.inDensity &#x3D; DisplayMetrics.DENSITY_DEFAULT;  &#x2F;&#x2F; 根据放到哪个文件夹决定 density 的大小</span><br><span class="line">                            &#125; else if (density !&#x3D; TypedValue.DENSITY_NONE) &#123;</span><br><span class="line">                                opts.inDensity &#x3D; density;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        &#x2F;&#x2F; 获取当前手机设备的 dpi </span><br><span class="line">                        if (opts.inTargetDensity &#x3D;&#x3D; 0 &amp;&amp; res !&#x3D; null) &#123;</span><br><span class="line">                            opts.inTargetDensity &#x3D; res.getDisplayMetrics().densityDpi;</span><br><span class="line">                        &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">-&gt; 类:&#96;BitmapFactory&#96;.decodeStream(@Nullable InputStream is, @Nullable Rect outPadding,</span><br><span class="line">            @Nullable Options opts)</span><br><span class="line">            </span><br><span class="line">-&gt; 类:&#96;BitmapFactory&#96;.decodeStreamInternal(@NonNull InputStream is,</span><br><span class="line">            @Nullable Rect outPadding, @Nullable Options opts)</span><br><span class="line">            </span><br><span class="line">   &#x2F;&#x2F; 调用 native 层的方法解析图片</span><br><span class="line">-&gt; 类:&#96;BitmapFactory&#96;.nativeDecodeStream(InputStream is, byte[] storage,</span><br><span class="line">            Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle)</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line">private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage,</span><br><span class="line">            Rect padding, Options opts, long inBitmapHandle, long colorSpaceHandle);</span><br></pre></td></tr></table></figure>
<font color="red">
opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;  // 根据放到哪个文件夹决定 density 的大小

<ul>
<li>mdpi = 160</li>
<li>hdpi = 240</li>
<li>xhdpi = 320</li>
<li>xxhdpi = 480</li>
<li>xxxhdpi = 640</li>
</ul>
</font>



<p>以下是 native 层的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类 &#96;BitmapFactory.cpp&#96;.nativeDecodeStream(JNIEnv* env, jobject clazz, jobject is, jbyteArray storage,</span><br><span class="line">        jobject padding, jobject options, jlong inBitmapHandle, jlong colorSpaceHandle)</span><br><span class="line"></span><br><span class="line">-&gt; 类 &#96;BitmapFactory.cpp&#96;.doDecode(JNIEnv* env, std::unique_ptr&lt;SkStreamRewindable&gt; stream,</span><br><span class="line">                        jobject padding, jobject options, jlong inBitmapHandle,</span><br><span class="line">                        jlong colorSpaceHandle)</span><br><span class="line">                        </span><br><span class="line">&#x2F;&#x2F; 分析下这个方法</span><br><span class="line"></span><br><span class="line">static jobject doDecode(JNIEnv* env, std::unique_ptr&lt;SkStreamRewindable&gt; stream,</span><br><span class="line">                        jobject padding, jobject options, jlong inBitmapHandle,</span><br><span class="line">                        jlong colorSpaceHandle) &#123;</span><br><span class="line">    &#x2F;&#x2F; Set default values for the options parameters.</span><br><span class="line">    int sampleSize &#x3D; 1;    &#x2F;&#x2F; option里面要大小设置的参数，代表压缩几倍  BitmapFactory.Options. &#96;inSampleSize&#96;</span><br><span class="line">    bool onlyDecodeSize &#x3D; false;  &#x2F;&#x2F; 是否只获取图片的大小 BitmapFactory.Options. &#96;inJustDecodeBounds&#96; </span><br><span class="line">    SkColorType prefColorType &#x3D; kN32_SkColorType; </span><br><span class="line">    bool isHardware &#x3D; false; &#x2F;&#x2F; 是否硬件加速</span><br><span class="line">    bool isMutable &#x3D; false; &#x2F;&#x2F; 是否可以复用</span><br><span class="line">    float scale &#x3D; 1.0f;  &#x2F;&#x2F; 缩放</span><br><span class="line">    bool requireUnpremultiplied &#x3D; false;</span><br><span class="line">    jobject javaBitmap &#x3D; NULL;</span><br><span class="line">    sk_sp&lt;SkColorSpace&gt; prefColorSpace &#x3D; GraphicsJNI::getNativeColorSpace(colorSpaceHandle);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 获取 Options 里面的属性</span><br><span class="line">    if (options !&#x3D; NULL) &#123;</span><br><span class="line">        sampleSize &#x3D; env-&gt;GetIntField(options, gOptions_sampleSizeFieldID);</span><br><span class="line">        &#x2F;&#x2F; Correct a non-positive sampleSize.  sampleSize defaults to zero within the</span><br><span class="line">        &#x2F;&#x2F; options object, which is strange.</span><br><span class="line">        if (sampleSize &lt;&#x3D; 0) &#123;</span><br><span class="line">            sampleSize &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (env-&gt;GetBooleanField(options, gOptions_justBoundsFieldID)) &#123;</span><br><span class="line">            onlyDecodeSize &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; initialize these, in case we fail later on</span><br><span class="line">        env-&gt;SetIntField(options, gOptions_widthFieldID, -1);</span><br><span class="line">        env-&gt;SetIntField(options, gOptions_heightFieldID, -1);</span><br><span class="line">        env-&gt;SetObjectField(options, gOptions_mimeFieldID, 0);</span><br><span class="line">        env-&gt;SetObjectField(options, gOptions_outConfigFieldID, 0);</span><br><span class="line">        env-&gt;SetObjectField(options, gOptions_outColorSpaceFieldID, 0);</span><br><span class="line"></span><br><span class="line">        jobject jconfig &#x3D; env-&gt;GetObjectField(options, gOptions_configFieldID);</span><br><span class="line">        prefColorType &#x3D; GraphicsJNI::getNativeBitmapColorType(env, jconfig);</span><br><span class="line">        isHardware &#x3D; GraphicsJNI::isHardwareConfig(env, jconfig);</span><br><span class="line">        isMutable &#x3D; env-&gt;GetBooleanField(options, gOptions_mutableFieldID);</span><br><span class="line">        requireUnpremultiplied &#x3D; !env-&gt;GetBooleanField(options, gOptions_premultipliedFieldID);</span><br><span class="line">        javaBitmap &#x3D; env-&gt;GetObjectField(options, gOptions_bitmapFieldID);</span><br><span class="line"></span><br><span class="line">        if (env-&gt;GetBooleanField(options, gOptions_scaledField  ID)) &#123;</span><br><span class="line">            const int density &#x3D; env-&gt;GetIntField(options, gOptions_densityFieldID);</span><br><span class="line">            const int targetDensity &#x3D; env-&gt;GetIntField(options, gOptions_targetDensityFieldID);</span><br><span class="line">            const int screenDensity &#x3D; env-&gt;GetIntField(options, gOptions_screenDensityFieldID);</span><br><span class="line">            if (density !&#x3D; 0 &amp;&amp; targetDensity !&#x3D; 0 &amp;&amp; density !&#x3D; screenDensity) &#123;</span><br><span class="line">                &#x2F;&#x2F; 获取 scale 图片存放的文件夹不一样 scale 的值就不一样</span><br><span class="line">                scale &#x3D; (float) targetDensity &#x2F; density;   &#x2F;&#x2F; scale &#x3D; 420&#x2F;480 &#x3D; 0.875</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    SkISize size &#x3D; codec-&gt;getSampledDimensions(sampleSize);</span><br><span class="line">    int scaledWidth &#x3D; size.width();  &#x2F;&#x2F; 864</span><br><span class="line">    int scaledHeight &#x3D; size.height(); &#x2F;&#x2F; 582</span><br><span class="line">    bool willScale &#x3D; false;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Apply a fine scaling step if necessary. 如果 sampleSize !&#x3D; 1 的话就会进入到这个方法中 进行尺寸压缩</span><br><span class="line">    if (needsFineScale(codec-&gt;getInfo().dimensions(), size, sampleSize)) &#123;</span><br><span class="line">        willScale &#x3D; true;</span><br><span class="line">        scaledWidth &#x3D; codec-&gt;getInfo().width() &#x2F; sampleSize;</span><br><span class="line">        scaledHeight &#x3D; codec-&gt;getInfo().height() &#x2F; sampleSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; Scale is necessary due to density differences.  scale &#x3D; 420&#x2F;480 &#x3D; 0.875</span><br><span class="line">    if (scale !&#x3D; 1.0f) &#123; &#x2F;&#x2F; 0.833333  </span><br><span class="line">        willScale &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 0.5f 是很重要的</span><br><span class="line">        scaledWidth &#x3D; static_cast&lt;int&gt;(scaledWidth * scale + 0.5f); &#x2F;&#x2F; 756</span><br><span class="line">        scaledHeight &#x3D; static_cast&lt;int&gt;(scaledHeight * scale + 0.5f); &#x2F;&#x2F; 509 </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/Native%E5%B1%82%E8%A7%A3%E6%9E%90Bitmap%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt></p>
<h1 id="3-Bitmap-的内存开辟"><a href="#3-Bitmap-的内存开辟" class="headerlink" title="3. Bitmap 的内存开辟"></a>3. Bitmap 的内存开辟</h1><p>内存申请因为版本不同而有所区别：</p>
<p>Bitmap 的内存申请不同版本间有些许差异，在 <code>3.0-7.0</code> 的 bitmap 像素内存都是存放在 <code>Java heap</code> 中的，而 <code>8.0</code> 以后则是放在 <code>Native heap</code> 中的</p>
<p>看下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    logMemory();</span><br><span class="line"></span><br><span class="line">    Bitmap bitmap &#x3D; Bitmap.createBitmap(1024, 1024 * 500, Bitmap.Config.ARGB_8888);</span><br><span class="line"></span><br><span class="line">    logMemory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void logMemory() &#123;</span><br><span class="line">    ActivityManager activityManager &#x3D; (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);</span><br><span class="line">    ActivityManager.MemoryInfo memoryInfo &#x3D; new ActivityManager.MemoryInfo();</span><br><span class="line">    activityManager.getMemoryInfo(memoryInfo);</span><br><span class="line">    Log.e(&quot;TAG&quot;, &quot;AvailMem :&quot; + memoryInfo.availMem &#x2F; 1024 &#x2F; 1024);</span><br><span class="line">    Log.e(&quot;TAG&quot;, &quot;lowMemory：&quot; + memoryInfo.lowMemory);</span><br><span class="line">    Log.e(&quot;TAG&quot;, &quot;NativeHeapAllocatedSize :&quot; + Debug.getNativeHeapAllocatedSize() &#x2F; 1024 &#x2F; 1024);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们创建了一张 2G 大小的 bitmap 我们在 8.0 以下的版本运行是会 OOM 的，而我们在 8.0 以上的版本运行是完全没问题，但 Native 内存多了 2G 的内存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E&#x2F;TAG: AvailMem :1654</span><br><span class="line">E&#x2F;TAG: lowMemory：false</span><br><span class="line">E&#x2F;TAG: NativeHeapAllocatedSize :4</span><br><span class="line"></span><br><span class="line">E&#x2F;TAG: AvailMem :1656</span><br><span class="line">E&#x2F;TAG: lowMemory：false</span><br><span class="line">E&#x2F;TAG: NativeHeapAllocatedSize :2052</span><br></pre></td></tr></table></figure>

<p>通过之前的源码分析可知 bitmap 的内存创建都是通过 <code>tryAllocPixels</code> 方法来申请的</p>
<p>8.0 以上像素内存在 Native 内存中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto wrapper &#x3D; alloc(size, info, rowBytes, ctable);</span><br></pre></td></tr></table></figure>

<p>看一下源码（8.0以上）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类 &#96;BitmapFactory.cpp&#96;.doDecode(JNIEnv* env, std::unique_ptr&lt;SkStreamRewindable&gt; stream,</span><br><span class="line">                        jobject padding, jobject options, jlong inBitmapHandle,</span><br><span class="line">                        jlong colorSpaceHandle)</span><br><span class="line"></span><br><span class="line">static jobject doDecode(JNIEnv* env, std::unique_ptr&lt;SkStreamRewindable&gt; stream,</span><br><span class="line">                        jobject padding, jobject options, jlong inBitmapHandle,</span><br><span class="line">                        jlong colorSpaceHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 原图</span><br><span class="line">    SkBitmap decodingBitmap;</span><br><span class="line">    if (!decodingBitmap.setInfo(bitmapInfo) ||</span><br><span class="line">            !decodingBitmap.tryAllocPixels(decodeAllocator)) &#123; &#x2F;&#x2F; tryAllocPixels 原图加载在了 native 层</span><br><span class="line">        &#x2F;&#x2F; SkAndroidCodec should recommend a valid SkImageInfo, so setInfo()</span><br><span class="line">        &#x2F;&#x2F; should only only fail if the calculated value for rowBytes is too</span><br><span class="line">        &#x2F;&#x2F; large.</span><br><span class="line">        &#x2F;&#x2F; tryAllocPixels() can fail due to OOM on the Java heap, OOM on the</span><br><span class="line">        &#x2F;&#x2F; native heap, or the recycled javaBitmap being too small to reuse.</span><br><span class="line">        return nullptr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Use SkAndroidCodec to perform the decode.</span><br><span class="line">    SkAndroidCodec::AndroidOptions codecOptions;</span><br><span class="line">    codecOptions.fZeroInitialized &#x3D; decodeAllocator &#x3D;&#x3D; &amp;defaultAllocator ?</span><br><span class="line">            SkCodec::kYes_ZeroInitialized : SkCodec::kNo_ZeroInitialized;</span><br><span class="line">    codecOptions.fSampleSize &#x3D; sampleSize;</span><br><span class="line">    SkCodec::Result result &#x3D; codec-&gt;getAndroidPixels(decodeInfo, decodingBitmap.getPixels(),</span><br><span class="line">            decodingBitmap.rowBytes(), &amp;codecOptions);</span><br><span class="line">    switch (result) &#123;</span><br><span class="line">        case SkCodec::kSuccess:</span><br><span class="line">        case SkCodec::kIncompleteInput:</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            return nullObjectReturn(&quot;codec-&gt;getAndroidPixels() failed.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 返回的图片</span><br><span class="line">    SkBitmap outputBitmap;</span><br><span class="line">    if (willScale) &#123; &#x2F;&#x2F; 如果有压缩</span><br><span class="line">        &#x2F;&#x2F; Set the allocator for the outputBitmap.</span><br><span class="line">        SkBitmap::Allocator* outputAllocator;</span><br><span class="line">        if (javaBitmap !&#x3D; nullptr) &#123;</span><br><span class="line">            outputAllocator &#x3D; &amp;recyclingAllocator;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            outputAllocator &#x3D; &amp;defaultAllocator;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkColorType scaledColorType &#x3D; decodingBitmap.colorType();</span><br><span class="line">        &#x2F;&#x2F; FIXME: If the alphaType is kUnpremul and the image has alpha, the</span><br><span class="line">        &#x2F;&#x2F; colors may not be correct, since Skia does not yet support drawing</span><br><span class="line">        &#x2F;&#x2F; to&#x2F;from unpremultiplied bitmaps.</span><br><span class="line">        outputBitmap.setInfo(</span><br><span class="line">                bitmapInfo.makeWH(scaledWidth, scaledHeight).makeColorType(scaledColorType));</span><br><span class="line">        if (!outputBitmap.tryAllocPixels(outputAllocator)) &#123; &#x2F;&#x2F; 输出的图片加载在 navtive 层</span><br><span class="line">            &#x2F;&#x2F; This should only fail on OOM.  The recyclingAllocator should have</span><br><span class="line">            &#x2F;&#x2F; enough memory since we check this before decoding using the</span><br><span class="line">            &#x2F;&#x2F; scaleCheckingAllocator.</span><br><span class="line">            return nullObjectReturn(&quot;allocation failed for scaled bitmap&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SkPaint paint;</span><br><span class="line">        &#x2F;&#x2F; kSrc_Mode instructs us to overwrite the uninitialized pixels in</span><br><span class="line">        &#x2F;&#x2F; outputBitmap.  Otherwise we would blend by default, which is not</span><br><span class="line">        &#x2F;&#x2F; what we want.</span><br><span class="line">        paint.setBlendMode(SkBlendMode::kSrc);</span><br><span class="line">        paint.setFilterQuality(kLow_SkFilterQuality); &#x2F;&#x2F; bilinear filtering</span><br><span class="line"></span><br><span class="line">        SkCanvas canvas(outputBitmap, SkCanvas::ColorBehavior::kLegacy);</span><br><span class="line">        canvas.scale(scaleX, scaleY);</span><br><span class="line">        canvas.drawBitmap(decodingBitmap, 0.0f, 0.0f, &amp;paint);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        outputBitmap.swap(decodingBitmap); &#x2F;&#x2F; 否则返回原图的复制对象，也是 native 层</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Bitmap-内存的回收"><a href="#4-Bitmap-内存的回收" class="headerlink" title="4. Bitmap 内存的回收"></a>4. Bitmap 内存的回收</h1><h2 id="4-1-recycle-方法"><a href="#4-1-recycle-方法" class="headerlink" title="4.1 recycle 方法"></a>4.1 recycle 方法</h2><p>如果是 <code>8.0</code> 我们手动调用 <code>recycle</code> 方法，<code>数据是会立即释放的</code>，因为像素数据本身就是在 Native 层开辟的。但如果是在 <code>8.0 以下</code>，就算我们手动调用 recycle 方法，<code>数据也是不会立即释放的</code>，<br>而是 DeleteWeakGlobalRef <code>交由 Java GC 来回收</code>。建议大家翻译一下 recycle 方法注释。注意：以上的所说的<code>释放数据仅代表释放像素数据</code>，并未释放 Native 层的 Bitmap 对象。</p>
<h2 id="4-2-不手动调用-recycle-方法时Native-层的-Bitmap-是怎么回收"><a href="#4-2-不手动调用-recycle-方法时Native-层的-Bitmap-是怎么回收" class="headerlink" title="4.2 不手动调用 recycle 方法时Native 层的 Bitmap 是怎么回收"></a>4.2 不手动调用 recycle 方法时Native 层的 Bitmap 是怎么回收</h2><ul>
<li>Android M（6.0） 版本及以前的版本, Bitmap 的内存回收主要是通过 BitmapFinalizer 来完成的(类似于 GC 时 Object 的finalize()方法)</li>
<li>Android M（6.0） 以上版本 虽然没有了 BitmapFinalizer 类,但在 new Bitmap 时会注册 native 的 Finalizer 方法</li>
</ul>
<p>总结：其实无论是 Android M 前还是之后，释放 Native 层的 Bitmap 对象的思想都是去监听 Java 层的 Bitmap 是否被释放，一旦当 Java 层的 Bitmap 对象被释放则立即去释放 Native 层的 Bitmap 。只不过 Android M 前是基于 Java 的 GC 机制，而 Android M 后是注册 native 的 Finalizer 方法。</p>
<h1 id="5-Bitmap-的内存复用"><a href="#5-Bitmap-的内存复用" class="headerlink" title="5.Bitmap 的内存复用"></a>5.Bitmap 的内存复用</h1><p>内存复用好处：<code>防止反复的去开辟和释放内存，内存抖动 -&gt; GC -&gt; 卡顿</code></p>
<p>Bitmap 绝对是我们 Android 开发中最容易引起 OOM 的对象之一，因为其占用的像素数据内存比较大，而加载图片又是很常见的操作。如果不断反复的去开辟和销毁 Bitmap 数据内存，势必可能会引起应用的内存抖动，因此 Google 的开发者也为我们想了一些办法，那就是允许 Bitmap 内存复用，具体如下：</p>
<ul>
<li>被复用的 Bitmap <code>必须为 Mutable（通过 BitmapFactory.Options 设置），然后 options.inBitmap = bitmap1，设置 inBitmap复用的Bitmap是谁</code></li>
<li>4.4 之前，将要解码的图像（无论是资源还是流）必须是 jpeg 或 png 格式且和被复用的 Bitmap 大小一样，其中BitmapFactory.Options#inSampleSize 字段必须设置为 1，要求比较严苛</li>
<li>4.4 以后，将要解码的图像的内存需要小于等于要复用的 Bitmap 的内存</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不复用的写法，消耗内存 32 M</span><br><span class="line">logMemory();</span><br><span class="line">Bitmap bitmap1 &#x3D; BitmapFactory.decodeResource(getResources(), R.drawable.test2);</span><br><span class="line">Bitmap bitmap2 &#x3D; BitmapFactory.decodeResource(getResources(), R.drawable.test2);</span><br><span class="line">logMemory();</span><br><span class="line">&#x2F;&#x2F; 复用的写法，消耗内存 16 M</span><br><span class="line">logMemory();</span><br><span class="line">BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">options.inMutable &#x3D; true;</span><br><span class="line">Bitmap bitmap1 &#x3D; BitmapFactory.decodeResource(getResources(), R.drawable.test2, options);</span><br><span class="line">options.inBitmap &#x3D; bitmap1;</span><br><span class="line">Bitmap bitmap2 &#x3D; BitmapFactory.decodeResource(getResources(), R.drawable.test2, options);</span><br><span class="line">logMemory();</span><br></pre></td></tr></table></figure>

<h1 id="6-xh，xxh，xxxh-放哪个文件夹更高效"><a href="#6-xh，xxh，xxxh-放哪个文件夹更高效" class="headerlink" title="6. xh，xxh，xxxh 放哪个文件夹更高效"></a>6. xh，xxh，xxxh 放哪个文件夹更高效</h1><ul>
<li>放当前主流的  xxh , native 源码中只会开辟一次内存</li>
</ul>
<h1 id="7-Bitmap-的内存优化与适配"><a href="#7-Bitmap-的内存优化与适配" class="headerlink" title="7.Bitmap 的内存优化与适配"></a>7.Bitmap 的内存优化与适配</h1><p>做效果的时候，最好按比例去计算</p>
<h1 id="8-线上-OOM-的-dump-收集"><a href="#8-线上-OOM-的-dump-收集" class="headerlink" title="8.线上 OOM 的 dump 收集"></a>8.线上 OOM 的 dump 收集</h1><p>首先 <code>OOM</code> 是可以 <code>try catch</code> 的,但是一般不这么做。<br>可以在 崩溃日志收集那儿 之前进行 dump 内存，怎么 dump 内存 可以参考 leakCanny</p>
]]></content>
      <categories>
        <category>Bitmap</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：03.Mat对象和图像混合</title>
    <url>/50.OpenCV-Mat%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88/</url>
    <content><![CDATA[<h1 id="1-mat-常见用法"><a href="#1-mat-常见用法" class="headerlink" title="1. mat 常见用法"></a>1. mat 常见用法</h1><p>Mat src</p>
<ul>
<li>src.empty() 判断mat是否为空，搭配<code>imread</code>判断文件是否存在</li>
<li>src.data 头指针，通过判断是否为 NULL 也能判断图片是否存在</li>
</ul>
<p>Mat的构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Mat的构造函数</span></span><br><span class="line"><span class="comment">// CV_8UC1 1个颜色的通道  (0-255)</span></span><br><span class="line"><span class="comment">// CV_8UC2 2个颜色的通道  16位 RGB565</span></span><br><span class="line"><span class="comment">// CV_8UC3 3个颜色的通道  24位</span></span><br><span class="line"><span class="comment">// CV_8UC4 4个颜色的通道  32位 ARGB8888</span></span><br><span class="line"><span class="comment">// 匹配上 Java Bitmap 的颜色通道 RGB565 ARGB8888</span></span><br><span class="line"><span class="comment">// Scalar 指定颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数 rows 高，第二个参数 cols 宽</span></span><br><span class="line"><span class="function">Mat <span class="title">mat</span><span class="params">(<span class="number">500</span>,<span class="number">300</span>,CV_8UC1,Scalar(<span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Size 第一个参数是 width , 第二个参数是 height</span></span><br><span class="line"><span class="function">Mat <span class="title">mat1</span><span class="params">(Size(<span class="number">300</span>,<span class="number">500</span>),CV_8UC1,Scalar(<span class="number">255</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三颜色通道</span></span><br><span class="line"><span class="function">Mat <span class="title">mat2</span><span class="params">(Size(<span class="number">300</span>,<span class="number">500</span>),CV_8UC3,Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">255</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>注意：以下几个拷贝的区别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数，但是不会去拷贝内容操作的还是原来的图</span></span><br><span class="line"><span class="comment">// Mat dst(src);</span></span><br><span class="line"><span class="comment">// Mat dst = src;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会拷贝内容</span></span><br><span class="line">Mat dst;</span><br><span class="line"><span class="comment">// src.copyTo(dst);</span></span><br><span class="line">dst = src.clone();</span><br></pre></td></tr></table></figure>

<h1 id="2-图像操作"><a href="#2-图像操作" class="headerlink" title="2. 图像操作"></a>2. 图像操作</h1><p>图像截取(不涉及创建新的内容)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 区域截取(不涉及创建新的内容)</span></span><br><span class="line">Mat srcROT = src(Rect(<span class="number">20</span>,<span class="number">20</span>,<span class="number">400</span>,<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不改变原图</span></span><br><span class="line">Mat dstROI = srcROT.clone();</span><br></pre></td></tr></table></figure>

<p>读取像素</p>
<p><code>mat.at&lt;Vec3b&gt;(i,j)</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 区域截取(不涉及创建新的内容)</span></span><br><span class="line">	Mat srcROT = src(Rect(<span class="number">20</span>,<span class="number">20</span>,<span class="number">400</span>,<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不改变原图</span></span><br><span class="line">	Mat dstROI = srcROT.clone();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> rows = dstROI.rows;</span><br><span class="line">	<span class="keyword">int</span> cols = dstROI.cols;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 获取像素 at Vec3b 3个字节</span></span><br><span class="line">			<span class="keyword">int</span> b = dstROI.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> g = dstROI.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> r = dstROI.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 底片效果</span></span><br><span class="line">			dstROI.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">255</span> - b;</span><br><span class="line">			dstROI.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">255</span> - g;</span><br><span class="line">			dstROI.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">255</span> - r;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src,gray,COLOR_BGR2GRAY); <span class="comment">// 这样转过来是1个通道</span></span><br><span class="line">	<span class="comment">// 获取信息</span></span><br><span class="line">	<span class="keyword">int</span> cols = gray.cols; <span class="comment">// 宽</span></span><br><span class="line">	<span class="keyword">int</span> rows = gray.rows; <span class="comment">// 高</span></span><br><span class="line">	<span class="keyword">int</span> chnnales = gray.channels();</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cols &lt;&lt; <span class="string">","</span> &lt;&lt; rows &lt;&lt; <span class="string">","</span> &lt;&lt; chnnales &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Bitmap 里面转的是 4 通道，一个通道就可以代表灰度</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (chnnales == <span class="number">3</span>)&#123;</span><br><span class="line">				<span class="keyword">int</span> b = src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">				<span class="keyword">int</span> g = src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">				<span class="keyword">int</span> r = src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 底片效果</span></span><br><span class="line">				gray.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = <span class="number">255</span> - b;</span><br><span class="line">				gray.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = <span class="number">255</span> - g;</span><br><span class="line">				gray.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = <span class="number">255</span> - r;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span> (chnnales == <span class="number">1</span>)&#123;</span><br><span class="line">				uchar pixels = gray.at&lt;uchar&gt;(i, j);</span><br><span class="line">				gray.at&lt;uchar&gt;(i, j) = <span class="number">255</span> - pixels;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 手写一个通道的灰度图</span></span><br><span class="line">	<span class="function">Mat <span class="title">gray</span><span class="params">(src.rows, src.cols, CV_8UC1)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> cols = gray.cols; <span class="comment">// 宽</span></span><br><span class="line">	<span class="keyword">int</span> rows = gray.rows; <span class="comment">// 高</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> b = src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> g = src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> r = src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 底片效果</span></span><br><span class="line">			gray.at&lt;uchar&gt;(i, j) = <span class="number">0.11f</span>*r + <span class="number">0.59f</span>*g + <span class="number">0.3f</span>*b;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imwrite(<span class="string">"E:/test_onegray.jpg"</span>,gray);</span><br><span class="line">	imshow(<span class="string">"test"</span>, gray);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-图像混合"><a href="#3-图像混合" class="headerlink" title="3. 图像混合"></a>3. 图像混合</h1><p><code>mat.add(src1,src2,dst)</code>  注意两张图片的大小必须一致（效果很生硬，直接是像素相加）</p>
<p>不一定非得是 alpha + beta = 1; dst(x) = saturate_cast(src(x)<em>alpha + logo(x)</em>beta + gamma)<br><code>addWeighted(src,0.8,logo,0.2,0.0,dst)</code> //注意两张图片的大小必须一致</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/test.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (src.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"src read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Mat logo = imread(<span class="string">"E:/android.png"</span>);</span><br><span class="line">	<span class="keyword">if</span> (logo.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"logo read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="comment">// add 方法：注意两张图片的大小必须一致（效果很生硬，直接是像素相加）</span></span><br><span class="line">	<span class="comment">// add(src,logo,dst);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 不一定非得是 alpha + beta = 1; dst(x) = saturate_cast(src(x)*alpha + logo(x)*beta + gamma)</span></span><br><span class="line">	<span class="comment">// addWeighted 方法：注意两张图片的大小必须一致</span></span><br><span class="line">	<span class="comment">// addWeighted(src,0.8,logo,0.2,0.0,dst);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 非得加图片不一样的怎么办，通过截取的方式进行图片合并</span></span><br><span class="line">	Mat srcROI = src(Rect(<span class="number">0</span>, <span class="number">0</span>, logo.cols, logo.rows));</span><br><span class="line">	<span class="comment">// 并不适合加水印，只适合做图片的混合</span></span><br><span class="line">	addWeighted(srcROI, <span class="number">0.8</span>, logo, <span class="number">1</span>, <span class="number">0.0</span>, srcROI);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"test"</span>, src);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-饱和度、亮度和对比度"><a href="#4-饱和度、亮度和对比度" class="headerlink" title="4.饱和度、亮度和对比度"></a>4.饱和度、亮度和对比度</h1><p>概念</p>
<ul>
<li>饱和度：指的其实是色彩的纯度，纯度越高，表现越鲜明，纯度较低，表现则较黯淡。 红色，淡红，鲜红，红得发紫等等   R -&gt; 1.2R B -&gt; 1.2B G -&gt; 1.2G</li>
<li>亮度：亮暗的程度</li>
<li>对比度: 图像对比度指的是 [1]  一幅图像中明暗区域最亮的白和最暗的黑之间不同亮度层级的测量，即指一幅图像灰度反差的大小</li>
</ul>
<p>修改像素：<code>alpha*R(G B) + beta;</code>   alpha控制饱和度和对比度，beta控制亮度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/test.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (src.empty())&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"src read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 滤镜 UI设计师 再调亮一点 ，饱和一点，对比度再调高一点？ alpha 增大成比例去增 1:500  10:5000  beta增</span></span><br><span class="line">	<span class="comment">// alpha 饱和度 , 对比度</span></span><br><span class="line">	<span class="comment">// beta 亮度</span></span><br><span class="line">	<span class="comment">// F(R) = alpha*R + beta;</span></span><br><span class="line">	<span class="comment">// F(G) = alpha*G + beta;</span></span><br><span class="line">	<span class="comment">// F(B) = alpha*B + beta;</span></span><br><span class="line">	<span class="comment">// 获取信息</span></span><br><span class="line">	<span class="keyword">int</span> cols = src.cols;<span class="comment">// 宽</span></span><br><span class="line">	<span class="keyword">int</span> rows = src.rows;<span class="comment">// 高</span></span><br><span class="line">	<span class="keyword">int</span> chnnales = src.channels();<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> alpha = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">int</span> beta = <span class="number">-50</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> b = src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>];</span><br><span class="line">			<span class="keyword">int</span> g = src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>];</span><br><span class="line">			<span class="keyword">int</span> r = src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">			src.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(alpha*b + beta);</span><br><span class="line">			src.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(alpha*g + beta);</span><br><span class="line">			src.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(alpha*r + beta);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"test"</span>, src);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


















]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：08.边缘类型、自定义线性滤波、阈值</title>
    <url>/56.OpenCV-%E8%BE%B9%E7%BC%98%E7%B1%BB%E5%9E%8B%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2%E3%80%81%E9%98%88%E5%80%BC/</url>
    <content><![CDATA[<h1 id="1-了解下卷积操作"><a href="#1-了解下卷积操作" class="headerlink" title="1. 了解下卷积操作"></a>1. 了解下卷积操作</h1><p>概念：<code>把kernel（卷积核）放到我们图像的矩阵之上，求锚点周围覆盖的像素乘积之和（包括锚点），用来计算锚点的像素值覆盖图片下面的像素值，称之为卷积操作。</code></p>
<p><img src="/images/56.%E5%8D%B7%E7%A7%AF%E6%93%8D%E4%BD%9C.png" alt></p>
<h1 id="2-处理边缘类型"><a href="#2-处理边缘类型" class="headerlink" title="2. 处理边缘类型"></a>2. 处理边缘类型</h1><p><code>copyMakeBorder(src,dst,src.rows/8,src.rows/8,src.cols/8,src.cols/8,BORDER_DEFAULT);</code></p>
<ul>
<li>BORDER_DEFAULT：用周边边缘区域来填充</li>
<li>BORDER_WRAP：用对边来填充</li>
<li>BORDER_REPLICATE: 用周边像素来填充</li>
<li>BORDER_CONSTANT: 用一个指定颜色来填充，默认是黑色。</li>
</ul>
<h1 id="3-自定义线性滤波与图片模糊-算子也叫作-核"><a href="#3-自定义线性滤波与图片模糊-算子也叫作-核" class="headerlink" title="3. 自定义线性滤波与图片模糊(算子也叫作 核)"></a>3. 自定义线性滤波与图片模糊(算子也叫作 核)</h1><p>介绍几种算子</p>
<ul>
<li>Robert 算子：<code>Mat kernelRobert = (Mat_&lt;int&gt;(2, 2) &lt;&lt; 1, 0, 0, -1);</code></li>
<li>Sobel 算子：x方向：<code>(Mat_&lt;int&gt;(3, 3) &lt;&lt; -1, 0, 1, -2,0,2,-1,0,1);</code>，y方向：<code>(Mat_&lt;int&gt;(3, 3) &lt;&lt; -1, -2, -1, 0, 0, 0, 1, 2, 1);</code></li>
<li>拉普拉斯算子：它对图片的要求比较高 <code>Mat kernelLpls= (Mat_&lt;int&gt;(3, 3) &lt;&lt; 0, -1, 0, -1, 4, -1, 0, -1, 0);</code></li>
</ul>
<p><img src="/images/56.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%97%E5%AD%90.png" alt></p>
<p>depth:（opencv中的概念）<br>　　矩阵中元素的一个通道的数据类型，这个值和type是相关的。例如 type为 CV_16SC2，一个2通道的16位的有符号整数。那么，depth则是CV_16S。depth也是一系列的预定义值，<br>将type的预定义值去掉通道信息就是depth值: 0 - 6 , type 的精度的层度<br>　　CV_8U 0  CV_8S 1 CV_16U 2 CV_16S 3 CV_32S 4 CV_32F 5 CV_64F 6</p>
<p>图像深度：像素的 bit 位数</p>
<p><code>自定义模糊：</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义模糊</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">15</span>;</span><br><span class="line">Mat kernel = Mat::ones(<span class="built_in">size</span>,<span class="built_in">size</span>,CV_32F)/(<span class="built_in">size</span>*<span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">Mat dst;</span><br><span class="line">filter2D(src,dst,src.depth(),kernel);</span><br><span class="line">imshow(<span class="string">"dst"</span>,dst);</span><br></pre></td></tr></table></figure>

<h1 id="4-阈值（图像二值化）"><a href="#4-阈值（图像二值化）" class="headerlink" title="4.阈值（图像二值化）"></a>4.阈值（图像二值化）</h1><p><code>threshold(gray,dst,100,255,type);</code></p>
<p><code>当使用了THRESH_OTSU和THRESH_TRIANGLE两个标志时，输入图像必须为单通道。</code></p>
<p>type 有以下值：</p>
<ul>
<li>THRESH_BINARY：当前像素点超过 thresh = 100 ,当前像素取 maxValue = 255 , 否则取最小值 0</li>
<li>THRESH_BINARY_INV：当前像素点超过 thresh = 100 ,当前像素取 0 , 否则取最大值 maxValue = 255</li>
<li>THRESH_TRUNC：当前像素点超过 thresh = 100 ,当前像素取 maxValue = 255 , 否则取原来的值</li>
<li>THRESH_TOZERO：当前像素点超过 thresh = 100 ,当前像素取原来的值，否则取最小值 0</li>
<li>THRESH_TOZERO_INV：当前像素点超过 thresh = 100，当前像素取 0 ，否则取原来的值</li>
<li>THRESH_OTSU：自动阈值：取每个像素点（整个图像）计算一个 thresh 值</li>
<li>THRESH_TRIANGLE：自动阈值：取每个像素点（整个图像）计算一个 thresh 值</li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：11.色彩空间与直方图均衡化</title>
    <url>/59.OpenCV-%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96/</url>
    <content><![CDATA[<h1 id="1-RGB与HSV"><a href="#1-RGB与HSV" class="headerlink" title="1. RGB与HSV"></a>1. RGB与HSV</h1><p>rgb请看下图:</p>
<p><img src="/images/59.rgb.jpg" alt></p>
<p>HSV 分析：  </p>
<ul>
<li>H ： Hue 色相 色调，色度 0~360度  360种</li>
<li>S ：Saturation 饱和度</li>
<li>V ：Value 亮度</li>
</ul>
<p><img src="/images/59.hsv.jpg" alt></p>
<p>作用：证件照背景替换，扣头发等等</p>
<h1 id="2-归一化-normalize"><a href="#2-归一化-normalize" class="headerlink" title="2.归一化 normalize"></a>2.归一化 normalize</h1><p>归一化：就是把需要处理的数据经过处理后，限制在你需要的一定范围内。例如<code>假设我们把训练数据的第一个属性从[-10,+10]缩放到[-1,+1],那么如果测试数据的第一个属性属于区间[-11,+8],我们必须将测试数据转变为[-1.1,+0.8]</code></p>
<h1 id="3-直方图均衡化-equalizeHistogram"><a href="#3-直方图均衡化-equalizeHistogram" class="headerlink" title="3.直方图均衡化 equalizeHistogram"></a>3.直方图均衡化 equalizeHistogram</h1><p><code>单通道的图片</code>，统计其每个像素值的个数。</p>
<p>概念：直方图均衡化是一种简单有效的图像增强技术，通过改变图像的直方图来改变图像中各像素的灰度，主要用于增强动态范围偏小的图像的对比度。<br>把原始图像的直方图变换为均匀分布（均衡）的形式，这样就增加了像素之间灰度值差别的动态范围，从而达到增强图像整体对比度的效果</p>
<p><img src="/images/59.%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 单通道均衡化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/2_04.png"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src,gray,COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Histogram 直方图</span></span><br><span class="line">	Mat dst;</span><br><span class="line">	equalizeHist(gray, dst);</span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 彩色图均衡化</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>,src);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;Mat&gt; channels;</span><br><span class="line">	split(src,channels);</span><br><span class="line"></span><br><span class="line">	Mat blue, green, red;</span><br><span class="line">	blue = channels.at(<span class="number">0</span>);</span><br><span class="line">	green = channels.at(<span class="number">1</span>);</span><br><span class="line">	red = channels.at(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 直方均衡</span></span><br><span class="line">	equalizeHist(blue, blue);</span><br><span class="line">	equalizeHist(green, green);</span><br><span class="line">	equalizeHist(red, red);</span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line">	merge(channels,dst);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-直方图的计算和绘制"><a href="#4-直方图的计算和绘制" class="headerlink" title="4.直方图的计算和绘制"></a>4.直方图的计算和绘制</h1><p>api</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// NORM_MINMAX中alpha、beta都起作用，同时需要注意的是alpha和beta的取值顺序与归一化结果无关。即alpha=255,beta=0和alpha=0,beta=255最后的归一化结果是相同的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @param alpha 在范围的情况下，标准化到或较低范围边界的范数值规范化。</span></span><br><span class="line"><span class="comment">// @param beta 范围归一化时的上限范围边界;它不用于规范规范化。</span></span><br><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">normalize</span><span class="params">( InputArray src, InputOutputArray dst, <span class="keyword">double</span> alpha = <span class="number">1</span>, <span class="keyword">double</span> beta = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> norm_type = NORM_L2, <span class="keyword">int</span> dtype = <span class="number">-1</span>, InputArray mask = noArray())</span></span>;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取直方图，B G R 每个都单独分离出来（自己写个代码去分离）</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Mat&gt; bgr_s;</span><br><span class="line">	split(src,bgr_s);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// b 通道，但为什么不是 蓝色，而是一个灰度图 ?   </span></span><br><span class="line">	<span class="comment">// imshow("bgr_s", bgr_s[0]);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算获得直方图的数据</span></span><br><span class="line">	<span class="comment">// images 输入的图像</span></span><br><span class="line">	<span class="comment">// nimages 输入图像的个数 </span></span><br><span class="line">	<span class="comment">// channels 第几通道  下标为 0</span></span><br><span class="line">	<span class="comment">// mask 掩模</span></span><br><span class="line">	<span class="comment">// dims 需要统计的通道个数</span></span><br><span class="line">	<span class="comment">// histSize 等级的个数  0-255，每个等级占的范围就是 256/256 = 1</span></span><br><span class="line">	<span class="comment">// ranges 数据的范围  0-255</span></span><br><span class="line">	<span class="comment">// uniform true 是否对得到的图片进行归一化处理</span></span><br><span class="line">	<span class="comment">// accumulate 在多个图像时，是否累计计算像素值的个数 false</span></span><br><span class="line">	<span class="comment">/*calcHist(const Mat* images, int nimages,</span></span><br><span class="line"><span class="comment">	const int* channels, InputArray mask,</span></span><br><span class="line"><span class="comment">	OutputArray hist, int dims, const int* histSize,</span></span><br><span class="line"><span class="comment">	const float** ranges, bool uniform = true, bool accumulate = false);*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> histSize = <span class="number">256</span>;</span><br><span class="line">	<span class="keyword">float</span> range[] = &#123; <span class="number">0</span>, <span class="number">256</span> &#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> * ranges = &#123; range &#125;;</span><br><span class="line">	Mat hist_b, hist_g, hist_r;</span><br><span class="line"></span><br><span class="line">	calcHist(&amp;bgr_s[<span class="number">0</span>], <span class="number">1</span>, <span class="number">0</span>, Mat(), hist_b, <span class="number">1</span>, &amp;histSize, &amp;ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">	calcHist(&amp;bgr_s[<span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>, Mat(), hist_g, <span class="number">1</span>, &amp;histSize, &amp;ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">	calcHist(&amp;bgr_s[<span class="number">2</span>], <span class="number">1</span>, <span class="number">0</span>, Mat(), hist_r, <span class="number">1</span>, &amp;histSize, &amp;ranges, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mat 存的是像素值，不一定，存任意值</span></span><br><span class="line">	<span class="comment">// 画出来，hist_b 存的是什么？存的是各个灰度值的个数，hist_b 最小值 0 ，最大值 图片的宽*高</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 归一化</span></span><br><span class="line">	<span class="keyword">int</span> hist_h = <span class="number">400</span>; <span class="comment">// 直方图的图像的高</span></span><br><span class="line">	<span class="keyword">int</span> hist_w = <span class="number">512</span>; <span class="comment">// 256 * 2 直方图的图像的宽（2 代表画笔的大小）</span></span><br><span class="line">	<span class="keyword">int</span> bin_w = hist_w / histSize; <span class="comment">// 画笔大小</span></span><br><span class="line">	<span class="comment">// alpha 最小值 </span></span><br><span class="line">	<span class="comment">// beta 最大值</span></span><br><span class="line">	<span class="comment">/*normalize(InputArray src, InputOutputArray dst, double alpha = 1, double beta = 0,</span></span><br><span class="line"><span class="comment">	int norm_type = NORM_L2, int dtype = -1, InputArray mask = noArray());*/</span></span><br><span class="line">	<span class="comment">// NORM_MINMAX 缩放到一定区域</span></span><br><span class="line">	normalize(hist_b, hist_b, <span class="number">0</span>, hist_h, NORM_MINMAX, <span class="number">-1</span>, Mat());</span><br><span class="line">	normalize(hist_g, hist_g, <span class="number">0</span>, hist_h, NORM_MINMAX, <span class="number">-1</span>, Mat());</span><br><span class="line">	normalize(hist_r, hist_r, <span class="number">0</span>, hist_h, NORM_MINMAX, <span class="number">-1</span>, Mat());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画到一张图中</span></span><br><span class="line">	<span class="function">Mat <span class="title">histImage</span><span class="params">(hist_h, hist_w, CV_8SC4, Scalar())</span></span>; </span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; histSize; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 开始点，结束点 255</span></span><br><span class="line">		<span class="built_in">line</span>(</span><br><span class="line">			histImage,</span><br><span class="line">			Point((i - <span class="number">1</span>)*bin_w, hist_h - hist_b.at&lt;<span class="keyword">float</span>&gt;(i - <span class="number">1</span>)),<span class="comment">// 图片的像素点 左上角才是 0,0</span></span><br><span class="line">			Point(i*bin_w, hist_h - hist_b.at&lt;<span class="keyword">float</span>&gt;(i)),</span><br><span class="line">			Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), bin_w, LINE_AA);</span><br><span class="line">		<span class="built_in">line</span>(</span><br><span class="line">			histImage,</span><br><span class="line">			Point((i - <span class="number">1</span>)*bin_w, hist_h - hist_g.at&lt;<span class="keyword">float</span>&gt;(i - <span class="number">1</span>)),</span><br><span class="line">			Point(i*bin_w, hist_h - hist_g.at&lt;<span class="keyword">float</span>&gt;(i)),</span><br><span class="line">			Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), bin_w, LINE_AA);</span><br><span class="line">		<span class="built_in">line</span>(</span><br><span class="line">			histImage,</span><br><span class="line">			Point((i - <span class="number">1</span>)*bin_w, hist_h - hist_r.at&lt;<span class="keyword">float</span>&gt;(i - <span class="number">1</span>)),</span><br><span class="line">			Point(i*bin_w, hist_h - hist_r.at&lt;<span class="keyword">float</span>&gt;(i)),</span><br><span class="line">			Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), bin_w, LINE_AA);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"histImage"</span>, histImage);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：06.中值滤波、腐蚀、膨胀、实现图片的美容效果-双边滤波</title>
    <url>/54.OpenCV-%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2%E3%80%81%E8%85%90%E8%9A%80%E3%80%81%E8%86%A8%E8%83%80%E3%80%81%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E7%9A%84%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C-%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h1 id="1-中值滤波与双边滤波"><a href="#1-中值滤波与双边滤波" class="headerlink" title="1. 中值滤波与双边滤波"></a>1. 中值滤波与双边滤波</h1><ul>
<li><code>medianBlur</code> 中值 对所有考虑点进行排序，取中间的那个值（替换到矩阵的中心点）   1,2,”3”,4,5  去掉噪音（很多 黑白点的情况）</li>
<li><code>bilateralFilter</code> 双边  可以用作美容 ，基于高斯，高斯保留的轮廓并不强，双边保留的轮廓信息会增强，基于高斯再增加像素差</li>
</ul>
<p>使用到的 api</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @params d : 滤波过程中使用的每个像素邻域的直径。如果它是非正的，它是由sigmaSpace计算的。</span></span><br><span class="line"><span class="comment">// @param sigmaColor ： 滤色空间中的。参数的值越大意味着，像素附近的更远的颜色(参见sigmaSpace)将被混合在一起，得到结果 在更大的区域半相等的颜色。</span></span><br><span class="line"><span class="comment">// @param sigmaSpace: 在坐标空间中过滤。参数的值越大意味着距离较远的像素会相互影响，只要它们的颜色足够接近(参见sigmaColor))。当d &gt; 0时，它指定邻域大小，而与sigmaSpace无关。否则,d是与sigmaSpace成正比。</span></span><br><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">bilateralFilter</span><span class="params">( InputArray src, OutputArray dst, <span class="keyword">int</span> d,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">double</span> sigmaColor, <span class="keyword">double</span> sigmaSpace,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">int</span> borderType = BORDER_DEFAULT )</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"src read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line">	 blur(src, dst, Size(<span class="number">15</span>, <span class="number">15</span>));</span><br><span class="line"></span><br><span class="line">	 中值滤波 对所有考虑点进行排序，取中间的那个值   <span class="number">1</span>,<span class="number">2</span>,“<span class="number">3</span>”,<span class="number">4</span>,<span class="number">5</span>  去掉噪音</span><br><span class="line">	 medianBlur(src, dst,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	 双边滤波 可以用作美容 ，基于高斯，高斯保留的轮廓并不强，双边保留的轮廓信息会增强，基于高斯再增加像素差</span><br><span class="line">	bilateralFilter(src,dst,<span class="number">15</span>,<span class="number">100</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">	 掩膜操作</span><br><span class="line">	Mat <span class="keyword">final</span>;</span><br><span class="line">	Mat kernal = (Mat_&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">5</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">	filter2D(dst,<span class="keyword">final</span>,dst.depth(),kernal);</span><br><span class="line">	imshow(<span class="string">"final"</span>,<span class="keyword">final</span>);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-腐蚀与膨胀"><a href="#2-腐蚀与膨胀" class="headerlink" title="2. 腐蚀与膨胀"></a>2. 腐蚀与膨胀</h1><p>数学形态学，与卷积操作类似，用的矩形 （E 求和），用的是任意形状，矩形，十字形，椭圆形，等等 最大值，最小值，中值，最大值-最小值</p>
<p>膨胀定义：<br>　　膨胀—图像膨胀的过程类似于一个卷积的过程，假设有图像矩阵A以及结构元素B（注意，B的形状、尺寸没有限制），B在A矩阵上依次移动，每个位置上B所覆盖元素的<code>最大值</code>替换B的中心位置值（即锚点处），即为膨胀的过程。</p>
<p>腐蚀定义：<br>    腐蚀—图像膨胀的过程类似于一个卷积的过程，假设有图像矩阵A以及结构元素B（注意，B的形状、尺寸没有限制），B在A矩阵上依次移动，每个位置上B所覆盖元素的<code>最小值</code>替换B的中心位置值（即锚点处），即为腐蚀的过程。</p>
<ul>
<li>erode 腐蚀 ，最小值（去白点）</li>
<li>dilate 膨胀 ， 最大值(去黑点)</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> element_size = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> max_size = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 膨胀与腐蚀，处理黑白图片</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackbarCallback</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">void</span> *userdata)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = element_size * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 创建一个 kernel</span></span><br><span class="line">	Mat kernel = getStructuringElement(MORPH_RECT, Size(<span class="built_in">size</span>, <span class="built_in">size</span>));</span><br><span class="line">	Mat dst;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//膨胀 ， 最大值(去黑点)</span></span><br><span class="line">	dilate(src, dst, kernel);</span><br><span class="line">	<span class="comment">// 腐蚀 ，最小值 （去白点）</span></span><br><span class="line">	<span class="comment">// erode(src,dst,kernel);</span></span><br><span class="line">	imshow(<span class="string">"output image"</span>, dst);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"src read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 创建一个 window</span></span><br><span class="line">	namedWindow(<span class="string">"output image"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 动态控制</span></span><br><span class="line">	createTrackbar(<span class="string">"Trackbar"</span>,<span class="string">"output image"</span>,&amp;element_size,max_size,trackbarCallback);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：10.霍夫检测(直线、圆检测)与重映射(镜像翻转)</title>
    <url>/58.OpenCV-%E9%9C%8D%E5%A4%AB%E6%A3%80%E6%B5%8B(%E7%9B%B4%E7%BA%BF%E3%80%81%E5%9C%86%E6%A3%80%E6%B5%8B)%E4%B8%8E%E9%87%8D%E6%98%A0%E5%B0%84(%E9%95%9C%E5%83%8F%E7%BF%BB%E8%BD%AC)/</url>
    <content><![CDATA[<h1 id="1-霍夫直线检测"><a href="#1-霍夫直线检测" class="headerlink" title="1. 霍夫直线检测"></a>1. 霍夫直线检测</h1><p>作用：检测图片当中点集合中的直线。（比如提取图片中的直线：车道线）</p>
<p>先来看下原理图：<br><img src="/images/58.%E9%9C%8D%E5%A4%AB%E7%9B%B4%E7%BA%BF%E6%A3%80%E6%B5%8B.png" alt></p>
<p>再来看下<code>opencv</code>中的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/houghLine.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. Canny 边缘检测</span></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src,gray,COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">	Mat cannyImage;</span><br><span class="line">	Canny(gray,cannyImage,<span class="number">200</span>,<span class="number">250</span>,<span class="number">3</span>);</span><br><span class="line">	imshow(<span class="string">"cannyImage"</span>, cannyImage);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. HoughLineP</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Vec4f&gt; plines;</span><br><span class="line">	<span class="comment">// lines 信息里面包含多条直线，每条直线两个点</span></span><br><span class="line">	<span class="comment">// rho 像素间隙扫描</span></span><br><span class="line">	<span class="comment">// theta 每次增加的角度 CV_PI / 180 = 1度</span></span><br><span class="line">	<span class="comment">// threshold 低阈值</span></span><br><span class="line">	<span class="comment">// minLineLength 线的最小长度</span></span><br><span class="line">	<span class="comment">// maxLineGap 线点之间的间隙</span></span><br><span class="line">	HoughLinesP(cannyImage, plines, <span class="number">1</span>, CV_PI / <span class="number">360</span>, <span class="number">170</span>, <span class="number">30</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plines.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Vec4f pline = plines[i];</span><br><span class="line"></span><br><span class="line">		<span class="built_in">line</span>(src, Point(pline[<span class="number">0</span>], pline[<span class="number">1</span>]), Point(pline[<span class="number">1</span>], pline[<span class="number">2</span>]), Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"result"</span>,src);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//HoughLines</span></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-霍夫圆检测"><a href="#2-霍夫圆检测" class="headerlink" title="2. 霍夫圆检测"></a>2. 霍夫圆检测</h1><p>先来看下原理图：<br><img src="/images/58.%E9%9C%8D%E5%A4%AB%E5%9C%86%E6%A3%80%E6%B5%8B.png" alt></p>
<p>解释：  </p>
<ul>
<li>梯度的求取：类似于 x、y 轴的垂直，梯度求取就是<code>取各个点各个方向直线的垂直线</code> ，投票将 相交的次数大于多少的才算作圆</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/HoughCircle.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 转灰度图</span></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src, gray, COLOR_BGR2GRAY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. HoughLineP</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Vec3f&gt; circles;</span><br><span class="line">	<span class="comment">// minDist:10 两个圆之间的最小距离 越大越能减少同心圆的现象</span></span><br><span class="line">	<span class="comment">// param1:100 投票累加结果超过多少才能算圆</span></span><br><span class="line">	<span class="comment">// params2:30 低阈值</span></span><br><span class="line">	<span class="comment">// minRadius: 5 最小的半径</span></span><br><span class="line">	<span class="comment">// maxRadius: 50 最大的半径</span></span><br><span class="line">	HoughCircles(gray, circles, HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">40</span>, <span class="number">100</span>, <span class="number">30</span>,<span class="number">5</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; circles.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Vec3f cc = circles[i];</span><br><span class="line">		<span class="built_in">circle</span>(src, Point(cc[<span class="number">0</span>], cc[<span class="number">1</span>]), cc[<span class="number">2</span>], Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>),<span class="number">1</span>,LINE_AA);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"result"</span>, src);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//HoughLines</span></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-重映射"><a href="#3-重映射" class="headerlink" title="3.重映射"></a>3.重映射</h1><p>remap 根据原图按照新定的满足一定规律重新赋值的操作。<br>g(x,y) = f(h(x,y))  g 新的图片 = h 原图 ， f 函数，</p>
<p>可用于<code>镜像翻转</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="function">Mat <span class="title">map_x</span><span class="params">(src.<span class="built_in">size</span>(),CV_32F)</span></span>;</span><br><span class="line">	<span class="function">Mat <span class="title">map_y</span><span class="params">(src.<span class="built_in">size</span>(), CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// x 轴的翻转</span></span><br><span class="line">			<span class="comment">//map_x.at&lt;float&gt;(row, col) = src.cols - col - 1;</span></span><br><span class="line">			<span class="comment">//map_y.at&lt;float&gt;(row, col) = row;</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">// y 轴的翻转</span></span><br><span class="line">			map_x.at&lt;<span class="keyword">float</span>&gt;(row, col) = col;</span><br><span class="line">			map_y.at&lt;<span class="keyword">float</span>&gt;(row, col) = src.rows - row;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line">	remap(src, dst, map_x, map_y, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//HoughLines</span></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：09.图片边缘检测</title>
    <url>/57.OpenCV-%E5%9B%BE%E7%89%87%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="1-Sobel-算子-检测图片边缘"><a href="#1-Sobel-算子-检测图片边缘" class="headerlink" title="1. Sobel 算子 检测图片边缘"></a>1. Sobel 算子 检测图片边缘</h1><p>先来看下微积分求导:</p>
<p><img src="/images/57.%E5%BE%AE%E7%A7%AF%E5%88%86%E6%B1%82%E5%AF%BC.png" alt></p>
<p>上代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/card1.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Mat kernel = (Mat_&lt;int&gt;(3, 3) &lt;&lt; -1, 0, 1, -2, 0, 2, -1, 0, 1); </span></span><br><span class="line">	<span class="comment">//Mat dst;</span></span><br><span class="line">	<span class="comment">//filter2D(src,dst,src.depth(),kernel);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 降噪高斯</span></span><br><span class="line">	Mat gaussian;</span><br><span class="line">	GaussianBlur(src,gaussian,Size(<span class="number">3</span>,<span class="number">3</span>),<span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 2. 转灰度</span></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(gaussian, gray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="comment">// 3. 求梯度</span></span><br><span class="line">	<span class="comment">// 参数 ：delta -&gt; 在计算结果的基础上再加上 delta</span></span><br><span class="line">	<span class="comment">// ddepth : -1代表与 gray.depth()相同的值，但是应该传比 gray 精度更高的值(1 / 3=0,1f/3 = 0.3333)</span></span><br><span class="line">	<span class="comment">// x y ，求梯度一般不用索贝尔，Scharr 增强</span></span><br><span class="line">	Mat sobel_x, sobel_y;</span><br><span class="line">	Sobel(gray, sobel_x, CV_32F, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">	Sobel(gray, sobel_y, CV_32F, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 求绝对值 (因为有的像素值求出来为负数)</span></span><br><span class="line">	convertScaleAbs(sobel_x, sobel_x);</span><br><span class="line">	convertScaleAbs(sobel_y, sobel_y);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 合并两个方向的图片</span></span><br><span class="line">	Mat sobel;</span><br><span class="line">	addWeighted(sobel_x,<span class="number">0.5</span>,sobel_y,<span class="number">0.5</span>,<span class="number">0</span>,sobel);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"sobel_x"</span>, sobel_x);</span><br><span class="line">	imshow(<span class="string">"sobel_y"</span>, sobel_y);</span><br><span class="line">	imshow(<span class="string">"sobel"</span>, sobel);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sobel x y方向两张图的合并</p>
<p><img src="/images/57.sobel%20%E5%90%88%E5%B9%B6.png" alt></p>
<h1 id="2-Scharr-增强求边缘"><a href="#2-Scharr-增强求边缘" class="headerlink" title="2. Scharr 增强求边缘"></a>2. Scharr 增强求边缘</h1><p>除了求梯度那儿跟 <code>sobel</code> 不一样以外其它代码都类似。下面着重上<code>求梯度</code>的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3. 求梯度</span></span><br><span class="line"><span class="comment">// 参数 ：delta -&gt; 在计算结果的基础上再加上 delta</span></span><br><span class="line"><span class="comment">// ddepth : -1代表与 gray.depth()相同的值，但是应该传比 gray 精度更高的值(1 / 3=0,1f/3 = 0.3333)</span></span><br><span class="line"><span class="comment">// x y ，求梯度一般不用索贝尔，Scharr 增强</span></span><br><span class="line">Mat scharr_x, scharr_y;</span><br><span class="line">Scharr(gray, scharr_x, CV_32F, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">Scharr(gray, scharr_y, CV_32F, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h1 id="3-Laplance-图片边缘检测"><a href="#3-Laplance-图片边缘检测" class="headerlink" title="3. Laplance 图片边缘检测"></a>3. Laplance 图片边缘检测</h1><p>这用到了二阶导数，所以只处理一次图片，不需要像 <code>sobel</code> 那样处理两次图片再合并</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/card1.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Mat kernel = (Mat_&lt;int&gt;(3, 3) &lt;&lt; -1, 0, 1, -2, 0, 2, -1, 0, 1);</span></span><br><span class="line">	<span class="comment">//Mat dst;</span></span><br><span class="line">	<span class="comment">//filter2D(src,dst,src.depth(),kernel);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1. 降噪高斯</span></span><br><span class="line">	Mat gaussian;</span><br><span class="line">	GaussianBlur(src, gaussian, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 2. 转灰度</span></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(gaussian, gray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="comment">// 3. laplance</span></span><br><span class="line">	Mat lpls;</span><br><span class="line">	Laplacian(gray, lpls, CV_16S, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4.求绝对值</span></span><br><span class="line">	convertScaleAbs(lpls, lpls);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 二值化</span></span><br><span class="line">	Mat thresh;</span><br><span class="line">	threshold(lpls,thresh,<span class="number">0</span>,<span class="number">255</span>,THRESH_BINARY|THRESH_OTSU);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"lpls"</span>, lpls);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Canny-图片边缘检测"><a href="#4-Canny-图片边缘检测" class="headerlink" title="4.Canny 图片边缘检测"></a>4.Canny 图片边缘检测</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/card1.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Canny 的原理</span></span><br><span class="line">	<span class="comment">// 1. 高斯去噪声 </span></span><br><span class="line">	<span class="comment">// 2. 灰度转换</span></span><br><span class="line">	<span class="comment">// 3. 计算梯度 Sobel/Scharr</span></span><br><span class="line">	<span class="comment">// 4. 非最大信号抑制</span></span><br><span class="line">	<span class="comment">// 5. 高低阈值输出二值图像（0,255） threshold1 低阈值 threshold2 高阈值</span></span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 参数：threshold1 - threshold2 ，在 threshold1 - threshold2 之间，取最大值 255，否则取 0  尽量 1 ：2  1 ：3   30-60  30-90  50-100 50-150</span></span><br><span class="line">	<span class="comment">// 参数：L2gradient  falsee类似于:绝对值相加，true类似于:开根号(sobel_x^2 + soble_y^2)</span></span><br><span class="line">	Canny(src,dst,<span class="number">30</span>,<span class="number">90</span>,<span class="number">3</span>,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：14.说说图片效果</title>
    <url>/62.OpenCV-%E8%AF%B4%E8%AF%B4%E5%9B%BE%E7%89%87%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv62" target="_blank" rel="noopener">NDKPractice项目的opencv62</a></strong></p>
<h1 id="1-opencv-的用处"><a href="#1-opencv-的用处" class="headerlink" title="1. opencv 的用处"></a>1. opencv 的用处</h1><ul>
<li>提高图片的视觉，图片变换效果</li>
<li>提取图像的特征，用来分析</li>
<li>图像识别，直播，人脸，指纹，二维码，汽车牌照识别</li>
</ul>
<p><img src="/images/62.%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86.png" alt></p>
<h1 id="2-Bitmap-的解封装与编解码"><a href="#2-Bitmap-的解封装与编解码" class="headerlink" title="2. Bitmap 的解封装与编解码"></a>2. Bitmap 的解封装与编解码</h1><p>你给一个错误地址，或者给一个文本地址，Glide 是如何判断图片格式，是否错误之类的呢？</p>
<p><code>根据流读出来的头几个字节判断格式</code>。</p>
<p>先说下 <code>PNG、JPEG、WEBP 区别</code> :<br><code>PNG (无损压缩)，JPEG（有损压缩），WEBP  区别？ 有损压缩和无损压缩</code></p>
<p>面试中常问问题：<code>WEBP</code> 有什么好处？ : </p>
<ul>
<li><code>存储空间更小还原度更高</code>，</li>
<li>版本区别：支持 4.0 开始支持，4.2 正式没有问题（alpha颜色通道）</li>
</ul>
<p><img src="/images/62.%E5%9B%BE%E7%89%87%20Bitmap%20%E7%9A%84%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%92%8C%E7%BC%96%E8%A7%A3%E7%A0%81.png" alt></p>
<h1 id="3-逆世界效果"><a href="#3-逆世界效果" class="headerlink" title="3. 逆世界效果"></a>3. 逆世界效果</h1><p>用图片说下原理：</p>
<p><img src="/images/62.%E9%80%86%E4%B8%96%E7%95%8C.png" alt></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv62_NDKBitmapUtils_againstWorld(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(src.<span class="built_in">size</span>(), src.type())</span></span>;</span><br><span class="line">    <span class="comment">// 获取图片宽高</span></span><br><span class="line">    <span class="keyword">int</span> src_w = src.cols; <span class="comment">// 图片的宽</span></span><br><span class="line">    <span class="keyword">int</span> src_h = src.rows; <span class="comment">// 图片的高</span></span><br><span class="line">    <span class="keyword">int</span> mid_h = src_h &gt;&gt; <span class="number">1</span>; <span class="comment">// 逆向世界的一般一般</span></span><br><span class="line">    <span class="keyword">int</span> a_h = src_h &gt;&gt; <span class="number">2</span>; <span class="comment">// 原图像的4/1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输出图像的下半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; mid_h; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src_w; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src.type() == CV_8UC4)</span><br><span class="line">                res.at&lt;Vec4b&gt;(row + mid_h, col) = src.at&lt;Vec4b&gt;(row + a_h, col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC2)</span><br><span class="line">                res.at&lt;Vec3b&gt;(row + mid_h, col) = src.at&lt;Vec3b&gt;(row + a_h, col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC1)</span><br><span class="line">                res.at&lt;uchar&gt;(row + mid_h, col) = src.at&lt;uchar&gt;(row + a_h, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输出图像的上半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; mid_h; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src_w; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src.type() == CV_8UC4)</span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col) = src.at&lt;Vec4b&gt;(src_h - row - a_h, col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC2)</span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col) = src.at&lt;Vec3b&gt;(src_h - row - a_h, col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC1)</span><br><span class="line">                res.at&lt;uchar&gt;(row, col) = src.at&lt;uchar&gt;(src_h - row - a_h, col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv_helper::mat2bitmap(env, res, bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-浮雕效果"><a href="#4-浮雕效果" class="headerlink" title="4.浮雕效果"></a>4.浮雕效果</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv62_NDKBitmapUtils_anaglyph(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    <span class="comment">// 有立体感，突出了轮廓信息，opencv  卷积</span></span><br><span class="line">    <span class="comment">// [1,0]</span></span><br><span class="line">    <span class="comment">// [0,1]</span></span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(src.<span class="built_in">size</span>(), src.type())</span></span>;</span><br><span class="line">    src.copyTo(res);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图片宽高</span></span><br><span class="line">    <span class="keyword">int</span> src_w = src.cols; <span class="comment">// 图片的宽</span></span><br><span class="line">    <span class="keyword">int</span> src_h = src.rows; <span class="comment">// 图片的高</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src_h - <span class="number">1</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src_w - <span class="number">1</span>; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src.type() == CV_8UC4) &#123;</span><br><span class="line">                Vec4b pixels_p = src.at&lt;Vec4b&gt;(row, col);</span><br><span class="line">                Vec4b pixels_n = src.at&lt;Vec4b&gt;(row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// bgra</span></span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col)[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(pixels_p[<span class="number">0</span>] - pixels_n[<span class="number">0</span>] + <span class="number">128</span>);</span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col)[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(pixels_p[<span class="number">1</span>] - pixels_n[<span class="number">1</span>] + <span class="number">128</span>);</span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col)[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(pixels_p[<span class="number">2</span>] - pixels_n[<span class="number">2</span>] + <span class="number">128</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC2) &#123;</span><br><span class="line">                Vec3b pixels_p = src.at&lt;Vec3b&gt;(row, col);</span><br><span class="line">                Vec3b pixels_n = src.at&lt;Vec3b&gt;(row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// bgr</span></span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(pixels_p[<span class="number">0</span>] - pixels_n[<span class="number">0</span>] + <span class="number">128</span>);</span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(pixels_p[<span class="number">1</span>] - pixels_n[<span class="number">1</span>] + <span class="number">128</span>);</span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(pixels_p[<span class="number">2</span>] - pixels_n[<span class="number">2</span>] + <span class="number">128</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC1) &#123;</span><br><span class="line">                uchar pixels_p = src.at&lt;uchar&gt;(row, col);</span><br><span class="line">                uchar pixels_n = src.at&lt;uchar&gt;(row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">                res.at&lt;uchar&gt;(row, col) = saturate_cast&lt;uchar&gt;(pixels_p - pixels_n + <span class="number">128</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jobject newBitmap = cv_helper::createBitmap(env, res.cols, res.rows, res.type());</span><br><span class="line"></span><br><span class="line">    cv_helper::mat2bitmap(env, res, newBitmap);</span><br><span class="line">    <span class="keyword">return</span> newBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-马赛克"><a href="#5-马赛克" class="headerlink" title="5.马赛克"></a>5.马赛克</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv62_NDKBitmapUtils_mosaic(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取图片宽高</span></span><br><span class="line">    <span class="keyword">int</span> src_w = src.cols; <span class="comment">// 图片的宽</span></span><br><span class="line">    <span class="keyword">int</span> src_h = src.rows; <span class="comment">// 图片的高</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略人脸识别</span></span><br><span class="line">    <span class="keyword">int</span> row_start = src_h &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> row_end = src_h * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> col_start = src_w &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> col_end = src_w * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size_h = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">int</span> size_w = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = row_start; row &lt; row_end; row += size_h) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = col_start; col &lt; col_end; col += size_w) &#123;</span><br><span class="line">            <span class="keyword">int</span> pixel = src.at&lt;<span class="keyword">int</span>&gt;(row, col);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m_row = <span class="number">0</span>; m_row &lt; size_w; m_row++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> m_col = <span class="number">0</span>; m_col &lt; size_h; m_col++) &#123;</span><br><span class="line">                    src.at&lt;<span class="keyword">int</span>&gt;(row + m_row, col + m_col) = pixel;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当还没到结束的区域时，剩下的区域也需要修改像素</span></span><br><span class="line">            <span class="keyword">if</span> (col &lt; col_end &amp;&amp; col + size_w &gt; col_end) &#123;</span><br><span class="line">                size_w = col_end - col - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size_w = <span class="number">50</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当还没到结束的区域时，剩下的区域也需要修改像素</span></span><br><span class="line">        <span class="keyword">if</span> (row &lt; row_end &amp;&amp; row + size_h &gt; row_end) &#123;</span><br><span class="line">            size_h = row_end - row - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            size_h = <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv_helper::mat2bitmap(env, src, bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-毛玻璃效果"><a href="#6-毛玻璃效果" class="headerlink" title="6.毛玻璃效果"></a>6.毛玻璃效果</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv62_NDKBitmapUtils_groundGlass(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line">    <span class="comment">// 不同于高斯模糊，毛玻璃（对某个区域取随机像素）</span></span><br><span class="line">    <span class="comment">// 获取图片宽高</span></span><br><span class="line">    <span class="keyword">int</span> src_w = src.cols; <span class="comment">// 图片的宽</span></span><br><span class="line">    <span class="keyword">int</span> src_h = src.rows; <span class="comment">// 图片的高</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">RNG <span class="title">rng</span><span class="params">(time(<span class="literal">NULL</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src_h; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src_w; ++col) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">random</span> = rng.uniform(<span class="number">0</span>, <span class="built_in">size</span>+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(row+<span class="built_in">random</span> &gt;= src_h)&#123;</span><br><span class="line">                <span class="keyword">if</span>(col + <span class="built_in">random</span> &gt;= src_w)&#123;</span><br><span class="line">                    src.at&lt;<span class="keyword">int</span>&gt;(row, col) = src.at&lt;<span class="keyword">int</span>&gt;(row - <span class="built_in">random</span>, col - <span class="built_in">random</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    src.at&lt;<span class="keyword">int</span>&gt;(row, col) = src.at&lt;<span class="keyword">int</span>&gt;(row - <span class="built_in">random</span>, col + <span class="built_in">random</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(col + <span class="built_in">random</span> &gt;= src_w)&#123;</span><br><span class="line">                    src.at&lt;<span class="keyword">int</span>&gt;(row, col) = src.at&lt;<span class="keyword">int</span>&gt;(row + <span class="built_in">random</span>, col - <span class="built_in">random</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    src.at&lt;<span class="keyword">int</span>&gt;(row, col) = src.at&lt;<span class="keyword">int</span>&gt;(row + <span class="built_in">random</span>, col + <span class="built_in">random</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cv_helper::mat2bitmap(env, src, bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-油画特效效果"><a href="#7-油画特效效果" class="headerlink" title="7. 油画特效效果"></a>7. 油画特效效果</h1><p>注意：<code>下面的size 越大效果越明显，但是计算速度越慢</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv62_NDKBitmapUtils_oilPainting(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    <span class="comment">// 油画基于直方统计</span></span><br><span class="line">    <span class="comment">// 1. 每个点需要分成 n*n 小块</span></span><br><span class="line">    <span class="comment">// 2. 统计灰度等级</span></span><br><span class="line">    <span class="comment">// 3. 选择灰度等级中最多的值</span></span><br><span class="line">    <span class="comment">// 4. 找到所有的像素取平均值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    1、获取图像的灰度(gray)图片</span></span><br><span class="line"><span class="comment">//    2、设计一个小方框（4x4 or 8x8 or 10x10等），统计每个小方框的像素值</span></span><br><span class="line"><span class="comment">//    3、将0-255的灰度值划分成几个等级，并把第二步处理的结果映射到所设置的各个等级中，并计数</span></span><br><span class="line"><span class="comment">//    4、找到每个方框中灰度等级最多的所有的像素，并且求取这些像素的均值</span></span><br><span class="line"><span class="comment">//    5、用统计出来的平均值来替代原来的像素值</span></span><br><span class="line"></span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line">    Mat gray;</span><br><span class="line">    cvtColor(src,gray,COLOR_BGRA2GRAY);</span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(src.<span class="built_in">size</span>(),src.type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> src_w = src.cols; <span class="comment">// 图片的宽</span></span><br><span class="line">    <span class="keyword">int</span> src_h = src.rows; <span class="comment">// 图片的高</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">15</span>;</span><br><span class="line">    <span class="comment">// 知识不是用来背的 20% ，用来唤醒大家的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src_h - <span class="built_in">size</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src_w - <span class="built_in">size</span>; ++col) &#123;</span><br><span class="line">            <span class="keyword">int</span> g[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;, b_g[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;, g_g[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;, r_g[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 255/8</span></span><br><span class="line">            <span class="comment">// 这个位置  64 循环 -&gt; 1 个像素点 ， 高斯模糊 ，想想怎么优化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> o_rows = <span class="number">0</span>; o_rows &lt; <span class="built_in">size</span>; ++o_rows) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> o_cols = <span class="number">0</span>; o_cols &lt; <span class="built_in">size</span>; ++o_cols) &#123;</span><br><span class="line">                    uchar gery = gray.at&lt;uchar&gt;(row + o_rows,col + o_cols);</span><br><span class="line">                    uchar index = gery / (<span class="number">255</span> / (<span class="built_in">size</span> - <span class="number">1</span>)); <span class="comment">// 254*7/254</span></span><br><span class="line">                    g[index] += <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// 等级的像素之和</span></span><br><span class="line">                    b_g[index] += src.at&lt;Vec4b&gt;(row + o_rows,col + o_cols)[<span class="number">0</span>];</span><br><span class="line">                    g_g[index] += src.at&lt;Vec4b&gt;(row + o_rows,col + o_cols)[<span class="number">1</span>];</span><br><span class="line">                    r_g[index] += src.at&lt;Vec4b&gt;(row + o_rows,col + o_cols)[<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最大的角标找出来</span></span><br><span class="line">            <span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">max</span> = g[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">size</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(g[max_index] &lt; g[i])&#123;</span><br><span class="line">                    max_index = i;</span><br><span class="line">                    <span class="built_in">max</span> = g[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 会超过 255，超过了的话 会截取最高位</span></span><br><span class="line">            res.at&lt;Vec4b&gt;(row,col)[<span class="number">0</span>] = b_g[max_index] / <span class="built_in">max</span>;</span><br><span class="line">            res.at&lt;Vec4b&gt;(row,col)[<span class="number">1</span>] = g_g[max_index] / <span class="built_in">max</span>;</span><br><span class="line">            res.at&lt;Vec4b&gt;(row,col)[<span class="number">2</span>] = r_g[max_index] / <span class="built_in">max</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cv_helper::mat2bitmap(env, res, bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-处理速度性能优化"><a href="#8-处理速度性能优化" class="headerlink" title="8. 处理速度性能优化"></a>8. 处理速度性能优化</h1><p>运算速度：位运算 &gt; +- &gt;  */ 。 int &gt; float</p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：07.形态学，验证码，提取水平线，上、降采样</title>
    <url>/55.OpenCV-%E5%BD%A2%E6%80%81%E5%AD%A6%EF%BC%8C%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%8C%E6%8F%90%E5%8F%96%E6%B0%B4%E5%B9%B3%E7%BA%BF%EF%BC%8C%E4%B8%8A%E3%80%81%E9%99%8D%E9%87%87%E6%A0%B7/</url>
    <content><![CDATA[<h1 id="1-形态学操作"><a href="#1-形态学操作" class="headerlink" title="1. 形态学操作"></a>1. 形态学操作</h1><p><code>morphologyEx</code></p>
<p>腐蚀：erode 取最小值<br>膨胀：dilate 取最大值  </p>
<ul>
<li>MORPH_OPEN 开：先腐蚀后膨胀</li>
<li>MORPH_CLOSE 闭：先膨胀后腐蚀</li>
<li>MORPH_GRADIENT 梯度：膨胀 - 腐蚀</li>
<li>MORPH_TOPHAT 顶帽：原图像 - 开图像</li>
<li>MORPH_BLACKHAT 黑帽：闭图像 - 原图像</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"imread error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	Mat kernel = getStructuringElement(MORPH_RECT,Size(<span class="number">25</span>,<span class="number">25</span>));</span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	<span class="comment">// erode(src, dst, kernel);</span></span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	<span class="comment">//dilate(src,dst,kernel);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MORPH_OPEN 开：先腐蚀后膨胀</span></span><br><span class="line">	<span class="comment">// morphologyEx(src, dst,MORPH_OPEN,kernel);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// MORPH_CLOSE 闭：先膨胀后腐蚀</span></span><br><span class="line">	<span class="comment">// morphologyEx(src,dst,MORPH_CLOSE,kernel);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// MORPH_GRADIENT 梯度：膨胀 - 腐蚀</span></span><br><span class="line">	<span class="comment">//morphologyEx(src, dst, MORPH_GRADIENT, kernel);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MORPH_TOPHAT 顶帽：原图像 - 开图像</span></span><br><span class="line">	<span class="comment">// morphologyEx(src,dst,MORPH_TOPHAT,kernel);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MORPH_BLACKHAT 黑帽：闭图像 - 原图像</span></span><br><span class="line">	morphologyEx(src,dst,MORPH_BLACKHAT,kernel);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-验证码识别"><a href="#2-验证码识别" class="headerlink" title="2. 验证码识别"></a>2. 验证码识别</h1><p><code>~ 符号表示 = （255 - 原本的像素值） 等同于 bitwise_not</code><br><code>adaptiveThreshold 二值化， 比如 &gt; 125 的像素 设置为 255, 小于=125 的像素设置为 0</code> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"imread error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2.1 把彩色变成 黑白 二值化</span></span><br><span class="line">	<span class="comment">// 灰白</span></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src,gray,COLOR_BGR2GRAY);</span><br><span class="line">	<span class="comment">// imshow("gray",gray);</span></span><br><span class="line">	<span class="comment">// 二值化方法，自动阈值</span></span><br><span class="line">	<span class="comment">// ~ 符号表示 = （255 - 原本的像素值） 等同于 bitwise_not</span></span><br><span class="line">	Mat binary;</span><br><span class="line">	adaptiveThreshold(~gray,binary,<span class="number">255</span>,ADAPTIVE_THRESH_MEAN_C,THRESH_BINARY,<span class="number">15</span>,<span class="number">0</span>);</span><br><span class="line">	imshow(<span class="string">"binary"</span>,binary);</span><br><span class="line"></span><br><span class="line">	Mat kernel = getStructuringElement(MORPH_RECT,Size(<span class="number">5</span>,<span class="number">5</span>));</span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="comment">// 腐蚀</span></span><br><span class="line">	erode(src,dst,kernel);</span><br><span class="line">	<span class="comment">// 膨胀</span></span><br><span class="line">	dilate(src, dst, kernel);</span><br><span class="line">	<span class="comment">// morphologyEx(src,dst,MORPH_CLOSE,kernel);</span></span><br><span class="line">	bitwise_not(dst, dst);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-提取水平线"><a href="#3-提取水平线" class="headerlink" title="3. 提取水平线"></a>3. 提取水平线</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"imread error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">	<span class="comment">// imshow("gray",gray);</span></span><br><span class="line">	<span class="comment">// 二值化方法，自动阈值</span></span><br><span class="line">	<span class="comment">// ~ 符号表示 = （255 - 原本的像素值） 等同于 bitwise_not</span></span><br><span class="line">	Mat binary;</span><br><span class="line">	adaptiveThreshold(~gray, binary, <span class="number">255</span>, ADAPTIVE_THRESH_MEAN_C, THRESH_BINARY, <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 二值化有些小问题，做一下弥补</span></span><br><span class="line">	Mat kernel = getStructuringElement(MORPH_RECT, Size(<span class="number">9</span>, <span class="number">9</span>));</span><br><span class="line">	Mat dst;</span><br><span class="line">	dilate(binary, dst, kernel);</span><br><span class="line">	erode(dst, dst, kernel);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 取水平</span></span><br><span class="line">	Mat lLine = getStructuringElement(MORPH_RECT, Size(src.cols/<span class="number">16</span>,<span class="number">1</span>));</span><br><span class="line">	erode(dst,dst,lLine);</span><br><span class="line">	dilate(dst,dst,lLine);</span><br><span class="line">	imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-上采样与降采样"><a href="#4-上采样与降采样" class="headerlink" title="4. 上采样与降采样"></a>4. 上采样与降采样</h1><p>图片采样：采样（sampling）也称取样，指把时间域或空间域的连续量转化成离散量的过程。在数字图像处理领域中，定义为图像空间坐标的数字化操作。</p>
<ul>
<li>pyrUp 上采样 放大  拉普拉斯：预计算（推算）值</li>
<li>pyrDown 降采样 缩小  高斯 ，1. 对图像进行高斯模糊，2.再过滤左右临近点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"imread error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="comment">// 上采样 拉普拉斯 双线性插值，预计算（推算）值</span></span><br><span class="line">	<span class="comment">// pyrUp(src,dst,Size(src.cols*2,src.rows*2));</span></span><br><span class="line">	<span class="comment">// 降采样：1. 对图像进行高斯模糊，2.再过滤左右临近点。 采用的高斯 所以比较慢</span></span><br><span class="line">	pyrDown(src,dst,Size(src.cols/<span class="number">2</span>,src.rows/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// imwrite("E:/copy_pyrUp.png", dst);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




















]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：12.直方图比较和匹配</title>
    <url>/60.OpenCV-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%AF%94%E8%BE%83%E5%92%8C%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="1-直方图比较-（compareHist-2组数据去对比）"><a href="#1-直方图比较-（compareHist-2组数据去对比）" class="headerlink" title="1. 直方图比较 （compareHist 2组数据去对比）"></a>1. 直方图比较 （compareHist 2组数据去对比）</h1><p><code>compareHist( const SparseMat&amp; H1, const SparseMat&amp; H2, int method )</code></p>
<h2 id="1-1-相关性比较-HISTCMP-CORREL-（多少的时候是最好的-1）-N-bins-直方图的等级"><a href="#1-1-相关性比较-HISTCMP-CORREL-（多少的时候是最好的-1）-N-bins-直方图的等级" class="headerlink" title="1.1 相关性比较 HISTCMP_CORREL （多少的时候是最好的  1）  N bins  直方图的等级"></a>1.1 相关性比较 HISTCMP_CORREL （多少的时候是最好的  1）  N bins  直方图的等级</h2><p><img src="/images/60.%E7%9B%B8%E5%85%B3%E6%80%A7%E6%AF%94%E8%BE%83.png" alt>  <img src="/images/60.%E7%9B%B8%E5%85%B3%E6%80%A7%E6%AF%94%E8%BE%832.png" alt></p>
<h2 id="1-2-卡方比较-HISTCMP-CHISQR-多少的时候是最好的-0"><a href="#1-2-卡方比较-HISTCMP-CHISQR-多少的时候是最好的-0" class="headerlink" title="1.2 卡方比较 HISTCMP_CHISQR    (多少的时候是最好的  0)"></a>1.2 卡方比较 HISTCMP_CHISQR    (多少的时候是最好的  0)</h2><p><img src="/images/60.%E5%8D%A1%E6%96%B9%E6%AF%94%E8%BE%83.png" alt></p>
<h2 id="1-3-十字交叉性-HISTCMP-INTERSECT"><a href="#1-3-十字交叉性-HISTCMP-INTERSECT" class="headerlink" title="1.3 十字交叉性 HISTCMP_INTERSECT"></a>1.3 十字交叉性 HISTCMP_INTERSECT</h2><p><img src="/images/60.%E5%8D%81%E5%AD%97%E4%BA%A4%E5%8F%89%E6%80%A7%E6%AF%94%E8%BE%83.png" alt></p>
<h2 id="1-4-巴氏距离-CV-COMP-BHATTACHARYYA-多少的时候是最好的-0"><a href="#1-4-巴氏距离-CV-COMP-BHATTACHARYYA-多少的时候是最好的-0" class="headerlink" title="1.4 巴氏距离 CV_COMP_BHATTACHARYYA  (多少的时候是最好的  0)"></a>1.4 巴氏距离 CV_COMP_BHATTACHARYYA  (多少的时候是最好的  0)</h2><p><img src="/images/60.%E5%B7%B4%E5%BC%8F%E8%B7%9D%E7%A6%BB.png" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">// 三张图</span></span><br><span class="line">	Mat src1 = imread(<span class="string">"E:/test.jpg"</span>);</span><br><span class="line">	Mat src2 = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line">	Mat src3 = imread(<span class="string">"E:/test3.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src1.data || !src2.data || !src3.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// RGB -&gt; HSV , 计算 HS 直方图3</span></span><br><span class="line">	Mat hsv1, hsv2, hsv3;</span><br><span class="line">	cvtColor(src1, hsv1, COLOR_BGR2HSV);</span><br><span class="line">	cvtColor(src2, hsv2, COLOR_BGR2HSV);</span><br><span class="line">	cvtColor(src3, hsv3, COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算直方图3（取 h 和 s 两个）</span></span><br><span class="line">	<span class="keyword">int</span> channels[] = &#123; <span class="number">0</span>, <span class="number">1</span> &#125;;</span><br><span class="line">	<span class="comment">// 复数（h的直方图放一个  s的直方图放一个）</span></span><br><span class="line">	MatND hist1, hist2, hist3;</span><br><span class="line">	<span class="keyword">int</span> h_bins = <span class="number">50</span>; <span class="comment">// h 的等级个数 </span></span><br><span class="line">	<span class="keyword">int</span> s_bins = <span class="number">50</span>; <span class="comment">// s 的等级个数</span></span><br><span class="line">	<span class="keyword">int</span> hist_size[] = &#123; h_bins, s_bins &#125;;</span><br><span class="line">	<span class="keyword">float</span> h_rangs[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;<span class="comment">// h 通道 最大不会超过 180</span></span><br><span class="line">	<span class="keyword">float</span> s_rangs[] = &#123; <span class="number">0</span>, <span class="number">255</span> &#125;;<span class="comment">// s 通过 最大不超过 255</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> *rangs[] = &#123; h_rangs, s_rangs &#125;;</span><br><span class="line">	calcHist(&amp;hsv1, <span class="number">1</span>, channels, Mat(), hist1, <span class="number">2</span>, hist_size, rangs);</span><br><span class="line">	calcHist(&amp;hsv2, <span class="number">1</span>, channels, Mat(), hist2, <span class="number">2</span>, hist_size, rangs);</span><br><span class="line">	calcHist(&amp;hsv3, <span class="number">1</span>, channels, Mat(), hist3, <span class="number">2</span>, hist_size, rangs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 归一化  0 - 1</span></span><br><span class="line">	normalize(hist1, hist1, <span class="number">0</span>, <span class="number">1</span>, NORM_MINMAX);</span><br><span class="line">	normalize(hist2, hist2, <span class="number">0</span>, <span class="number">1</span>, NORM_MINMAX);</span><br><span class="line">	normalize(hist2, hist2, <span class="number">0</span>, <span class="number">1</span>, NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两个直方图比较</span></span><br><span class="line">	<span class="comment">// compareHist( const SparseMat&amp; H1, const SparseMat&amp; H2, int method )</span></span><br><span class="line">	<span class="keyword">double</span> hist1_hist1 = compareHist(hist1, hist1, HISTCMP_CORREL); <span class="comment">// 最好的</span></span><br><span class="line">	<span class="keyword">double</span> hist1_hist2 = compareHist(hist1, hist2, HISTCMP_CORREL); <span class="comment">// 接近于 1</span></span><br><span class="line">	<span class="keyword">double</span> hist1_hist3 = compareHist(hist1, hist3, HISTCMP_CORREL); <span class="comment">// &lt; 0.8</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hist1_hist1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hist1_hist2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hist1_hist3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src1"</span>, src1);</span><br><span class="line">	imshow(<span class="string">"src2"</span>, src2);</span><br><span class="line">	imshow(<span class="string">"src3"</span>, src3);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-直方图反向投射-反射投影的次数-（不是像素值）"><a href="#2-直方图反向投射-反射投影的次数-（不是像素值）" class="headerlink" title="2. 直方图反向投射 (反射投影的次数 （不是像素值）)"></a>2. 直方图反向投射 (反射投影的次数 （不是像素值）)</h1><p><code>可用于截取</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">calcBackProject(<span class="keyword">const</span> Mat* images, <span class="keyword">int</span> nimages,</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">int</span>* channels, InputArray hist,</span><br><span class="line">		OutputArray backProject, <span class="keyword">const</span> <span class="keyword">float</span>** ranges,</span><br><span class="line">		<span class="keyword">double</span> scale = <span class="number">1</span>, <span class="keyword">bool</span> uniform = <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Mat hueImage;</span><br><span class="line"><span class="keyword">int</span> bins = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> max_bins = <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hist_backprojection</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">void</span>*)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 直方图反向投影到 Mat</span></span><br><span class="line">	<span class="comment">// calcBackProject</span></span><br><span class="line">	<span class="comment">//calcBackProject(const Mat* images, int nimages,</span></span><br><span class="line">	<span class="comment">//	const int* channels, InputArray hist,</span></span><br><span class="line">	<span class="comment">//	OutputArray backProject, const float** ranges,</span></span><br><span class="line">	<span class="comment">//	double scale = 1, bool uniform = true);</span></span><br><span class="line"></span><br><span class="line">	Mat hist;</span><br><span class="line">	<span class="keyword">int</span> hist_size = MAX(bins,<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">float</span> hue_rang[] = &#123; <span class="number">0</span>, <span class="number">180</span> &#125;;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">float</span> *ranges[] = &#123; hue_rang &#125;;</span><br><span class="line">	calcHist(&amp;hueImage, <span class="number">1</span>, <span class="number">0</span>, Mat(), hist, <span class="number">1</span>, &amp;hist_size, ranges);</span><br><span class="line">	normalize(hist, hist, <span class="number">0</span>, <span class="number">255</span>, NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 反射投影的次数 （不是像素值）</span></span><br><span class="line">	Mat backProject;</span><br><span class="line">	calcBackProject(&amp;hueImage, <span class="number">1</span>, <span class="number">0</span>, hist, backProject, ranges);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"BackProject"</span>, backProject);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"C:/Users/hcDarren/Desktop/android/hand.png"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"读取文件出错"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Mat hsv;</span><br><span class="line">	cvtColor(src, hsv, COLOR_BGR2HSV);</span><br><span class="line">	<span class="comment">// 作业，明天讲</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Mat&gt; hsv_s;</span><br><span class="line">	split(hsv, hsv_s);</span><br><span class="line">	hueImage = hsv_s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个窗口</span></span><br><span class="line">	namedWindow(<span class="string">"BackProject"</span>);</span><br><span class="line">	createTrackbar(<span class="string">"backprojection"</span>, <span class="string">"BackProject"</span>, &amp;bins, max_bins, hist_backprojection);</span><br><span class="line">	hist_backprojection(bins, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-直方图模板匹配"><a href="#3-直方图模板匹配" class="headerlink" title="3.直方图模板匹配"></a>3.<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/histograms/template_matching/template_matching.html" target="_blank" rel="noopener">直方图模板匹配</a></h1><p><code>用于找寻相似的部分</code></p>
<p><code>matchTemplate(InputArray image, InputArray templ,
         OutputArray result, int method, InputArray mask = noArray());</code></p>
<ul>
<li>TM_SQDIFF : 平方差匹配。这类方法利用平方差来进行匹配,最好匹配为0.匹配越差,匹配值越大.</li>
<li>TM_SQDIFF_NORMED：标准平方差匹配</li>
<li>TM_CCORR：相关匹配。这类方法采用模板和图像间的乘法操作,所以较大的数表示匹配程度较高,0标识最坏的匹配效果.</li>
<li>TM_CCORR_NORMED：标准相关匹配</li>
<li>TM_CCOEFF：相关匹配。这类方法将模版对其均值的相对值与图像对其均值的相关值进行匹配,1表示完美匹配,-1表示糟糕的匹配,0表示没有任何相关性(随机序列).</li>
<li>TM_CCOEFF_NORMED：标准相关匹配。</li>
</ul>
<p><code>CV_EXPORTS_W void minMaxLoc(InputArray src, CV_OUT double* minVal,
         CV_OUT double* maxVal = 0, CV_OUT Point* minLoc = 0,
         CV_OUT Point* maxLoc = 0, InputArray mask = noArray());</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"C:/Users/hcDarren/Desktop/android/qd.jpg"</span>);</span><br><span class="line">	Mat tmpl = imread(<span class="string">"C:/Users/hcDarren/Desktop/android/template.png"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"读取文件出错"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*matchTemplate(InputArray image, InputArray templ,</span></span><br><span class="line"><span class="comment">		OutputArray result, int method, InputArray mask = noArray());*/</span></span><br><span class="line"></span><br><span class="line">	<span class="function">Mat <span class="title">result</span><span class="params">(src.rows - tmpl.rows + <span class="number">1</span>, src.cols - tmpl.cols + <span class="number">1</span>, CV_32FC1)</span></span>;</span><br><span class="line">	<span class="comment">// 模板匹配   result  匹配计算的结果 ， 大小应该是多少 image.cols image.rows</span></span><br><span class="line">	matchTemplate(src, tmpl, result, TM_CCORR_NORMED);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从结果里面去找最小值，for , 找到那个最小值的点 Point， for 去找 </span></span><br><span class="line">	<span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">minMaxLoc</span><span class="params">(InputArray src, CV_OUT <span class="keyword">double</span>* minVal,</span></span></span><br><span class="line"><span class="function"><span class="params">		CV_OUT <span class="keyword">double</span>* maxVal = <span class="number">0</span>, CV_OUT Point* minLoc = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">		CV_OUT Point* maxLoc = <span class="number">0</span>, InputArray mask = noArray())</span></span>;</span><br><span class="line">	<span class="comment">// 传出参数：minVal 在函数中通过指针赋值，当做返回值用</span></span><br><span class="line">	<span class="keyword">double</span> minVal = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">double</span> maxVal = <span class="number">0</span>;</span><br><span class="line">	Point minLoc = <span class="number">0</span>;</span><br><span class="line">	Point maxLoc = <span class="number">0</span>;</span><br><span class="line">	minMaxLoc(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; maxVal &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画出来</span></span><br><span class="line">	rectangle(src, maxLoc, Point(maxLoc.x + tmpl.cols, maxLoc.y + tmpl.rows), Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：15.图片的几何变换</title>
    <url>/63.OpenCV-%E5%9B%BE%E7%89%87%E7%9A%84%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv63" target="_blank" rel="noopener">NDKPractice项目的opencv63</a></strong></p>
<h1 id="1-图片旋转"><a href="#1-图片旋转" class="headerlink" title="1. 图片旋转"></a>1. 图片旋转</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv63_OpenCvUtils_rotation(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res_w = src.rows; <span class="comment">// 图片的宽</span></span><br><span class="line">    <span class="keyword">int</span> res_h = src.cols; <span class="comment">// 图片的高</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(res_h, res_w, src.type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输出图像的下半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; res_h; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; res_w; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src.type() == CV_8UC4)</span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col) = src.at&lt;Vec4b&gt;(src.rows - col, row);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC2)</span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col) = src.at&lt;Vec3b&gt;(src.rows - col, row);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC1)</span><br><span class="line">                res.at&lt;uchar&gt;(row, col) = src.at&lt;uchar&gt;(src.rows - col, row);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的bitmap 宽是原来的高，高是原来的宽</span></span><br><span class="line">    jobject newBitmap = bitmap_util::create_bitmap(env, res_w, res_h, res.type());</span><br><span class="line">    cv_helper::mat2bitmap(env, res, newBitmap);</span><br><span class="line">    <span class="keyword">return</span> newBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-矩阵仿射变换"><a href="#2-矩阵仿射变换" class="headerlink" title="2. 矩阵仿射变换"></a>2. 矩阵仿射变换</h1><p>使用到的 api </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// center 旋转中心点  angle 逆时针 scale 缩放比例</span></span><br><span class="line"><span class="function">Mat <span class="title">getRotationMatrix2D</span><span class="params">(Point2f center, <span class="keyword">double</span> angle, <span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 图像仿射变换的 用到的 api</span></span></span><br><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">warpAffine</span><span class="params">( InputArray src, OutputArray dst,</span></span></span><br><span class="line"><span class="function"><span class="params">                              InputArray M, Size dsize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> flags = INTER_LINEAR,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> Scalar&amp; borderValue = Scalar())</span></span>;</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片仿射变换</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_east_opencv63_OpenCvUtils_warpAffine(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(src.<span class="built_in">size</span>(), src.type())</span></span>;</span><br><span class="line">    <span class="comment">/*Mat M(2,3,CV_32FC1);</span></span><br><span class="line"><span class="comment">    // 这几个值应该怎么确定？</span></span><br><span class="line"><span class="comment">    // [a0,a1,a2]     两个矩阵    [a0,a1]    [a2]       =     [ x ]     *     [a0,a1]    +   [a2]    =   a0*x+b0*x + a2</span></span><br><span class="line"><span class="comment">    // [b0,b1,b2]                 [b0,b1]    [b2]             [ y ]           [b0,b1]        [b2]    =   b1*y+b1*y + b2</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(0,0) = 1;// a0</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(0,1) = 0;// a1</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(0,2) = 0;// a2</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(1,0) = 0; // b1</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(1,1) = 1; // b2</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(1,2) = 0;*/</span> <span class="comment">//b3</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Point2f <span class="title">center</span><span class="params">(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>)</span></span>;</span><br><span class="line">    Mat M = getRotationMatrix2D(center, <span class="number">45</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    warpAffine(src, res, M, src.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cv_helper::mat2bitmap(env, res, bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-reSize-图片缩放"><a href="#3-reSize-图片缩放" class="headerlink" title="3. reSize() 图片缩放"></a>3. reSize() 图片缩放</h1><ul>
<li>INTER_NEAREST - 最近邻插值</li>
<li>INTER_LINEAR - 线性插值（默认值）</li>
<li>INTER_AREA - 区域插值（利用像素区域关系的重采样插值）</li>
<li>INTER_CUBIC –三次样条插值（超过4×4像素邻域内的双三次插值）</li>
<li>INTER_LANCZOS4 -Lanczos插值（超过8×8像素邻域的Lanczos插值）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图片缩放</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_east_opencv63_OpenCvUtils_resize(JNIEnv *env, jclass clazz, jobject bitmap, jint <span class="built_in">width</span>,</span><br><span class="line">                                          jint <span class="built_in">height</span>) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(<span class="built_in">height</span>, <span class="built_in">width</span>, src.type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> src_w = src.cols;</span><br><span class="line">    <span class="keyword">float</span> src_h = src.rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="built_in">height</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="built_in">width</span>; ++col) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> src_row = row * (src_h / <span class="built_in">height</span>);</span><br><span class="line">            <span class="keyword">int</span> src_col = col * (src_w / <span class="built_in">width</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src.type() == CV_8UC4)</span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col) = src.at&lt;Vec4b&gt;(src_row, src_col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC2)</span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col) = src.at&lt;Vec3b&gt;(src_row, src_col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC1)</span><br><span class="line">                res.at&lt;uchar&gt;(row, col) = src.at&lt;uchar&gt;(src_row, src_col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    jobject newBitmap = bitmap_util::create_bitmap(env, <span class="built_in">width</span>, <span class="built_in">height</span>, res.type());</span><br><span class="line">    cv_helper::mat2bitmap(env, res, newBitmap);</span><br><span class="line">    <span class="keyword">return</span> newBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-remap-重映射-自己实现"><a href="#4-remap-重映射-自己实现" class="headerlink" title="4.remap 重映射  (自己实现)"></a>4.remap 重映射  (自己实现)</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remap</span><span class="params">(Mat &amp;src,Mat &amp;res,Mat &amp;matX,Mat &amp;matY)</span></span>&#123;</span><br><span class="line">    res.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">    <span class="keyword">int</span> res_w = res.cols;</span><br><span class="line">    <span class="keyword">int</span> res_h = res.rows;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; res_h; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; res_w; ++col) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = matX.at&lt;<span class="keyword">float</span>&gt;(row,col);</span><br><span class="line">            <span class="keyword">int</span> y = matY.at&lt;<span class="keyword">float</span>&gt;(row,col);</span><br><span class="line">            res.at&lt;Vec4b&gt;(row,col) = src.at&lt;Vec4b&gt;(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手写 Remap 重映射</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_east_opencv63_OpenCvUtils_reMap(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line">    Mat res;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">matX</span><span class="params">(src.<span class="built_in">size</span>(), CV_32F)</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">matY</span><span class="params">(src.<span class="built_in">size</span>(), CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; ++col) &#123;</span><br><span class="line">            matX.at&lt;<span class="keyword">float</span>&gt;(row, col) = src.cols - col;</span><br><span class="line">            matY.at&lt;<span class="keyword">float</span>&gt;(row, col) = src.rows - row;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remap(src, res, matX, matY);</span><br><span class="line">    cv_helper::mat2bitmap(env,res,bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：17.手写直方图和直方均衡</title>
    <url>/65.OpenCV-%E6%89%8B%E5%86%99%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%92%8C%E7%9B%B4%E6%96%B9%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<h1 id="1-亮度增强-线性方式"><a href="#1-亮度增强-线性方式" class="headerlink" title="1.亮度增强(线性方式)"></a>1.亮度增强(线性方式)</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; src.channels() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	Mat dst = src.clone();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			Vec3b pixels = src.at&lt;Vec3b&gt;(row,col);</span><br><span class="line">			dst.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(pixels[<span class="number">0</span>] + <span class="number">30</span>);</span><br><span class="line">			dst.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(pixels[<span class="number">1</span>] + <span class="number">30</span>);</span><br><span class="line">			dst.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(pixels[<span class="number">2</span>] + <span class="number">30</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-直方均衡，提升对比度"><a href="#2-直方均衡，提升对比度" class="headerlink" title="2.直方均衡，提升对比度"></a>2.直方均衡，提升对比度</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	Mat hsv;</span><br><span class="line">	cvtColor(src,hsv,COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;Mat&gt; hsv_s;</span><br><span class="line">	split(hsv,hsv_s);</span><br><span class="line"></span><br><span class="line">	equalizeHist(hsv_s[<span class="number">2</span>],hsv_s[<span class="number">2</span>]);</span><br><span class="line">	merge(hsv_s,hsv);</span><br><span class="line">	cvtColor(hsv,src,COLOR_HSV2BGR);</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>,src);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-手写直方图计算源码"><a href="#3-手写直方图计算源码" class="headerlink" title="3. 手写直方图计算源码"></a>3. 手写直方图计算源码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手写直方图计算源码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcHist</span><span class="params">(<span class="keyword">const</span> Mat &amp;mat,Mat &amp;hist)</span></span>&#123;</span><br><span class="line">	<span class="comment">// int 存</span></span><br><span class="line">	hist.create(<span class="number">1</span>, <span class="number">256</span>, CV_32S);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hist.cols; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, i) = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; mat.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; mat.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 灰度等级的角标</span></span><br><span class="line">			<span class="keyword">int</span> index = mat.at&lt;uchar&gt;(row, col);</span><br><span class="line">			hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, index) += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> n_max)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 0 ~ n_max;</span></span><br><span class="line">	<span class="keyword">int</span> max_value = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> value = src.at&lt;<span class="keyword">int</span>&gt;(row, col);</span><br><span class="line">			max_value = <span class="built_in">max</span>(value, max_value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> value = src.at&lt;<span class="keyword">int</span>&gt;(row, col);</span><br><span class="line">			dst.at&lt;<span class="keyword">int</span>&gt;(row, col) = <span class="number">1.0</span> * value / max_value * n_max;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 手写直方图计算源码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src,gray,COLOR_BGR2GRAY);</span><br><span class="line">	imshow(<span class="string">"gray"</span>,gray);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// hist 没有宽高，是生成了一个空的数组</span></span><br><span class="line">	Mat hist;</span><br><span class="line">	calcHist(gray,hist);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hist &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画直方图，归一化</span></span><br><span class="line">	normalize(hist,hist,<span class="number">255</span>);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; hist &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 画直方图</span></span><br><span class="line">	<span class="keyword">int</span> bin_w = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> grad = <span class="number">256</span>;</span><br><span class="line">	<span class="function">Mat <span class="title">hist_mat</span><span class="params">(grad,bin_w * <span class="number">256</span>,CV_8UC3)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grad; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function">Point <span class="title">start</span><span class="params">(i*bin_w, hist_mat.rows)</span></span>;</span><br><span class="line">		<span class="function">Point <span class="title">end</span><span class="params">(i*bin_w, hist_mat.rows - hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>,i))</span></span>;</span><br><span class="line">		<span class="built_in">line</span>(hist_mat, start, <span class="built_in">end</span>, Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), bin_w, LINE_AA);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"hist_mat"</span>,hist_mat);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="4-手写直方图均衡"><a href="#4-手写直方图均衡" class="headerlink" title="4. 手写直方图均衡"></a>4. 手写直方图均衡</h1><p>假设有如下图像：</p>
<p><img src="/images/65.1.jpg" alt></p>
<p>得图像的统计信息如下图所示，并根据统计信息完成灰度值映射:  </p>
<p><img src="/images/65.2.jpg" alt></p>
<p>映射后的图像如下所示：  </p>
<p><img src="/images/65.3.jpg" alt></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.1 直方图的统计</span></span><br><span class="line"><span class="comment">// 4.2 计算直方图中像素的概率</span></span><br><span class="line"><span class="comment">// 4.3 生成一张映射表(255 * 累加概率)</span></span><br><span class="line"><span class="comment">// 4.4 从映射表中查找赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equalizeHist</span><span class="params">(Mat &amp;src,Mat &amp;dst)</span></span>&#123;</span><br><span class="line">	Mat hist;</span><br><span class="line">	<span class="comment">// 1.直方图的统计</span></span><br><span class="line">	calcHist(src,hist);</span><br><span class="line">	<span class="comment">// 2.计算直方图中像素的概率</span></span><br><span class="line">	<span class="function">Mat <span class="title">prob_mat</span><span class="params">(hist.<span class="built_in">size</span>(),CV_32FC1)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> image_size = src.rows * src.cols; <span class="comment">// 这个就是总的次数，因为每个像素值都算一次</span></span><br><span class="line">	<span class="comment">/*float image_size = 0;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; hist.cols; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		image_size += hist.at&lt;int&gt;(0, i);</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hist.cols; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> times = hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, i);</span><br><span class="line">		<span class="keyword">float</span> prob = times / image_size;</span><br><span class="line">		prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) = prob;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 3. 计算累加概率 256 （可读）</span></span><br><span class="line">	<span class="keyword">float</span> prob_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hist.cols; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		prob_sum += prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i);</span><br><span class="line">		prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) = prob_sum;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 生成映射表</span></span><br><span class="line">	<span class="function">Mat <span class="title">map</span><span class="params">(hist.<span class="built_in">size</span>(), CV_32FC1)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prob_mat.cols; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">map</span>.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) = <span class="number">255</span> * prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i); <span class="comment">// 255 * 概率</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	dst.create(src.<span class="built_in">size</span>(), src.type());</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			uchar pixels = src.at&lt;uchar&gt;(row, col);</span><br><span class="line">			dst.at&lt;uchar&gt;(row, col) = <span class="built_in">map</span>.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,pixels);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">	imshow(<span class="string">"gray"</span>, gray);</span><br><span class="line">	equalizeHist(gray,gray);</span><br><span class="line">	imshow(<span class="string">"dst"</span>,gray);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//vector&lt;Mat&gt; channels;</span></span><br><span class="line">	<span class="comment">//split(src,channels);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Mat blue = channels.at(0);</span></span><br><span class="line">	<span class="comment">//Mat green = channels.at(0);</span></span><br><span class="line">	<span class="comment">//Mat red = channels.at(0);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//equalizeHist(blue, blue);</span></span><br><span class="line">	<span class="comment">//equalizeHist(green, green);</span></span><br><span class="line">	<span class="comment">//equalizeHist(red, red);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Mat dst;</span></span><br><span class="line">	<span class="comment">//merge(channels, dst);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//imshow("dst", dst);</span></span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：13.轮廓查找、图像矩、多边形测试、图像分水岭</title>
    <url>/61.OpenCV-%E8%BD%AE%E5%BB%93%E6%9F%A5%E6%89%BE%E3%80%81%E5%9B%BE%E5%83%8F%E7%9F%A9%E3%80%81%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B5%8B%E8%AF%95%E3%80%81%E5%9B%BE%E5%83%8F%E5%88%86%E6%B0%B4%E5%B2%AD/</url>
    <content><![CDATA[<h1 id="1-银行卡轮廓查找与绘制"><a href="#1-银行卡轮廓查找与绘制" class="headerlink" title="1. 银行卡轮廓查找与绘制"></a>1. 银行卡轮廓查找与绘制</h1><p>使用到的api</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数说明：https://blog.csdn.net/guduruyu/article/details/69220296</span></span><br><span class="line"><span class="comment">输入图像image必须为一个2值单通道图像</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">contours参数为检测的轮廓数组，每一个轮廓用一个point类型的vector表示</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">hiararchy参数和轮廓个数相同，每个轮廓contours[ i ]对应4个hierarchy元素hierarchy[ i ][ 0 ] ~hierarchy[ i ][ 3 ]，</span></span><br><span class="line"><span class="comment">分别表示后一个轮廓、前一个轮廓、父轮廓、内嵌轮廓的索引编号，如果没有对应项，该值设置为负数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">mode表示轮廓的检索模式</span></span><br><span class="line"><span class="comment">CV_RETR_EXTERNAL 表示只检测外轮廓</span></span><br><span class="line"><span class="comment">CV_RETR_LIST 检测的轮廓不建立等级关系</span></span><br><span class="line"><span class="comment">CV_RETR_CCOMP 建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。</span></span><br><span class="line"><span class="comment">CV_RETR_TREE 建立一个等级树结构的轮廓。具体参考contours.c这个demo</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">method为轮廓的近似办法</span></span><br><span class="line"><span class="comment">CV_CHAIN_APPROX_NONE 存储所有的轮廓点，相邻的两个点的像素位置差不超过1，即max（abs（x1-x2），abs（y2-y1））==1</span></span><br><span class="line"><span class="comment">CV_CHAIN_APPROX_SIMPLE 压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息</span></span><br><span class="line"><span class="comment">CV_CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS 使用teh-Chinl chain 近似算法</span></span><br><span class="line"><span class="comment">offset表示代表轮廓点的偏移量，可以设置为任意值。对ROI图像中找出的轮廓，并要在整个图像中进行分析时，这个参数还是很有用的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">findContours</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="function"><span class="params">                              OutputArray hierarchy, <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> method, Point offset = Point())</span></span>;</span><br><span class="line"><span class="comment">// 查找轮廓</span></span><br><span class="line"><span class="function">CV_EXPORTS <span class="keyword">void</span> <span class="title">findContours</span><span class="params">( InputArray <span class="built_in">image</span>, OutputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> mode, <span class="keyword">int</span> method, Point offset = Point())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取可以包围轮廓的外层的矩形</span></span><br><span class="line"><span class="function">CV_EXPORTS_W Rect <span class="title">boundingRect</span><span class="params">( InputArray <span class="built_in">array</span> )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制轮廓</span></span><br><span class="line"></span><br><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">drawContours</span><span class="params">( InputOutputArray <span class="built_in">image</span>, InputArrayOfArrays contours,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> contourIdx, <span class="keyword">const</span> Scalar&amp; color,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> thickness = <span class="number">1</span>, <span class="keyword">int</span> lineType = LINE_8,</span></span></span><br><span class="line"><span class="function"><span class="params">                              InputArray hierarchy = noArray(),</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maxLevel = INT_MAX, Point offset = Point() )</span></span>;</span><br></pre></td></tr></table></figure>

<p>以下是银行卡的轮廓查找与绘制</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/card.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 梯度和二值化</span></span><br><span class="line">	Mat binary;</span><br><span class="line">	Canny(src,binary,<span class="number">50</span>,<span class="number">150</span>);</span><br><span class="line">	imshow(<span class="string">"binary"</span>, binary);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//findContours(InputArray image, OutputArrayOfArrays contours,</span></span><br><span class="line">	<span class="comment">//	int mode, int method, Point offset = Point())</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">	findContours(binary,contours,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	Mat contours_mat = Mat::zeros(src.<span class="built_in">size</span>(),CV_8UC3);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 画轮廓 </span></span><br><span class="line">		<span class="comment">// boundingRect 获取可以包围轮廓的外层的矩形</span></span><br><span class="line">		Rect <span class="built_in">rect</span> = boundingRect(contours[i]);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">rect</span>.<span class="built_in">width</span> &gt; src.cols / <span class="number">2</span> &amp;&amp; <span class="built_in">rect</span>.<span class="built_in">height</span> &gt; src.rows / <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="comment">// 画轮廓</span></span><br><span class="line">			drawContours(contours_mat,contours,i,Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>);</span><br><span class="line">			rectangle(contours_mat, Point(<span class="built_in">rect</span>.x, <span class="built_in">rect</span>.y), Point(<span class="built_in">rect</span>.x + <span class="built_in">rect</span>.<span class="built_in">width</span>, <span class="built_in">rect</span>.y + <span class="built_in">rect</span>.<span class="built_in">height</span>), Scalar(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">2</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"contours_mat"</span>, contours_mat);</span><br><span class="line">	</span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="2-图像矩-多边形测试"><a href="#2-图像矩-多边形测试" class="headerlink" title="2. 图像矩,多边形测试"></a>2. <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/shapedescriptors/point_polygon_test/point_polygon_test.html#point-polygon-test" target="_blank" rel="noopener">图像矩,多边形测试</a></h1><p>使用到的api</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// measureDist: 为`true`的情况下, `&lt;0:在外面，&gt;0：在里面，==0：在轮廓上`。</span></span><br><span class="line"><span class="comment">// 为`false`的情况,`-1:在外面，1：在里面，0：在轮廓上`</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pointPolygonTest</span><span class="params">( InputArray contour, Point2f pt, <span class="keyword">bool</span> measureDist )</span></span></span><br></pre></td></tr></table></figure>

<p>图像矩的一个小例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">/// 创建一个图形     </span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> r = <span class="number">100</span>;</span><br><span class="line">	Mat src = Mat::zeros(Size(<span class="number">4</span> * r, <span class="number">4</span> * r), CV_8UC1);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// 绘制一系列点创建一个轮廓:</span></span><br><span class="line">	<span class="function"><span class="built_in">vector</span>&lt;Point2f&gt; <span class="title">vert</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	vert[<span class="number">0</span>] = Point(<span class="number">1.5</span>*r, <span class="number">1.34</span>*r);</span><br><span class="line">	vert[<span class="number">1</span>] = Point(<span class="number">1</span> * r, <span class="number">2</span> * r);</span><br><span class="line">	vert[<span class="number">2</span>] = Point(<span class="number">1.5</span>*r, <span class="number">2.866</span>*r);</span><br><span class="line">	vert[<span class="number">3</span>] = Point(<span class="number">2.5</span>*r, <span class="number">2.866</span>*r);</span><br><span class="line">	vert[<span class="number">4</span>] = Point(<span class="number">3</span> * r, <span class="number">2</span> * r);</span><br><span class="line">	vert[<span class="number">5</span>] = Point(<span class="number">2.5</span>*r, <span class="number">1.34</span>*r);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// 在src内部绘制</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">line</span>(src, vert[j], vert[(j + <span class="number">1</span>) % <span class="number">6</span>], Scalar(<span class="number">255</span>), <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查找轮廓</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">	findContours(src,contours,RETR_EXTERNAL,CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算到轮廓的距离</span></span><br><span class="line">	<span class="function">Mat <span class="title">raw_dist</span><span class="params">(src.<span class="built_in">size</span>(),CV_32FC1)</span></span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			raw_dist.at&lt;<span class="keyword">float</span>&gt;(row, col) = pointPolygonTest(contours[<span class="number">0</span>], Point2f(col, row), <span class="literal">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 优化</span></span><br><span class="line">	Mat drawing = Mat::zeros(src.<span class="built_in">size</span>(),CV_8UC3);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// raw_dist.at&lt;float&gt;(row, col) = pointPolygonTest(contours[0], Point2f(col, row), true);</span></span><br><span class="line">			<span class="keyword">float</span> value = raw_dist.at&lt;<span class="keyword">float</span>&gt;(row, col);</span><br><span class="line">			<span class="keyword">if</span> (value &lt; <span class="number">0</span>)&#123; <span class="comment">// 外面</span></span><br><span class="line">				drawing.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = saturate_cast&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>)<span class="built_in">abs</span>(value));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="number">0</span>)&#123; <span class="comment">// 里面</span></span><br><span class="line">				drawing.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = saturate_cast&lt;<span class="keyword">int</span>&gt;((<span class="keyword">int</span>)value);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;<span class="comment">// 矩形上面</span></span><br><span class="line">				drawing.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = <span class="number">255</span>;</span><br><span class="line">				drawing.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = <span class="number">255</span>;</span><br><span class="line">				drawing.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = <span class="number">255</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"drawing"</span>, drawing);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-图像分水岭"><a href="#3-图像分水岭" class="headerlink" title="3. 图像分水岭"></a>3. 图像分水岭</h1><p>使用到的api</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">watershed</span><span class="params">( InputArray <span class="built_in">image</span>, InputOutputArray markers )</span></span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：18.人脸美容效果-积分图</title>
    <url>/66.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C-%E7%A7%AF%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="1-双边滤波美容"><a href="#1-双边滤波美容" class="headerlink" title="1. 双边滤波美容"></a>1. 双边滤波美容</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line">	bilateralFilter(src,dst,<span class="number">0</span>,<span class="number">100</span>,<span class="number">5</span>);</span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-卷积模糊算法，时间复杂度分析"><a href="#2-卷积模糊算法，时间复杂度分析" class="headerlink" title="2.卷积模糊算法，时间复杂度分析"></a>2.卷积模糊算法，时间复杂度分析</h1><p><code>时间复杂度 = src.rows * src.cols * size * size</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高斯（模糊），计算高斯卷积核，卷积操作，考虑像素之间的差值（更好的保留图像的边缘）</span></span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">10000</span>;</span><br><span class="line">	Mat kernel = Mat::ones(<span class="built_in">size</span>, <span class="built_in">size</span>, CV_32FC1) / (<span class="built_in">size</span> * <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">long</span> st = clock();</span><br><span class="line">	filter2D(src,dst,src.depth(),kernel);</span><br><span class="line">	<span class="keyword">long</span> et = clock();</span><br><span class="line">	<span class="keyword">double</span> time = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;((et - st) / CLOCKS_PER_SEC);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"time = "</span> &lt;&lt; time &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//时间复杂度 = src.rows * src.cols * size * size</span></span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-积分图算法介绍"><a href="#3-积分图算法介绍" class="headerlink" title="3. 积分图算法介绍"></a>3. 积分图算法介绍</h1><p>看图更明白些：</p>
<p><img src="/images/66.%E7%A7%AF%E5%88%86%E5%9B%BE%E8%AE%A1%E7%AE%97.png" alt></p>
<h1 id="4-使用积分图算法对卷积模糊进行优化"><a href="#4-使用积分图算法对卷积模糊进行优化" class="headerlink" title="4. 使用积分图算法对卷积模糊进行优化"></a>4. 使用积分图算法对卷积模糊进行优化</h1><p>使用到的 api</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @param sum ：积分和表</span></span><br><span class="line"><span class="comment">// @param sqsum ：平方和表</span></span><br><span class="line"><span class="comment">// @param sdepth ：积分和表的深度</span></span><br><span class="line"><span class="comment">// @param sqdepth ：平方和表的深度 如果是：CV_32F，计算的时候就以 float 计算</span></span><br><span class="line">CV_EXPORTS_AS(integral2) <span class="function"><span class="keyword">void</span> <span class="title">integral</span><span class="params">( InputArray src, OutputArray sum,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        OutputArray sqsum, <span class="keyword">int</span> sdepth = <span class="number">-1</span>, <span class="keyword">int</span> sqdepth = <span class="number">-1</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p><img src="/images/66.%E7%A7%AF%E5%88%86%E5%9B%BE%E7%9A%84%E6%A8%A1%E7%B3%8A%E7%AE%97%E6%B3%95.png" alt></p>
<p><code>Vec3b:vector&lt;uchar, 3&gt; 不能超过 255</code></p>
<p><code>Vec3i:vector&lt;int, 3&gt;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">meanBlur</span><span class="params">(Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 卷积的 size 必须确保为基数 size % 2 == 1</span></span><br><span class="line">	<span class="comment">// 填充周围，方便计算</span></span><br><span class="line">	Mat mat;</span><br><span class="line">	<span class="keyword">int</span> radius = <span class="built_in">size</span> / <span class="number">2</span>;</span><br><span class="line">	copyMakeBorder(src,mat,radius,radius,radius,radius,BORDER_DEFAULT);</span><br><span class="line">	<span class="comment">// 求积分图</span></span><br><span class="line">	Mat sum_mat, sqsum_mat;</span><br><span class="line">	integral(mat,sum_mat,sqsum_mat,CV_32S,CV_32S);</span><br><span class="line"></span><br><span class="line">	dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">	<span class="keyword">int</span> channels = src.channels();</span><br><span class="line">	<span class="keyword">int</span> area = <span class="built_in">size</span> * <span class="built_in">size</span>;</span><br><span class="line">	<span class="comment">// 求四个点，左上，左下，右上，右下</span></span><br><span class="line">	<span class="keyword">int</span> x0 = <span class="number">0</span>, x1 = <span class="number">0</span>, y0 = <span class="number">0</span>, y1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">	&#123;	</span><br><span class="line">		y0 = row;</span><br><span class="line">		y1 = y0 + <span class="built_in">size</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">		&#123;</span><br><span class="line">			x0 = col;</span><br><span class="line">			x1 = x0 + <span class="built_in">size</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; channels; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 获取四个点的值</span></span><br><span class="line">				<span class="keyword">int</span> lt = sum_mat.at&lt;Vec3i&gt;(y0, x0)[i];</span><br><span class="line">				<span class="keyword">int</span> lb = sum_mat.at&lt;Vec3i&gt;(y1, x0)[i];</span><br><span class="line">				<span class="keyword">int</span> rt = sum_mat.at&lt;Vec3i&gt;(y0, x1)[i];</span><br><span class="line">				<span class="keyword">int</span> rb = sum_mat.at&lt;Vec3i&gt;(y1, x1)[i];</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 区块的合</span></span><br><span class="line">				<span class="keyword">int</span> sum = rb - lb - rt + lt;</span><br><span class="line">				dst.at&lt;Vec3b&gt;(row, col)[i] = sum / area;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 高斯（模糊），计算高斯卷积核，卷积操作，考虑像素之间的差值（更好的保留图像的边缘）</span></span><br><span class="line"></span><br><span class="line">	Mat dst;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">15</span>; <span class="comment">// size == 10001 时 time = 1 秒</span></span><br><span class="line">	<span class="keyword">long</span> st = clock();</span><br><span class="line">	meanBlur(src,dst,<span class="built_in">size</span>);</span><br><span class="line">	<span class="keyword">long</span> et = clock();</span><br><span class="line">	<span class="keyword">double</span> time = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;((et - st) / CLOCKS_PER_SEC);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"time = "</span> &lt;&lt; time &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-快速边缘保留算法"><a href="#5-快速边缘保留算法" class="headerlink" title="5.快速边缘保留算法"></a>5.快速边缘保留算法</h1><p>先看两张图：</p>
<p><img src="/images/66.%E5%BF%AB%E9%80%9F%E8%BE%B9%E7%BC%98%E4%BF%9D%E7%95%99%E7%AE%97%E6%B3%95.png" alt></p>
<p><img src="/images/66.%E5%B1%80%E9%83%A8%E6%96%B9%E5%B7%AE%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC.png" alt></p>
<p>具体的请看<a href="https://github.com/EastUp/CPractice/blob/master/markdown/67.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C2-%E8%BE%B9%E7%BC%98%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">67.人脸美容效果2-边缘处理</a></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：19.人脸美容效果2-边缘处理</title>
    <url>/67.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C2-%E8%BE%B9%E7%BC%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-快速边缘保留算法"><a href="#1-快速边缘保留算法" class="headerlink" title="1.快速边缘保留算法"></a>1.快速边缘保留算法</h1><p>先看两张图：</p>
<p><img src="/images/66.%E5%BF%AB%E9%80%9F%E8%BE%B9%E7%BC%98%E4%BF%9D%E7%95%99%E7%AE%97%E6%B3%95.png" alt></p>
<p><img src="/images/66.%E5%B1%80%E9%83%A8%E6%96%B9%E5%B7%AE%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC.png" alt></p>
<p>具体代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 快速边缘保留</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 快速边缘保留</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBlockSum</span><span class="params">(Mat &amp;sum_mat,<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取四个点的值（因为肯定会超过 255 所以需要用Vec3i 来装）</span></span><br><span class="line">    <span class="keyword">int</span> lt = sum_mat.at&lt;Vec3i&gt;(y0, x0)[ch];</span><br><span class="line">    <span class="keyword">int</span> lb = sum_mat.at&lt;Vec3i&gt;(y1, x0)[ch];</span><br><span class="line">    <span class="keyword">int</span> rt = sum_mat.at&lt;Vec3i&gt;(y0, x1)[ch];</span><br><span class="line">    <span class="keyword">int</span> rb = sum_mat.at&lt;Vec3i&gt;(y1, x1)[ch];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区块的合</span></span><br><span class="line">    <span class="keyword">int</span> sum = rb - lb - rt + lt;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getBlockSqSum</span><span class="params">(Mat &amp;sqsum_mat, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取四个点的值（因为肯定会超过 255 所以需要用Vec3f 来装）</span></span><br><span class="line">    <span class="keyword">float</span> lt = sqsum_mat.at&lt;Vec3f&gt;(y0, x0)[ch];</span><br><span class="line">    <span class="keyword">float</span> lb = sqsum_mat.at&lt;Vec3f&gt;(y1, x0)[ch];</span><br><span class="line">    <span class="keyword">float</span> rt = sqsum_mat.at&lt;Vec3f&gt;(y0, x1)[ch];</span><br><span class="line">    <span class="keyword">float</span> rb = sqsum_mat.at&lt;Vec3f&gt;(y1, x1)[ch];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区块的合</span></span><br><span class="line">    <span class="keyword">float</span> sqsum = rb - lb - rt + lt;</span><br><span class="line">    <span class="keyword">return</span> sqsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 积分图的模糊算法 size 模糊的直径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fastBlateralBlur</span><span class="params">(Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> sigma)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 卷积的 size 必须确保为基数 size % 2 == 1</span></span><br><span class="line">    <span class="comment">// 填充周围，方便计算</span></span><br><span class="line">    Mat mat;</span><br><span class="line">    <span class="keyword">int</span> radius = <span class="built_in">size</span> / <span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src,mat,radius,radius,radius,radius,BORDER_DEFAULT);</span><br><span class="line">    <span class="comment">// 求积分图</span></span><br><span class="line">    Mat sum_mat, sqsum_mat;</span><br><span class="line">    integral(mat,sum_mat,sqsum_mat,CV_32S,CV_32F);</span><br><span class="line"></span><br><span class="line">    dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">    <span class="keyword">int</span> channels = src.channels();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="built_in">size</span> * <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 求四个点，左上，左下，右上，右下</span></span><br><span class="line">    <span class="keyword">int</span> x0 = <span class="number">0</span>, x1 = <span class="number">0</span>, y0 = <span class="number">0</span>, y1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        y0 = row;</span><br><span class="line">        y1 = y0 + <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            x0 = col;</span><br><span class="line">            x1 = x0 + <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; channels; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 区块的合</span></span><br><span class="line">                <span class="keyword">int</span> sum = getBlockSum(sum_mat,x0,y0,x1,y1,i);</span><br><span class="line">                <span class="keyword">float</span> sqsum = getBlockSqSum(sqsum_mat, x0, y0, x1, y1, i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> diff_sq = (sqsum - (sum*sum) / area) / area;</span><br><span class="line">                <span class="keyword">float</span> k = diff_sq / (diff_sq + sigma);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> pixels = src.at&lt;Vec3b&gt;(row, col)[i];</span><br><span class="line">                pixels = (<span class="number">1</span> - k)*(sum / area) + k * pixels;</span><br><span class="line"></span><br><span class="line">                dst.at&lt;Vec3b&gt;(row, col)[i] = pixels;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skinDetect</span><span class="params">(Mat &amp;src, Mat &amp;skinMask)</span></span>&#123;</span><br><span class="line">    skinMask.create(src.<span class="built_in">size</span>(),CV_8UC1);</span><br><span class="line">    <span class="keyword">int</span> rows = src.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = src.cols;</span><br><span class="line"></span><br><span class="line">    Mat ycrcb;</span><br><span class="line">    cvtColor(src,ycrcb,COLOR_BGR2YCrCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            Vec3b pixels = ycrcb.at&lt;Vec3b&gt;(row, col);</span><br><span class="line">            uchar y = pixels[<span class="number">0</span>];</span><br><span class="line">            uchar cr = pixels[<span class="number">1</span>];</span><br><span class="line">            uchar cb = pixels[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (y&gt;<span class="number">80</span> &amp;&amp; <span class="number">85</span> &lt; cb &lt; <span class="number">135</span> &amp;&amp; <span class="number">135</span> &lt; cr &lt; <span class="number">180</span>)&#123;</span><br><span class="line">                <span class="comment">// 255 代表人脸区域</span></span><br><span class="line">                skinMask.at&lt;uchar&gt;(row,col) = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                skinMask.at&lt;uchar&gt;(row, col) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuseSkin</span><span class="params">(Mat &amp;src,Mat &amp;blur_mat, Mat &amp;dst, Mat &amp;skinMask)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 融合</span></span><br><span class="line">    dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">    <span class="comment">// 处理一些区域，平滑点(所以有些地方的数值就不是0 或者 255了)</span></span><br><span class="line">    GaussianBlur(skinMask, skinMask, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    Mat skinMask_f;</span><br><span class="line">    skinMask.convertTo(skinMask_f, CV_32F);</span><br><span class="line">	</span><br><span class="line">    normalize(skinMask_f, skinMask_f, <span class="number">0.0</span>, <span class="number">1.0</span>, NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = src.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = src.cols;</span><br><span class="line">    <span class="keyword">int</span> ch = src.channels();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有的区域还是有可能不够平滑</span></span><br><span class="line">            <span class="comment">/*uchar mask_pixels = skinMask.at&lt;uchar&gt;(row, col);</span></span><br><span class="line"><span class="comment">            // 皮肤位置</span></span><br><span class="line"><span class="comment">            if (mask_pixels == 255)&#123;</span></span><br><span class="line"><span class="comment">                dst.at&lt;Vec3b&gt;(row, col) = blur_mat.at&lt;Vec3b&gt;(row,col);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else&#123;</span></span><br><span class="line"><span class="comment">                dst.at&lt;Vec3b&gt;(row, col) = src.at&lt;Vec3b&gt;(row, col);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// src ，通过指针去获取， 指针 -&gt; Vec3b -&gt; 获取</span></span><br><span class="line">            uchar b_src = src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line">            uchar g_src = src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line">            uchar r_src = src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// blur_mat</span></span><br><span class="line">            uchar b_blur = blur_mat.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line">            uchar g_blur = blur_mat.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line">            uchar r_blur = blur_mat.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> k = skinMask_f.at&lt;<span class="keyword">float</span>&gt;(row, col); <span class="comment">// k == 1的时候，人脸区域需要取b_blur，否则取b_src</span></span><br><span class="line"></span><br><span class="line">            dst.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = b_blur*k + (<span class="number">1</span> - k)*b_src;</span><br><span class="line">            dst.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = g_blur*k + (<span class="number">1</span> - k)*g_src;</span><br><span class="line">            dst.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = r_blur*k + (<span class="number">1</span> - k)*r_src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高斯（模糊），计算高斯卷积核，卷积操作，考虑像素之间的差值（更好的保留图像的边缘）</span></span><br><span class="line"></span><br><span class="line">    Mat blur_mat;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">12</span>; <span class="comment">// size == 10001 时 time = 1 秒</span></span><br><span class="line">    fastBlateralBlur(src, blur_mat, <span class="built_in">size</span>, <span class="built_in">size</span>*<span class="built_in">size</span>);</span><br><span class="line">    imshow(<span class="string">"fastBlateralBlur"</span>, blur_mat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 皮肤区域检测</span></span><br><span class="line">    Mat skinMask;</span><br><span class="line">    skinDetect(src, skinMask);</span><br><span class="line">    imshow(<span class="string">"skinDetect"</span>, skinMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//皮肤区域融合</span></span><br><span class="line">    Mat fuseDst;</span><br><span class="line">    fuseSkin(src, blur_mat, fuseDst, skinMask);</span><br><span class="line">    imshow(<span class="string">"fuseSkin"</span>, fuseDst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边缘的提升（可有可无）</span></span><br><span class="line">    Mat cannyMask;</span><br><span class="line">    Canny(src,cannyMask,<span class="number">150</span>,<span class="number">300</span>,<span class="number">3</span>,<span class="literal">false</span>);</span><br><span class="line">    imshow(<span class="string">"cannyMask"</span>, cannyMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于 &amp; 运算</span></span><br><span class="line">    bitwise_and(src,src,fuseDst,cannyMask);</span><br><span class="line">    imshow(<span class="string">"bitwise_and"</span>, fuseDst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 稍微提升一下对比度（亮度）</span></span><br><span class="line">    add(fuseDst,Scalar(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),fuseDst);</span><br><span class="line">    imshow(<span class="string">"add"</span>, fuseDst);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：20.二维码检测</title>
    <url>/68.OpenCV-%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="1-二维码检测"><a href="#1-二维码检测" class="headerlink" title="1.二维码检测"></a>1.二维码检测</h1><p>思路：</p>
<p><img src="/images/68.%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF.png" alt></p>
<p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果是倾斜的 变换菱形 放正</span></span><br><span class="line"><span class="function">Mat <span class="title">wrapTransfrom</span><span class="params">(<span class="keyword">const</span> Mat &amp;gray,<span class="keyword">const</span> RotatedRect &amp;<span class="built_in">rect</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">width</span> = <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span> = <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">	<span class="function">Mat <span class="title">result</span><span class="params">(Size(<span class="built_in">width</span>,<span class="built_in">height</span>),gray.type())</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 矩阵怎么获取</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;Point&gt; srcPoints;</span><br><span class="line">	Point2f pts[<span class="number">4</span>];</span><br><span class="line">	<span class="built_in">rect</span>.points(pts);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		srcPoints.push_back(pts[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;Point&gt; dstPoints;</span><br><span class="line">	dstPoints.push_back(Point(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">	dstPoints.push_back(Point(<span class="built_in">width</span>, <span class="number">0</span>));</span><br><span class="line">	dstPoints.push_back(Point(<span class="built_in">width</span>, <span class="built_in">height</span>));</span><br><span class="line">	dstPoints.push_back(Point(<span class="number">0</span>, <span class="built_in">height</span>));</span><br><span class="line">	</span><br><span class="line">	Mat M = findHomography(srcPoints,dstPoints);</span><br><span class="line">	warpPerspective(gray,result,M,result.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isXCorner</span><span class="params">(<span class="keyword">const</span> Mat &amp;qrROI)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 四个值</span></span><br><span class="line">	<span class="comment">//cb:中心的黑色块数量</span></span><br><span class="line">	<span class="comment">//lw:左边的白色块数量</span></span><br><span class="line">	<span class="comment">//rw:右边的白色块数量</span></span><br><span class="line">	<span class="comment">//lb:左边的黑色块数量</span></span><br><span class="line">	<span class="comment">//rb:右边的黑色块数量</span></span><br><span class="line">	<span class="keyword">int</span> cb = <span class="number">0</span>, lw = <span class="number">0</span>, rw = <span class="number">0</span>, lb = <span class="number">0</span>, rb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">width</span> = qrROI.cols; <span class="comment">//36</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span> = qrROI.rows; <span class="comment">//36</span></span><br><span class="line">	<span class="keyword">int</span> cx = <span class="built_in">width</span> / <span class="number">2</span>;  <span class="comment">// 18</span></span><br><span class="line">	<span class="keyword">int</span> cy = <span class="built_in">height</span> / <span class="number">2</span>; <span class="comment">// 18</span></span><br><span class="line">	uchar pixels = qrROI.at&lt;uchar&gt;(cy, cx);</span><br><span class="line">	<span class="keyword">if</span> (pixels == <span class="number">255</span>)&#123; <span class="comment">// 中间肯定是黑色的色块</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 求中心黑色</span></span><br><span class="line">	<span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>, offset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> findleft = <span class="literal">false</span>, findright = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">		offset++;</span><br><span class="line">		<span class="keyword">if</span> (offset &gt;= cx)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 中心点往左边扫</span></span><br><span class="line">		pixels = qrROI.at&lt;uchar&gt;(cy, cx - offset);</span><br><span class="line">		<span class="keyword">if</span> (!findleft &amp;&amp; pixels == <span class="number">255</span>)&#123;</span><br><span class="line">			start = cx - offset; <span class="comment">// 左边白色的像素位置 12</span></span><br><span class="line">			findleft = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 中心点往右边扫</span></span><br><span class="line">		pixels = qrROI.at&lt;uchar&gt;(cy, cx + offset);</span><br><span class="line">		<span class="keyword">if</span> (!findright &amp;&amp; pixels == <span class="number">255</span>)&#123;</span><br><span class="line">			<span class="built_in">end</span> = cx + offset; <span class="comment">// 右边白色的像素位置  25</span></span><br><span class="line">			findright = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (findleft &amp;&amp; findright)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start == <span class="number">0</span> || <span class="built_in">end</span> == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	cb = <span class="built_in">end</span> - start;</span><br><span class="line">	<span class="comment">// 相间的白色</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="built_in">end</span>; col &lt; <span class="built_in">width</span> - <span class="number">1</span>; col++)</span><br><span class="line">	&#123;</span><br><span class="line">		pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line">		<span class="keyword">if</span> (pixels == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		rw++;  <span class="comment">// 5</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> col = start; col &gt; <span class="number">0</span>; col--)</span><br><span class="line">	&#123;</span><br><span class="line">		pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line">		<span class="keyword">if</span> (pixels == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		lw++;  <span class="comment">// 6</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (rw == <span class="number">0</span> || lw == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两边的黑色</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="built_in">end</span>+rw; col &lt; <span class="built_in">width</span> - <span class="number">1</span>; col++)</span><br><span class="line">	&#123;</span><br><span class="line">		pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line">		<span class="keyword">if</span> (pixels == <span class="number">255</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		rb++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> col = start - lw; col &gt; <span class="number">0</span>; col--)</span><br><span class="line">	&#123;</span><br><span class="line">		pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line">		<span class="keyword">if</span> (pixels == <span class="number">255</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		lb++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (rb == <span class="number">0</span> || lb == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">float</span> sum = cb + lb + rb + lw + rw;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"cx = "</span> &lt;&lt; cx &lt;&lt; <span class="string">",,,cy ="</span> &lt;&lt; cy &lt;&lt; <span class="string">",,,width = "</span> &lt;&lt; <span class="built_in">width</span> &lt;&lt; <span class="string">",,,height ="</span> &lt;&lt; <span class="built_in">height</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"start = "</span> &lt;&lt; start &lt;&lt; <span class="string">",,,end ="</span> &lt;&lt; <span class="built_in">end</span> &lt;&lt; <span class="string">",,,cb ="</span> &lt;&lt; cb &lt;&lt; <span class="string">",,,lw = "</span> &lt;&lt; lw &lt;&lt; <span class="string">",,,rw ="</span> &lt;&lt; rw &lt;&lt; <span class="string">",,,lb ="</span> &lt;&lt; lb &lt;&lt; <span class="string">",,,rb ="</span> &lt;&lt; rb &lt;&lt; <span class="string">",,,sum ="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 求比例 3:1:1:1:1</span></span><br><span class="line">	cb = (cb / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">	lb = (lb / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">	rb = (rb / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">	lw = (lw / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">	rw = (rw / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"start = "</span> &lt;&lt; start &lt;&lt; <span class="string">",,,end ="</span> &lt;&lt; <span class="built_in">end</span> &lt;&lt; <span class="string">",,,cb ="</span> &lt;&lt; cb &lt;&lt; <span class="string">",,,lw = "</span> &lt;&lt; lw &lt;&lt; <span class="string">",,,rw ="</span> &lt;&lt; rw &lt;&lt; <span class="string">",,,lb ="</span> &lt;&lt; lb &lt;&lt; <span class="string">",,,rb ="</span> &lt;&lt; rb &lt;&lt; <span class="string">",,,sum ="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((cb == <span class="number">3</span> || cb == <span class="number">4</span>) &amp;&amp; (lw == rw) &amp;&amp; (lb == rb) &amp;&amp; (lw == <span class="number">1</span>))&#123;</span><br><span class="line">		<span class="comment">// 3:1:1:1:1 或 4:1:1:1:1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最好还是加上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isYCorner</span><span class="params">(<span class="keyword">const</span> Mat&amp; qrROI)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 统计白色像素点和黑色像素点</span></span><br><span class="line">	<span class="keyword">int</span> bp = <span class="number">0</span>, wp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">width</span> = qrROI.cols;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">height</span> = qrROI.rows;</span><br><span class="line">	<span class="keyword">int</span> cx = <span class="built_in">width</span> / <span class="number">2</span>;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 中心点是黑色</span></span><br><span class="line">	<span class="keyword">int</span> pv = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="built_in">height</span>; row++)</span><br><span class="line">	&#123;</span><br><span class="line">		pv = qrROI.at&lt;uchar&gt;(row, cx);</span><br><span class="line">		<span class="keyword">if</span> (pv == <span class="number">0</span>)&#123;</span><br><span class="line">			bp++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pv == <span class="number">255</span>)&#123;</span><br><span class="line">			wp++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bp == <span class="number">0</span> || wp == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wp * <span class="number">2</span> &gt; bp || bp &gt; <span class="number">4</span> * wp)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Mat src = imread(<span class="string">"E:/qcode1.jpg"</span>);</span><br><span class="line">	<span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 1.对图像进行灰度图处理</span></span><br><span class="line">	Mat gray;</span><br><span class="line">	cvtColor(src,gray,COLOR_BGR2GRAY);</span><br><span class="line">	<span class="comment">// 2. 二值化处理</span></span><br><span class="line">	threshold(gray,gray,<span class="number">0</span>,<span class="number">255</span>,THRESH_BINARY | THRESH_OTSU);</span><br><span class="line">	imshow(<span class="string">"threshold"</span>, gray);</span><br><span class="line">	<span class="comment">// 轮廓发现</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">	findContours(gray,contours,RETR_LIST,CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 过滤面积</span></span><br><span class="line">		<span class="keyword">double</span> area = contourArea(contours[i]);</span><br><span class="line">		<span class="keyword">if</span> (area &lt; <span class="number">49</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 过滤宽高比和宽高大小</span></span><br><span class="line">		RotatedRect rRect = minAreaRect(contours[i]);</span><br><span class="line">		<span class="keyword">float</span> w = rRect.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line">		<span class="keyword">float</span> h = rRect.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line">		<span class="keyword">float</span> ratio = <span class="built_in">min</span>(w,h) / <span class="built_in">max</span>(w,h);</span><br><span class="line">		<span class="keyword">if</span> (ratio &gt; <span class="number">0.9</span> &amp;&amp; w &lt; gray.cols / <span class="number">2</span> &amp;&amp; h &lt; gray.rows / <span class="number">2</span>)&#123;</span><br><span class="line">			<span class="comment">// 去分析，找到满足宽高比的，满足宽高大小的</span></span><br><span class="line">			Mat qrROI = wrapTransfrom(gray, rRect);</span><br><span class="line">			<span class="keyword">if</span> (isYCorner(qrROI) &amp;&amp; isXCorner(qrROI))&#123;</span><br><span class="line">				drawContours(src, contours, i, Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">4</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	imshow(<span class="string">"dstsrc"</span>,src);</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：22.实时人脸检测</title>
    <url>/70.OpenCV-%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<h1 id="1-相机实时人脸检测"><a href="#1-相机实时人脸检测" class="headerlink" title="1. 相机实时人脸检测"></a>1. 相机实时人脸检测</h1><p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv70" target="_blank" rel="noopener">NDKPractice项目的opencv70</a></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @param 1.1 会采用上采样、下采样、缩放比例</span></span><br><span class="line"><span class="comment">// @param 3 会检测多少次才能判断是个人脸</span></span><br><span class="line"><span class="comment">// @param Size(width/4,height/4) 最小的人脸大小</span></span><br><span class="line"><span class="comment">// @param Size(width,height) 最大的人脸</span></span><br><span class="line">cascadeClassifier.detectMultiScale(gray,faces,<span class="number">1.1</span>,<span class="number">3</span>,<span class="number">0</span>,Size(<span class="built_in">width</span>/<span class="number">4</span>,<span class="built_in">height</span>/<span class="number">4</span>),Size(<span class="built_in">width</span>,<span class="built_in">height</span>));</span><br></pre></td></tr></table></figure>

<h1 id="2-人脸识别相关：-均值，方差与协方差、特征值与特征向量"><a href="#2-人脸识别相关：-均值，方差与协方差、特征值与特征向量" class="headerlink" title="2. 人脸识别相关： 均值，方差与协方差、特征值与特征向量"></a>2. 人脸识别相关： 均值，方差与协方差、特征值与特征向量</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Mat src = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">70</span>);</span><br><span class="line">	<span class="comment">// 平均值 ：(50+50+50+...+70) / 9 = 60;</span></span><br><span class="line">	<span class="comment">// 标准方差（均方差）：各个数据与平均值之差的平方的和的平均数，再开根号</span></span><br><span class="line">	<span class="comment">// ((50-60)的平方 + (50-60)的平方 + (50-60)的平方 + (60-60)的平方... + (70-60)的平方)/9 = 开根号(66.6666666667) = 8.1649658093 </span></span><br><span class="line">	Mat mean, stddev; <span class="comment">// mean 平均值，stddev 标准方差</span></span><br><span class="line">	meanStdDev(src, mean, stddev);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mean &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; stddev &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"========================================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 协方差矩阵</span></span><br><span class="line">	Mat covar;</span><br><span class="line">	calcCovarMatrix(src,covar,mean,COVAR_NORMAL | COVAR_ROWS);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; mean &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; covar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"========================================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 协方差矩阵再去求特征和特征向量</span></span><br><span class="line">	src = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">	Mat eigenvalues, eigenvectors;</span><br><span class="line">	eigen(src, eigenvalues, eigenvectors);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; eigenvalues &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; eigenvectors &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-人脸识别相关：PCA-原理与应用-（降维）"><a href="#3-人脸识别相关：PCA-原理与应用-（降维）" class="headerlink" title="3.人脸识别相关：PCA 原理与应用 （降维）"></a>3.人脸识别相关：PCA 原理与应用 （降维）</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 人脸识别相关：PCA 原理与应用 （降维）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">size</span> = src.rows * src.cols;</span><br><span class="line">	<span class="function">Mat <span class="title">data</span><span class="params">(<span class="built_in">size</span>,<span class="number">3</span>,CV_8UC1)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> row = i / src.cols;</span><br><span class="line">		<span class="keyword">int</span> col = i - row * src.cols;</span><br><span class="line"></span><br><span class="line">		data.at&lt;uchar&gt;(i, <span class="number">0</span>) = src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line">		data.at&lt;uchar&gt;(i, <span class="number">1</span>) = src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line">		data.at&lt;uchar&gt;(i, <span class="number">2</span>) = src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终降维的数据</span></span><br><span class="line">	<span class="function">PCA <span class="title">pca_analyze</span><span class="params">(data, Mat(), PCA::Flags::DATA_AS_ROW)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pca_analyze.mean &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pca_analyze.eigenvalues &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; pca_analyze.eigenvectors &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	waitKey(<span class="number">0</span>);</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：16.封装 java 层 sdk 模型</title>
    <url>/64.OpenCV-%E5%B0%81%E8%A3%85%20java%20%E5%B1%82%20sdk%20%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv64" target="_blank" rel="noopener">NDKPractice项目的opencv64</a></strong></p>
<p>小的需求：<code>优化下Bitmap加载图片的源码（严格控制下内存）</code></p>
<h1 id="1-苏宁体育面试题讲解（一面）"><a href="#1-苏宁体育面试题讲解（一面）" class="headerlink" title="1. 苏宁体育面试题讲解（一面）"></a>1. 苏宁体育面试题讲解（一面）</h1><ul>
<li>HashMap 的实现，如何判断超出了原存储空间，超出了如何扩容，如果存入 key 相同，值如何存入。（之前手写过）</li>
<li>你所了解的设计模式，谈谈你对工厂设计模式的理解，单例设计模式如何避免内存泄露</li>
<li>事件分发机制</li>
<li>二叉树找最大</li>
<li>Activity 的启动模式，几种模式具体的应用。</li>
<li>静态方法存储在哪儿，堆和栈的垃圾回收机制</li>
</ul>
<p>面试考两点：1.<code>基础牢不牢</code>　2.<code>能不能搞定目前的项目</code></p>
<h1 id="2-NDK-学到什么程度"><a href="#2-NDK-学到什么程度" class="headerlink" title="2. NDK 学到什么程度"></a>2. NDK 学到什么程度</h1><p>c/c++ 少不了，基础，进阶，linux内核，shell脚本，cmake语法<br>opencv,ffmpeg<br>android开发：c/c++工程师开发（精通），java 工程师(精通)，native 和 java 层互通 NDK 开发(熟悉c/c++,熟悉android)  </p>
<ul>
<li>知道：有这么个东西，模糊  </li>
<li>熟悉：知道这个东西，讲明白，项目中也能直接用上  </li>
<li>精通：知道这个东西，讲明白，项目中也能直接用，知道原理（四种启动模式，怎么解析，怎么压栈弹栈，声明周期怎么调用）    </li>
</ul>
<p>读：第三方的源码，opencv，ffmpeg,openGL,android native.<br>写：那么多套路    </p>
<p>部门：引擎部门（.so库，java的sdk）有专门的 c/c++ 工程师，android 应用层开发</p>
<h1 id="3-如何封装-java-层-sdk-模型"><a href="#3-如何封装-java-层-sdk-模型" class="headerlink" title="3.如何封装 java 层 sdk 模型"></a>3.如何封装 java 层 sdk 模型</h1><p>假设我对一张图片做操作  </p>
<ul>
<li>掩膜操作</li>
<li>模糊操作</li>
<li>又来一个关于 filter2D 的操作</li>
</ul>
<p>规则考虑周到</p>
<ul>
<li>细节拆分</li>
<li>尽量不要改 native 层的代码，可以改 java 层的（<code>针对上面的需求可以把 filter2D 方法提到 java 层</code>）</li>
<li>思考：时间空间复杂度</li>
</ul>
<h1 id="4-动手封装OpenCV的Mat-java-对象"><a href="#4-动手封装OpenCV的Mat-java-对象" class="headerlink" title="4.动手封装OpenCV的Mat.java 对象"></a>4.动手封装OpenCV的Mat.java 对象</h1><p>filter2D -&gt; Mat  </p>
<p>Java层的Mat.java 对应 native 层的 Mat.cpp  </p>
<p>Java层写 Mat.java -&gt; Bitmap.java, Bitmap.java -&gt; Mat.java</p>
<h1 id="5-NDK异常处理需要注意的地方"><a href="#5-NDK异常处理需要注意的地方" class="headerlink" title="5.NDK异常处理需要注意的地方"></a>5.NDK异常处理需要注意的地方</h1><p>在前面有篇博客讲过 NDK 中的异常处理</p>
<h1 id="6-java和C-的回收机制"><a href="#6-java和C-的回收机制" class="headerlink" title="6.java和C++的回收机制"></a>6.java和C++的回收机制</h1><p>java的 GC 会调用 <code>finalize</code> 方法。</p>
<p>c 中需要自己回收</p>
]]></content>
      <categories>
        <category>OpenCV</category>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：03.linux系统-文档编辑、应用编译运行</title>
    <url>/74.linux%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E3%80%81%E5%BA%94%E7%94%A8%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<p>注意：<code>未做说明以下都是在命令模式下进行</code></p>
<p>编辑过程中遇到的问题：</p>
<p>误按了：<code>ctrl + z</code> ： 可以将一个正在前台执行的命令放到后台，并且暂停</p>
<p>再次打开就变成了以下这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">E325: 注意</span><br><span class="line">发现交换文件 &quot;.t.txt.swp&quot;</span><br><span class="line">            所有者: root    日期: Sun Aug 25 23:27:33 2019</span><br><span class="line">            文件名: ~root&#x2F;test&#x2F;t.txt</span><br><span class="line">            修改过: 否</span><br><span class="line">            用户名: root      主机名: master</span><br><span class="line">           进程 ID: 4803 (仍在运行)</span><br><span class="line">正在打开文件 &quot;t.txt&quot;</span><br><span class="line">              日期: Sun Aug 25 22:17:30 2019</span><br><span class="line"></span><br><span class="line">(1) Another program may be editing the same file.  If this is the case,</span><br><span class="line">    be careful not to end up with two different instances of the same</span><br><span class="line">    file when making changes.  Quit, or continue with caution.</span><br><span class="line">(2) An edit session for this file crashed.</span><br><span class="line">    如果是这样，请用 &quot;:recover&quot; 或 &quot;vim -r t.txt&quot;</span><br><span class="line">    恢复修改的内容 (请见 &quot;:help recovery&quot;)。</span><br><span class="line">    如果你已经进行了恢复，请删除交换文件 &quot;.t.txt.swp&quot;</span><br><span class="line">    以避免再看到此消息。</span><br><span class="line"></span><br><span class="line">交换文件 &quot;.t.txt.swp&quot; 已存在！</span><br><span class="line">以只读方式打开([O]), 直接编辑((E)), 恢复((R)), 退出((Q)), 中止((A)):</span><br></pre></td></tr></table></figure>

<p>解决办法：</p>
<p>使用 <code>fg</code> :将后台中的命令调至前台继续运行</p>
<h1 id="1-vim-工作模式"><a href="#1-vim-工作模式" class="headerlink" title="1. vim 工作模式"></a>1. vim 工作模式</h1><p><img src="/images/74.vim%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt></p>
<ul>
<li><code>gcc hello.c -o a</code>：编译成可执行文件 <code>a</code></li>
<li><code>./a</code>：运行可执行文件 a</li>
</ul>
<h1 id="2-vim-命令模式进入输入模式的快捷键"><a href="#2-vim-命令模式进入输入模式的快捷键" class="headerlink" title="2 vim 命令模式进入输入模式的快捷键"></a>2 vim 命令模式进入输入模式的快捷键</h1><ul>
<li><p><code>i</code>: 输入,光标前面</p>
</li>
<li><p><code>I</code>: 输入,光标前面</p>
</li>
<li><p><code>a</code>: 输入,光标会逻动一个位置</p>
</li>
<li><p><code>A</code>:输入,光标会逻动到最后</p>
</li>
<li><p><code>o</code>:输入,光标会逻动到下一行</p>
</li>
<li><p><code>O</code>:输入,光标会逻动到上一行</p>
</li>
<li><p><code>s</code>:输入,会删除光标所在字符</p>
</li>
<li><p><code>S</code>: 输入,会删除光标所在行</p>
</li>
<li><p><code>h</code>: 向左移动光标</p>
</li>
<li><p><code>l</code>: 向右移动光标</p>
</li>
<li><p><code>j</code>: 向下移动光标</p>
</li>
<li><p><code>k</code>: 向上移动光标</p>
</li>
</ul>
<h2 id="2-1-跳转和删除"><a href="#2-1-跳转和删除" class="headerlink" title="2.1.跳转和删除"></a>2.1.跳转和删除</h2><ul>
<li><p><code>5G</code>：跳转到第 5 行</p>
</li>
<li><p><code>5回车</code>或者<code>G</code>：跳转到末行行首</p>
</li>
<li><p><code>gg</code>: 跳转到首行行首</p>
</li>
<li><p><code>$</code>: 跳转到当行行尾</p>
</li>
<li><p><code>0</code>: 跳转到当行行首</p>
</li>
<li><p><code>gg=G</code>: 格式化代码</p>
</li>
<li><p><code>dw</code>：删除单词从光标到单词结束的地方</p>
</li>
<li><p><code>x</code>: 删除某个字母</p>
</li>
<li><p><code>d0</code>: 删除光标至行首</p>
</li>
<li><p><code>v+h/j/k/l+d</code> 或者 <code>v+上/下/左/右+d</code>：删除选中区域</p>
</li>
<li><p><code>dd</code>: 剪切整行，可以当删除</p>
</li>
<li><p><code>3dd</code>: 从当前行剪切 3 行，可以当删除</p>
</li>
</ul>
<h2 id="2-2-复制、粘贴"><a href="#2-2-复制、粘贴" class="headerlink" title="2.2. 复制、粘贴"></a>2.2. 复制、粘贴</h2><ul>
<li><code>yy</code>: 复制当前行</li>
<li><code>3yy</code>: 从当前行复制 3 行</li>
<li><code>p</code>: 粘贴到当前行的<code>下一行</code></li>
<li><code>P</code>: 粘贴到当前行的<code>上一行</code></li>
<li><code>dd</code>: 剪切整行</li>
<li><code>3dd</code>: 从当前行剪切 3 行</li>
</ul>
<h2 id="2-3-查找替换"><a href="#2-3-查找替换" class="headerlink" title="2.3 查找替换"></a>2.3 查找替换</h2><ul>
<li><code>/ + &#39;要查找的内容&#39; +回车</code>:  查找 , ‘*’或‘n’ 跳转到下一个， ‘N’ 是查看上一个</li>
<li><code>r + &#39;要替换的字符&#39;</code>：把当前光标字符替换成 ‘要替换的字符’</li>
<li><code>:s /printf/println</code> : 将当前光标所在行中的<code>第一个</code>printf替换成println</li>
<li><code>:%s /printf/println</code> : 将每一行中的<code>第一个</code>printf替换成println</li>
<li><code>:s /printf/println/g</code> ：将这一行的所有printf替换成println</li>
<li><code>:%s /printf/println/g</code> : 将所有地方的printf替换成println</li>
<li><code>:1,3s /printf/println/g</code>: 将1-3行的所有printf替换成println</li>
</ul>
<h2 id="2-4-其它命令"><a href="#2-4-其它命令" class="headerlink" title="2.4.其它命令"></a>2.4.其它命令</h2><ul>
<li><code>u</code>: 撤销</li>
<li><code>ctrl+r</code>: 反撤销</li>
<li><code>:sp</code>: 上下分屏</li>
<li><code>:vsp</code>: 左右分屏</li>
<li><code>ctrl + ww</code> : 切换分屏</li>
<li><code>wqall</code>: 保存退出所有</li>
<li><code>3+K或2+K</code>: 跳转到光标所指向的函数声明</li>
</ul>
<h1 id="3-gcc-编译的四个步骤"><a href="#3-gcc-编译的四个步骤" class="headerlink" title="3. gcc 编译的四个步骤"></a>3. gcc 编译的四个步骤</h1><p>.c 文件 -&gt; 可执行文件，经历了四个步骤</p>
<h2 id="3-1-预处理阶段"><a href="#3-1-预处理阶段" class="headerlink" title="3.1 预处理阶段"></a>3.1 预处理阶段</h2><p><code>将所有的宏定义的替换，类似于 java 的 final</code>,展开include的文件 </p>
<p><code>gcc -E -o hello.i hello.c</code>: 将 hello.c 文件预处理成 hello.i 文件</p>
<h2 id="3-2-预编译阶段"><a href="#3-2-预编译阶段" class="headerlink" title="3.2 预编译阶段"></a>3.2 预编译阶段</h2><p>在这个阶段，GCC 才会去检测你代码的规范性，语法是否有错误，gcc 会把代码翻译成汇编</p>
<p><code>gcc -S -o hello.s hello.i</code>:将 hello.i 文件预编译成 hello.i 文件</p>
<h2 id="3-3-汇编阶段"><a href="#3-3-汇编阶段" class="headerlink" title="3.3 汇编阶段"></a>3.3 汇编阶段</h2><p>把 .s 文件翻译成二进制.o文件（机器的指令）,文本打开的是乱码</p>
<p><code>gcc -c -o hello.o hello.s</code>:将 hello.s 汇编成 hello.o 文件</p>
<h3 id="3-4-链接阶段"><a href="#3-4-链接阶段" class="headerlink" title="3.4 链接阶段"></a>3.4 链接阶段</h3><p>计算逻辑地址，合并数据段，有些函数是在另外一个 so 库文件中的。</p>
<p><code>gcc -o hello hello.o</code>：这个时候就可以执行<code>hello</code>了</p>
<h1 id="4-动态库和静态库"><a href="#4-动态库和静态库" class="headerlink" title="4.动态库和静态库"></a>4.动态库和静态库</h1><p><code>静态库</code>：其实是内容的拷贝(代码)，运行阶段<code>没有 .a 文件</code>了也是可以执行的。<br><code>动态库</code>：不会拷贝内容，运行阶段起的作用（加载），生成 so 的时候要生成与位置无关的代码，没有 so 不能运行。</p>
<h2 id="4-1-静态库的生成"><a href="#4-1-静态库的生成" class="headerlink" title="4.1 静态库的生成:"></a>4.1 静态库的生成:</h2><h3 id="4-1-1-将-c-生成-o"><a href="#4-1-1-将-c-生成-o" class="headerlink" title="4.1.1 将 c 生成 .o"></a>4.1.1 将 c 生成 .o</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -c add.c -o add.o  <span class="comment">// 将 add.c 文件输出为 .o文件</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-使用-ar-工具制作静态库"><a href="#4-1-2-使用-ar-工具制作静态库" class="headerlink" title="4.1.2. 使用 ar 工具制作静态库"></a>4.1.2. 使用 ar 工具制作静态库</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ar rcs libmath.a add.o xxx.o <span class="comment">// 将 add.o 和 xxx.o 文件制作到 libmath.a 中</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-编译静态库到可执行文件"><a href="#4-1-3-编译静态库到可执行文件" class="headerlink" title="4.1.3. 编译静态库到可执行文件"></a>4.1.3. 编译静态库到可执行文件</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc a.c libmath.a -o hello <span class="comment">// 将 a.c 和 libmath.a 输出到可执行文件 hello 中</span></span><br></pre></td></tr></table></figure>


<h2 id="4-2-动态库生成"><a href="#4-2-动态库生成" class="headerlink" title="4.2 动态库生成"></a>4.2 动态库生成</h2><h3 id="4-2-1-将-c-生成-o-（要生成与位置无关的代码）"><a href="#4-2-1-将-c-生成-o-（要生成与位置无关的代码）" class="headerlink" title="4.2.1 将 c 生成 .o （要生成与位置无关的代码）"></a>4.2.1 将 c 生成 .o （要生成与位置无关的代码）</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -c add.c -o add.o -fPIC  <span class="comment">// // 将 add.c 文件输出为 .o文件 要加 -fPIC</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-使用-gcc-shared-制作动态库"><a href="#4-2-2-使用-gcc-shared-制作动态库" class="headerlink" title="4.2.2 使用 gcc -shared 制作动态库"></a>4.2.2 使用 gcc -shared 制作动态库</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc -shared -o libmath.so add.o xxx.o <span class="comment">// // 将 add.o 和 xxx.o 文件制作到 libmath.so 中</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-编译动态库到可执行文件，需要指定动态库的名称-l-指定库路径-L"><a href="#4-2-3-编译动态库到可执行文件，需要指定动态库的名称-l-指定库路径-L" class="headerlink" title="4.2.3 编译动态库到可执行文件，需要指定动态库的名称 -l , 指定库路径 -L"></a>4.2.3 编译动态库到可执行文件，需要指定动态库的名称 -l , 指定库路径 -L</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">gcc a.c -o a -lmath -L./   <span class="comment">// libmath.so 要写成math， ./ 代表当前文件夹</span></span><br></pre></td></tr></table></figure>

<h1 id="5-虚拟内存与物理内存"><a href="#5-虚拟内存与物理内存" class="headerlink" title="5.虚拟内存与物理内存"></a>5.虚拟内存与物理内存</h1><p><code>虚拟内存</code> 是为了缓解<code>物理内存</code>的压力而创建的，他们之间是通过<code>映射</code>来进行的联系</p>
<p>每个进程都有4G的虚拟地址空间，其中3G用户空间，1G内核空间（linux），每个进程共享内核空间，独立的用户空间：</p>
<p><img src="/images/74.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE.png" alt></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：21.人脸识别 - HOG 和 LBP 特征检测</title>
    <url>/69.OpenCV-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%20-%20HOG%20%E5%92%8C%20LBP%20%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv69" target="_blank" rel="noopener">NDKPractice项目的opencv69</a></strong></p>
<p>人脸检测分为以下几步</p>
<ol>
<li>特征提取：边缘，角点，点，线，平坦区</li>
<li>训练样本：正向样，负向样本 （xml文件）</li>
<li>特征匹配：DDM , detection (发现)  description (描述)  matching (匹配) </li>
</ol>
<h1 id="1-HOG-Histogram-of-Oriented-Gradient-特征检测的实现原理"><a href="#1-HOG-Histogram-of-Oriented-Gradient-特征检测的实现原理" class="headerlink" title="1. HOG(Histogram of Oriented Gradient) 特征检测的实现原理"></a>1. HOG(Histogram of Oriented Gradient) 特征检测的实现原理</h1><p><img src="/images/69.hog%E7%89%B9%E5%BE%81.png" alt><br><img src="/images/69.hog%E5%88%86%E7%BD%91%E6%A0%BC%E7%9A%84%E6%A2%AF%E5%BA%A6%E6%96%B9%E5%90%91%E7%9B%B4%E6%96%B9%E5%9B%BE.png" alt><br><img src="/images/69.hog%E5%9D%97%E6%8F%8F%E8%BF%B0%E5%AD%90.png" alt></p>
<p>HOG特征提取流程可分为5个部分：检测窗口、归一化图像、计算梯度、统计直方图、梯度直方图归一化、得到HOG特征向量，以下介绍下检测窗口</p>
<h2 id="1-1-检测窗口："><a href="#1-1-检测窗口：" class="headerlink" title="1.1 检测窗口："></a>1.1 检测窗口：</h2><p>HOG通过窗口（window)和块(block)将图像进行分割。通过以细胞(cell)为单位，对图像某一区域的像素值进行数学计算处理。在此先介绍窗口(window)、块(block)和细胞（cell）的概念及之间的联系。</p>
<ul>
<li>窗口(window)：将图像按一定大小分割成多个相同的窗口，滑动。</li>
<li>块（block)：将每个窗口按一定大小分割成多个相同的块，滑动。</li>
<li>细胞（cell)：将每个窗口按一定大小分割成多个相同的细胞，属于特征提取的单元，静止不动。</li>
<li>图像(image)-&gt;检测窗口(win)-&gt;图像块(block)-&gt;细胞单元(cell)</li>
</ul>
<p><img src="/images/69.hog%E6%A3%80%E6%B5%8B%E7%AA%97%E5%8F%A3.jpg" alt></p>
<h1 id="2-实现行人检测"><a href="#2-实现行人检测" class="headerlink" title="2. 实现行人检测"></a>2. 实现行人检测</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现行人检测</span></span><br><span class="line"><span class="comment">// 训练样本，直接拿过来用</span></span><br><span class="line">Mat bgr; <span class="comment">// 只能用 bgr 格式的</span></span><br><span class="line">cvtColor(src,bgr,COLOR_BGRA2BGR);</span><br><span class="line">HOGDescriptor descriptor;</span><br><span class="line">descriptor.setSVMDetector(descriptor.getDefaultPeopleDetector());</span><br><span class="line"><span class="built_in">vector</span>&lt;Rect&gt; foundLocations;</span><br><span class="line">descriptor.detectMultiScale(bgr,foundLocations,<span class="number">0</span>,Size(<span class="number">12</span>,<span class="number">12</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; foundLocations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    rectangle(src,foundLocations[i],Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>,LINE_AA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-LBP-（Local-Binary-Patterns）特征介绍"><a href="#3-LBP-（Local-Binary-Patterns）特征介绍" class="headerlink" title="3.LBP （Local Binary Patterns）特征介绍"></a>3.LBP （Local Binary Patterns）特征介绍</h1><p><img src="/images/69.lbp.%E7%89%B9%E5%BE%81.png" alt><br><img src="/images/69.lbp%E8%A1%A8%E8%BE%BE.png" alt></p>
<h1 id="4-手写-LBP-特征算法实现"><a href="#4-手写-LBP-特征算法实现" class="headerlink" title="4.手写 LBP 特征算法实现"></a>4.手写 LBP 特征算法实现</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv69_MainActivity_lbpBitmap(JNIEnv *env, jobject thiz, jobject bitmap) &#123;</span><br><span class="line">    <span class="comment">// 自己手写 两套 3*3 考虑步长和角度</span></span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env,bitmap,src);</span><br><span class="line">    Mat gray;</span><br><span class="line">    cvtColor(src,gray,COLOR_BGRA2GRAY);</span><br><span class="line">    <span class="comment">// 3*3 lbp 计算的特征数据</span></span><br><span class="line">    Mat result = Mat::zeros(Size(src.cols - <span class="number">2</span>,src.rows - <span class="number">2</span>),CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有点类似卷积操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; gray.rows - <span class="number">1</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; gray.cols - <span class="number">1</span>; ++col) &#123;</span><br><span class="line">            uchar pixels = gray.at&lt;uchar&gt;(row,col); <span class="comment">// 中心点</span></span><br><span class="line">            <span class="keyword">int</span> rPixels = <span class="number">0</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row<span class="number">-1</span>,col<span class="number">-1</span>)) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row<span class="number">-1</span>,col)) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row<span class="number">-1</span>,col+<span class="number">1</span>)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row,col<span class="number">-1</span>)) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row,col+<span class="number">1</span>)) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row+<span class="number">1</span>,col<span class="number">-1</span>)) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row+<span class="number">1</span>,col)) &lt;&lt; <span class="number">5</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row+<span class="number">1</span>,col+<span class="number">1</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            result.at&lt;uchar&gt;(row<span class="number">-1</span>,col<span class="number">-1</span>) = rPixels;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jobject  resBitmap = cv_helper::createBitmap(env,result.cols,result.rows,src.type());</span><br><span class="line">    cv_helper::mat2bitmap(env,result,resBitmap);</span><br><span class="line">    <span class="keyword">return</span> resBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-haar-特征介绍"><a href="#5-haar-特征介绍" class="headerlink" title="5.haar 特征介绍"></a>5.haar 特征介绍</h1><p><img src="/images/69.Haar%E7%89%B9%E5%BE%81.png" alt></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：04.linux系统-内核编程，文件IO与文件描述符</title>
    <url>/75.linux%E7%B3%BB%E7%BB%9F-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%87%E4%BB%B6IO%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="1-系统内核调用"><a href="#1-系统内核调用" class="headerlink" title="1. 系统内核调用"></a>1. 系统内核调用</h1><p>3-4G 是系统的空间（<code>内核空间</code>），这部分是由操作系统来管理，那么如果我们要操作这部分数据，只能借助系统提供的一些函数（系统函数），用户调用这些函数就称之为系统调用。</p>
<p><img src="/images/75.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt></p>
<h1 id="2-普通函数与内核函数"><a href="#2-普通函数与内核函数" class="headerlink" title="2.普通函数与内核函数"></a>2.普通函数与内核函数</h1><p>系统函数：<code>open , close , write , read</code></p>
<p><code>man 2 ‘系统函数’</code>：查看系统函数<br><code>man 3 ‘普通函数’</code>：查看系统函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; open</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">pathname : 文件的路径  </span><br><span class="line">flags : O_APPEND 追加，O_CREAT 没有的时候会创建，O_TRUNC 会截断（清空文件）  </span><br><span class="line">mode：就是创建时的文件权限 ， 只是当前用户可读可写，S_IRUSR|S_IWUSR  </span><br><span class="line">返回的是一个文件句柄 fd , 我们直接通过 fd 去做操作  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int close(int fd); 关闭文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  read</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">fd：文件句柄</span><br><span class="line">void *buf：读入的缓冲区</span><br><span class="line">count：每次读多少字节数</span><br><span class="line">ssize_t ：返回的是读到真实个数</span><br><span class="line"></span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">fd：文件句柄</span><br><span class="line">void *buf：写入的缓冲区</span><br><span class="line">count：每次写入的字节数</span><br><span class="line">ssize_t ：返回的是写入真实个数</span><br></pre></td></tr></table></figure>

<p>文件操作的错误怎么提示？会有一个宏定义 errno  , 通过 strerror(errno) 获取错误信息，需要打印错误快捷的方式 perror<br>void perror(const char *s); s 代表的是错误信息的描述 s: strerror(errno)</p>
<p>普通函数：<code>fopen，fclose ， fread/fputc ，fwrite/fgetc</code></p>
<h1 id="3-普通函数和系统函数拷贝文件的区别"><a href="#3-普通函数和系统函数拷贝文件的区别" class="headerlink" title="3.普通函数和系统函数拷贝文件的区别"></a>3.普通函数和系统函数拷贝文件的区别</h1><p>fputc 和 fgetc 内部是封装了 read , wirte , 如果拷贝文件，速度区别如下：</p>
<ul>
<li>系统函数每次只读取一个 Byte，速度很慢</li>
<li>普通函数每次读取 4096 个 byte，所以很快</li>
</ul>
<p>Java write 数据，需要 flush 的原理一样，数据还在缓冲区(数据不会自动发送出去)，需要flush一起给到内核空间，在内核空间中调用 write.</p>
<p><img src="/images/75.%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0.png" alt></p>
<h1 id="4-文件描述符（文件句柄）"><a href="#4-文件描述符（文件句柄）" class="headerlink" title="4.文件描述符（文件句柄）"></a>4.文件描述符（文件句柄）</h1><p><img src="/images/75.%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt></p>
<h1 id="5-lseek-与-fseek"><a href="#5-lseek-与-fseek" class="headerlink" title="5.lseek 与 fseek"></a>5.lseek 与 fseek</h1><p>用来获取偏移量 SEEK_SET , SEEK_END, SEEK_CUR<br>lseek 他的偏移量，读和写是同一个</p>
<h1 id="6-stat-和-lstat"><a href="#6-stat-和-lstat" class="headerlink" title="6.stat 和 lstat"></a>6.stat 和 lstat</h1><p>Inode: 370887 ， 文件的权限，盘符的位置。<br>硬链接计数就充分的利用了 inode<br>硬链接：文件快捷键<br>软链接：类似于文件的快捷键，但是你操作任何一个都会被改变  </p>
<p>软连接和硬链接的特点：</p>
<p>软链接：</p>
<ul>
<li>软链接是存放另一个文件的路径的形式存在。</li>
<li>软链接可以 跨文件系统 ，硬链接不可以。</li>
<li>软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。</li>
<li>软链接可以对目录进行链接。</li>
</ul>
<p>硬链接：</p>
<ul>
<li>硬链接，以文件副本的形式存在。但不占用实际空间。</li>
<li>不允许给目录创建硬链接。</li>
<li>硬链接只有在同一个文件系统中才能创建。</li>
<li>删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。</li>
</ul>
<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int stat(const char *pathname, struct stat *buf);</span><br><span class="line">pathname：文件路径</span><br><span class="line"></span><br><span class="line">struct stat *buf：stat 结构体指针</span><br><span class="line"></span><br><span class="line">作业：stat 获取文件的属性，获取文件的大小就可以</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stat 和 lstat 有什么区别？stat 是会穿透的，lstat 不会穿透，穿透软连接</span><br><span class="line"></span><br><span class="line">ln -s f_read_write f_read_write.soft ： 创建软连接</span><br></pre></td></tr></table></figure>

<h1 id="7-目录操作"><a href="#7-目录操作" class="headerlink" title="7.目录操作"></a>7.目录操作</h1><p>递归操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName)</span></span>&#123;</span><br><span class="line">    <span class="comment">// int stat(const char *pathname,struct stat *buf);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>* <span class="title">buf</span>;</span> <span class="comment">// 作为传入参数</span></span><br><span class="line">    stat(fileName,&amp;buf);</span><br><span class="line">    <span class="keyword">mode_t</span> st_mode = buf.st_mode;</span><br><span class="line">    <span class="keyword">return</span> S_ISDIR(st_mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR *dir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open dir fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct dirent *readdir(DIR *dirp);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    <span class="keyword">while</span>((dirp = readdir(dir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// printf("%s\t",dirp-&gt;d_name);</span></span><br><span class="line">        <span class="comment">// 一个递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：05.linux系统-进程创建和进程管理</title>
    <url>/76.linux%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-pcb-process-control-block-进程控制块"><a href="#1-pcb-process-control-block-进程控制块" class="headerlink" title="1.pcb(process control block)进程控制块"></a>1.pcb(process control block)进程控制块</h1><p>结构体的路径：<code>~/usr/src/linux-headers-3.5.0-23/include/linux/sched.h</code></p>
<p>结构体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">        &#x2F;&#x2F; ......</span><br><span class="line"></span><br><span class="line">        进程 id</span><br><span class="line"></span><br><span class="line">        文件描述符</span><br><span class="line"></span><br><span class="line">        进程的状态：初始态，就绪态，运行态，挂起态，终止态</span><br><span class="line"></span><br><span class="line">        进程工作目录</span><br><span class="line"></span><br><span class="line">        信号相关信息资源</span><br><span class="line"></span><br><span class="line">        用户id组id</span><br><span class="line"></span><br><span class="line">        进程工作目录</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-内存映射（重点）"><a href="#2-内存映射（重点）" class="headerlink" title="2.内存映射（重点）"></a><strong><font color="red">2.内存映射（重点）</font></strong></h1><p>由于应用程序不能直接操作设备硬件地址，所以操作系统提供了这样的一种机制——内存映射，把设备地址映射到进程虚拟地址，<code>mmap</code>就是实现内存映射的接口。</p>
<p><code>mmap</code>的好处是，mmap<code>把设备内存映射到虚拟内存，则用户操作虚拟内存相当于直接操作设备了，省去了用户空间到内核空间的复制过程，相对IO操作来说，增加了数据的吞吐量</code>。</p>
<p>用户空间映射时，会映射到不同的区域，内核空间映射时，会映射到同一区域的不同地方（共享！！）</p>
<p>每个进程都有4G的虚拟地址空间，其中3G用户空间，1G内核空间（linux），每个进程共享内核空间，独立的用户空间</p>
<p><img src="/images/76.%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.png" alt></p>
<h1 id="3-fork-创建子进程（重点）"><a href="#3-fork-创建子进程（重点）" class="headerlink" title="3.fork 创建子进程（重点）"></a><strong><font color="red">3.fork 创建子进程（重点）</font></strong></h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc.<span class="keyword">const</span>  <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process!,pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent,cpid = %d,pid = %d,ppid = %d"</span> ,pid,getpid(),getppid());</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/76.fork%E5%87%BD%E6%95%B0.png" alt></p>
<h1 id="4-父子进程共享（重点）"><a href="#4-父子进程共享（重点）" class="headerlink" title="4.父子进程共享（重点）"></a><strong><font color="red">4.父子进程共享（重点）</font></strong></h1><h2 id="4-1-父子进程相同："><a href="#4-1-父子进程相同：" class="headerlink" title="4.1 父子进程相同："></a>4.1 父子进程相同：</h2><p>刚 fork 后，data 段，text 段，堆，栈，环境变量，全局变量，进程工作目录，信号处理方式。（0-3G 部分是共享的）</p>
<h2 id="4-2-父子进程不同的："><a href="#4-2-父子进程不同的：" class="headerlink" title="4.2 父子进程不同的："></a>4.2 父子进程不同的：</h2><p>进程 id ，返回值，各自的父进程，进程创建时间，闹钟，未决信号集 </p>
<h2 id="4-3-父子进程共享："><a href="#4-3-父子进程共享：" class="headerlink" title="4.3 父子进程共享："></a>4.3 父子进程共享：</h2><p>map 映射区，读时共享，写时复制。</p>
<h1 id="5-进程回收"><a href="#5-进程回收" class="headerlink" title="5. 进程回收"></a>5. 进程回收</h1><p>回收的就是残留在内核中的 3-4G 的数据（pcb 进程控制块）</p>
<ul>
<li>孤儿进程：父进程先于子进程结束，则子进程会成为孤儿进程，子进程的父进程成为 init 进程，有 init 进程（进程孤儿院）来回收进程。</li>
<li>僵尸进程：子进程结束，父进程尚未回收，该子进程会变成僵尸进程</li>
</ul>
<p>wait, waitpid<br>wait功能：</p>
<ol>
<li>阻塞等待子线程退出</li>
<li>回收子进程残留的资源</li>
<li>获取子进程退出的状态（怎么死掉的）</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> state;</span><br><span class="line">wait(&amp;state);</span><br></pre></td></tr></table></figure>

<h1 id="6-监听-APP-应用被卸载"><a href="#6-监听-APP-应用被卸载" class="headerlink" title="6.监听 APP 应用被卸载"></a>6.监听 APP 应用被卸载</h1><ol>
<li>fork 一个子进程</li>
<li>监听文件是否被删除了，data/data/xxx包名</li>
<li>execl 函数族去执行某些命令（打开浏览器收集用户反馈）  </li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以执行自己写好的程序，path 是路径，arg 是可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行系统的命令程序，file 是命令的名称，arg 是可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p> <font color="red">execl 不会走 fork 之后的 text 代码段，而是会去执行 exec 函数族的命令或者程序</font></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc.<span class="keyword">const</span>  <span class="keyword">char</span>* argv[])</span></span>&#123; <span class="comment">// 获取 参数 -l ，[1]才是，[0]是程序本身</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process!,pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">        execl(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>); <span class="comment">// NULL 代表可变参数的结尾</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent,cpid = %d,pid = %d,ppid = %d"</span> ,pid,getpid(),getppid());</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：06.linux系统-IPC进程间通信</title>
    <url>/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h1 id="1-进程间通信的方式"><a href="#1-进程间通信的方式" class="headerlink" title="1.进程间通信的方式"></a>1.进程间通信的方式</h1><p>文件，管道，信号、信号量，共享映射区（共享内存），消息队列，管道，套接字（socket）</p>
<p>着重讲下：</p>
<ul>
<li>管道（使用简单）</li>
<li>信号（开销比较小）</li>
<li><font color="red">共享映射区</font></li>
<li>套接字（低速稳定）</li>
</ul>
<p>一般都是通过内核共享空间进行通信</p>
<p><img src="/images/77.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt></p>
<h1 id="2-管道-pipe"><a href="#2-管道-pipe" class="headerlink" title="2.管道(pipe)"></a>2.管道(pipe)</h1><p><img src="/images/77.%E7%AE%A1%E9%81%93.png" alt><br><img src="/images/77.%E7%AE%A1%E9%81%93%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png" alt></p>
<ol>
<li>无名管道，<font color="red">半双工的通信方式(数据流向固定：只能 a 的数据写给 b ，或者 b 的数据写给 a )</font></li>
<li>管道大家可以简单的理解为一种特殊的文件形式，我们可以用文件的读写方法，不是一种简单的文件，只会占用内存。</li>
<li>管道只能是有血缘关系的进程间通信</li>
<li>数据不能自己写自己读</li>
<li>数据一旦读走，不能再次读</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pipe error!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="comment">// 等等在读</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 没有其它读写操作了可以关闭 fd[0]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe read : %s"</span>,buf);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello pipe\n"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 没有其它读写操作了可以关闭 fd[1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非法操作：</p>
<ol>
<li><p>读管道：<br> 1.1 管道中有数据，read 返回实际读到的数据</p>
<p> 1.2 管道中无数据：    </p>
<pre><code>1.2.1 管道写端被关闭，read 返回 0

1.2.2 管道写端如果没有被关闭，会阻塞等待</code></pre></li>
<li><p>写管道：<br> 2.1 读端被关闭，异常终止（信号导致）</p>
<p> 2.2 读端未关闭：</p>
<pre><code>2.2.1 管道数据已满，阻塞等待写入数据（其他人读走）

2.2.2 管道未满，直接将数据写入</code></pre></li>
</ol>
<h1 id="3-共享映射区"><a href="#3-共享映射区" class="headerlink" title="3.共享映射区"></a><font color="red">3.共享映射区</font></h1><p><img src="/images/77.mmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt></p>
<p>binder 驱动，腾讯 MMKV，xlog （日志库）中都会有 <code>mmap</code>函数</p>
<p>以下是binder驱动的流程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、注册建立ServiceManager表。</span><br><span class="line">2、Service1、Service2通过Binder驱动申请注册到ServiceManager中。</span><br><span class="line">3、Client需要与Service2进行通信,跨进程无法直接通信，需要先通过ServiceManger中查询到Service2。借助Binder驱动</span><br><span class="line">返回一个Service2的代理对象。Client直接跟Service2代理对象进行操作，通过Binder驱动映射操作Service2真实对象，从而完成通信。</span><br><span class="line"></span><br><span class="line">- Binder是一种通信机制；</span><br><span class="line">- 对于Service来说Binder指的是Binder本地对象，对于Client来说Binder指的是Binder的代理对象；</span><br><span class="line">- 对于传输过程而言，Binder是可以跨进程传递的对象。</span><br><span class="line"></span><br><span class="line">为什么要使用Binder？</span><br><span class="line">性能方面</span><br><span class="line"></span><br><span class="line">在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，</span><br><span class="line">更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</span><br><span class="line"></span><br><span class="line">安全方面</span><br><span class="line"></span><br><span class="line">传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协</span><br><span class="line">议本身就支持对通信双方做身份校检，因而大大提升了安全性。</span><br></pre></td></tr></table></figure>


<p>mmap 注意事项  </p>
<ol>
<li>指定映射区的大小，必须要小于文件大小</li>
<li>映射区大小必须要大于 0 ，否则会异常</li>
<li>创建映射区需要 read 权限，mmap 的读写权限应该 &lt;= 文件的权限</li>
<li>文件可以先关闭</li>
<li>偏移量必须是 4k 的整数倍</li>
<li>MAP_PRIVATE 只会对内存进行修改，不会反应到磁盘上</li>
</ol>
<p>mmap 万能调用方法：<br>open(O_RDWR);<br>mmap(NULL, 有效大小，PROT_READ|PROT_WRITE,MAP_SHARED,fd,0)  </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * msg)</span></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line"><span class="comment">              int fd, off_t offset);</span></span><br><span class="line"><span class="comment">   int munmap(void *addr, size_t length);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  addr：地址，一般可以不传（NULL），传入传出参数</span></span><br><span class="line"><span class="comment">     *  length：内存大小</span></span><br><span class="line"><span class="comment">     *  prot：</span></span><br><span class="line"><span class="comment">     *       PROT_EXEC 内容可以被执行</span></span><br><span class="line"><span class="comment">     *       PROT_READ 内容可以被读取</span></span><br><span class="line"><span class="comment">     *       PROT_WRITE 内容可以被写</span></span><br><span class="line"><span class="comment">     *       PROT_NONE 内容不可访问</span></span><br><span class="line"><span class="comment">     *  flags:</span></span><br><span class="line"><span class="comment">     *       MAP_SHARED 共享</span></span><br><span class="line"><span class="comment">     *       MAP_PRIVATE 私有f</span></span><br><span class="line"><span class="comment">     *       MAP_ANONYMOUS 匿名映射（不基于文件）,fd 参数就传 -1</span></span><br><span class="line"><span class="comment">     *  fd: 文件句柄</span></span><br><span class="line"><span class="comment">     *  offset：偏移大小，必须是 4K 的整数倍，一个物理页映射是 4K。     </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建打开一个文件</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test_map"</span>,O_ROWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">"open file error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件变大（不增大的话，映射的是 0）</span></span><br><span class="line">    ftruncate(fd,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>,<span class="number">20</span>, PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭了文件，那么后面通过操作 mmap 的空间，能不能写入文件? 能</span></span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">// 关闭的是系统函数到文件的操作，而 mmap 映射不受影响</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"hello mmap\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---&gt;%s"</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放 mmap</span></span><br><span class="line">    munmap(p,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有示例请可以看<a href="https://github.com/EastUp/CPractice/tree/master/linux/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">这儿</a></p>
<h1 id="4-信号"><a href="#4-信号" class="headerlink" title="4.信号"></a>4.信号</h1><p>进程间通信的机制，内核自带的，信号不能携带大量的数据，一般就是一个数字，只有在特定场景下才调用。</p>
<p>怎样才会产生信号：</p>
<ol>
<li>按键产生: ctrl + c, ctrl+z</li>
<li>系统调用 kill ， raise， abort</li>
<li>软件条件产生， alarm</li>
<li>硬件异常产生，非法访问内存，除 0 ，内存对齐等等</li>
<li>命令产生</li>
</ol>
<p>信号的处理方式：</p>
<ol>
<li>忽略此信号</li>
<li>执行系统默认动作</li>
<li>捕捉用户希望动作</li>
</ol>
<p>信号处理的原理：  </p>
<ul>
<li>信号屏蔽字: 用于屏蔽x信号，内部实现就是一个集合，当 x 信号屏蔽后，再收到该信号，信号处理将推后</li>
<li>未决信号集: 信号抵达 x 信号位反转为 1 ， 当信号被处理后重新置为 0 </li>
</ul>
<p><code>man 7 signal</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">       Signal     Value     Action   Comment</span><br><span class="line">       ──────────────────────────────────────────────────────────────────────</span><br><span class="line">       SIGHUP        1       Term    Hangup detected on controlling terminal</span><br><span class="line">                                     or death of controlling process</span><br><span class="line">       SIGINT        2       Term    Interrupt from keyboard</span><br><span class="line">       SIGQUIT       3       Core    Quit from keyboard</span><br><span class="line">       SIGILL        4       Core    Illegal Instruction</span><br><span class="line">       SIGABRT       6       Core    Abort signal from abort(3)</span><br><span class="line">       SIGFPE        8       Core    Floating point exception</span><br><span class="line">       SIGKILL       9       Term    Kill signal</span><br><span class="line">       SIGSEGV      11       Core    Invalid memory reference</span><br><span class="line">       SIGPIPE      13       Term    Broken pipe: write to pipe with no</span><br><span class="line">                                     readers</span><br><span class="line">       SIGALRM      14       Term    Timer signal from alarm(2)</span><br><span class="line">       SIGTERM      15       Term    Termination signal</span><br><span class="line">       SIGUSR1   30,10,16    Term    User-defined signal 1</span><br><span class="line">       SIGUSR2   31,12,17    Term    User-defined signal 2</span><br><span class="line">       SIGCHLD   20,17,18    Ign     Child stopped or terminated</span><br><span class="line">       SIGCONT   19,18,25    Cont    Continue if stopped</span><br><span class="line">       SIGSTOP   17,19,23    Stop    Stop process</span><br><span class="line">       SIGTSTP   18,20,24    Stop    Stop typed at tty</span><br><span class="line">       SIGTTIN   21,21,26    Stop    tty input for background process</span><br><span class="line">       SIGTTOU   22,22,27    Stop    tty output for background process</span><br><span class="line"></span><br><span class="line">       Signal       Value     Action   Comment</span><br><span class="line">       ────────────────────────────────────────────────────────────────────</span><br><span class="line">       SIGBUS      10,7,10     Core    Bus error (bad memory access)</span><br><span class="line">       SIGPOLL                 Term    Pollable event (Sys V).</span><br><span class="line">                                       Synonym for SIGIO</span><br><span class="line">       SIGPROF     27,27,29    Term    Profiling timer expired</span><br><span class="line">       SIGSYS      12,31,12    Core    Bad argument to routine (SVr4)</span><br><span class="line">       SIGTRAP        5        Core    Trace&#x2F;breakpoint trap</span><br><span class="line">       SIGURG      16,23,21    Ign     Urgent condition on socket (4.2BSD)</span><br><span class="line">       SIGVTALRM   26,26,28    Term    Virtual alarm clock (4.2BSD)</span><br><span class="line">       SIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2BSD)</span><br><span class="line">       SIGXFSZ     25,25,31    Core    File size limit exceeded (4.2BSD)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Signal     Value     Action   Comment</span><br><span class="line">名称        编号       事件      默认执行动作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Term ： 终止进程</span><br><span class="line">Ign ： 忽略</span><br><span class="line">Core：终止进程，生成 Core 文件（可以帮助开发者检测）</span><br><span class="line">Stop：停止进程</span><br><span class="line">Cont：继续运行</span><br></pre></td></tr></table></figure>

<p>Process.killProcess(Process.myPid());</p>
<p><code>kill pid （发送信号）</code> : 第一个参数，，&lt; 0 往 |pid| 发个信息，0 杀死进程组，不要传 -1 </p>
<ul>
<li>pid &gt; 0 往 pid 进程发个信号</li>
<li>pid &lt; 0 往 |pid| 发个信息</li>
<li>pid = 0 杀死进程组</li>
<li>不要传 -1 ,会杀死所有能杀死的进程</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：02.linux系统-常用命令</title>
    <url>/73.linux%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1. 常用快捷键"></a>1. 常用快捷键</h1><ul>
<li><code>table</code> 补齐</li>
<li><code>ctrl + a</code> : 光标移动到最前</li>
<li><code>ctrl + e</code>：光标移动到最后</li>
<li><code>ctrl + u</code>：清空</li>
<li><code>上，下键</code>：切换命令</li>
</ul>
<h1 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h1><h2 id="2-1-文件基本操作指令"><a href="#2-1-文件基本操作指令" class="headerlink" title="2.1 文件基本操作指令"></a>2.1 文件基本操作指令</h2><ul>
<li><code>cd xxx</code>：进入到某个目录</li>
<li><code>cd ..</code>：回退到上一级目录</li>
<li><code>ls</code> : 当前文件夹下面的所有文件</li>
<li><code>./date</code> ：执行当前目录下的可执行文件</li>
</ul>
<p>linux 系统中所见即文件（驱动）  , bin 目录一些执行文件，home 目录用户， lib 目录常用的 so ，opt 和 proc 是与进程相关的</p>
<ul>
<li><code>mkdir xxx</code>：创建文件夹</li>
<li><code>touch xxx.xxx</code>： 创建文件</li>
<li><code>ls -l</code> : 打印详细信息</li>
<li><code>ls -R</code> ：递归文件夹输出</li>
</ul>
<h2 id="2-2-文件类型"><a href="#2-2-文件类型" class="headerlink" title="2.2 文件类型"></a>2.2 文件类型</h2><p><code>drwxr-xr-x 1 ubuntu ubuntu 0 Apr 14 20:37 hello.c</code><br>代表：文件权限，硬链接计数，所有者，所属组，大小，时间，文件名</p>
<ul>
<li><code>d</code>:表示文件类型；</li>
<li><code>rwx</code>：表示文件所有者的对该文件所拥有的权限；</li>
</ul>
<p><code>-rw-rw-r--：- 文件类型，rw- 所有者可读可写，rw- 同一组用户可读可写，r-- 其他人可读</code></p>
<p><img src="/images/73.linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.jpg" alt></p>
<p>linux 系统文件类型：</p>
<ul>
<li>普通文件：-</li>
<li>目录文件：d</li>
<li>软连接：l</li>
<li>字符设备文件：c</li>
<li>块设备文件：b</li>
<li>管道文件：p</li>
<li>套接字：s</li>
</ul>
<h2 id="2-3-文件删除、拷贝、读取等"><a href="#2-3-文件删除、拷贝、读取等" class="headerlink" title="2.3 文件删除、拷贝、读取等"></a>2.3 文件删除、拷贝、读取等</h2><ul>
<li><code>rmdir ‘文件夹’</code> : 只能清空空目录文件夹</li>
<li><code>rm -r ‘文件夹’</code>：递归清空目录</li>
<li><code>rm ‘文件’</code>：删除文件</li>
<li><code>cp &#39;文件&#39; ‘文件夹路径’</code> ： 拷贝文件 -r 递归赋值</li>
<li><code>cat ‘文件’</code> ：查看文件内容</li>
<li><code>tac ‘文件’</code>：倒着查看文件</li>
<li><code>more ‘文件’</code>：每次只查看一页，空格查看下一页</li>
<li><code>less ‘文件’</code>：与 more 不同地方是, 回车是下一行，空格翻一页，没有百分百，退出 ctrl + c 不行，ESC之后  :q</li>
<li><code>head -2 ‘文件’</code>：查看前面2行</li>
<li><code>tail -20 ‘文件’</code>：查看后面20行</li>
</ul>
<p>删除文件时<code>rm</code>的参数</p>
<ul>
<li>-i 删除前逐一询问确认。</li>
<li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li>
<li>-r 将目录及以下之档案亦逐一删除。</li>
</ul>
<h1 id="3-用户与用户组"><a href="#3-用户与用户组" class="headerlink" title="3. 用户与用户组"></a>3. 用户与用户组</h1><ul>
<li>sudo：代表使用 root 权限</li>
<li><code>sudo su ‘用户’</code>：切换到 root 用户</li>
<li><code>exit</code> : 退出 当前 用户</li>
<li><code>whoami</code>：查看当前用户</li>
</ul>
<h2 id="3-1-修改用户文件权限"><a href="#3-1-修改用户文件权限" class="headerlink" title="3.1 修改用户文件权限"></a>3.1 修改用户文件权限</h2><p>新建的文件默认是不能执行的，我们需要修改用户文件权限</p>
<h3 id="3-1-1-文字设定法"><a href="#3-1-1-文字设定法" class="headerlink" title="3.1.1. 文字设定法"></a>3.1.1. 文字设定法</h3><p><code>chmod 用户的标识 +/- 权限 文件名：chmod u+x hello.sh</code><br>用户的标识：u(当前用户) ，g(同组)，o(other)，a(all)</p>
<h3 id="3-1-2-数字设定法"><a href="#3-1-2-数字设定法" class="headerlink" title="3.1.2. 数字设定法"></a>3.1.2. 数字设定法</h3><p><code>chmod nnn 文件名</code>  ,第一个n所属用户，第二个n所属用户组，第三个n其它用户<br>n = 4+2+1 = r+w+x </p>
<h2 id="3-2-用户和用户组的创建、修改、删除"><a href="#3-2-用户和用户组的创建、修改、删除" class="headerlink" title="3.2 用户和用户组的创建、修改、删除"></a>3.2 用户和用户组的创建、修改、删除</h2><ul>
<li><code>sudo adduser &#39;用户&#39;</code>： 创建了一个用户</li>
<li><code>sudo chown &#39;用户&#39; &#39;文件&#39;</code> ：修改文件的所属用户</li>
<li><code>sudo chgrp &#39;用户组&#39; &#39;文件&#39;</code> ：修改文件的所属组</li>
<li><code>sudo chown &#39;用户&#39;:&#39;用户组&#39; &#39;文件&#39;</code>：同时修改文件所属组：所属用户</li>
<li><code>sudo deluser &#39;用户&#39;</code>：删除用户，同时需要再删除“/home/用户名”的文件夹</li>
</ul>
<h1 id="4-搜索查找"><a href="#4-搜索查找" class="headerlink" title="4.搜索查找"></a>4.搜索查找</h1><h2 id="4-1-find-查找文件"><a href="#4-1-find-查找文件" class="headerlink" title="4.1 find 查找文件"></a>4.1 find 查找文件</h2><ul>
<li><code>find ./ -type ‘文件类型（文件是 -，目录是 d）’</code>（递归）</li>
<li><code>find ./ -name &#39;*.so&#39;</code> ： 根据文件名去查找</li>
<li><code>find ./ -maxdepth 1 -name &#39;*.so&#39;</code> ： 根据文件名去查找，只在当前文件夹查找，-maxdepth ：递归的层级</li>
<li><code>find ./ -maxdepth 1 -ctime -20</code>：将目前目录及其子目录下所有最近 20 天内更新过的文件列出</li>
</ul>
<p>再回顾下 文件类型</p>
<ul>
<li>d: 目录</li>
<li>c: 字型装置文件</li>
<li>b: 区块装置文件</li>
<li>p: 具名贮列</li>
<li>f: 一般文件</li>
<li>l: 符号连结</li>
<li>s: socket</li>
</ul>
<h2 id="4-2-grep-查找内容"><a href="#4-2-grep-查找内容" class="headerlink" title="4.2 grep 查找内容"></a>4.2 grep 查找内容</h2><ul>
<li><code>grep -r &quot;查询内容&quot; 文件目录</code>：grep -r ‘jaminniubi’ ./ 找当前文件夹中文件内容有jamin 的文件</li>
<li><code>grep -r -l   &quot;查询内容&quot;</code>  文件目录  ：  #这样只显示包含内容的文件名</li>
<li><code>ps aux</code>: 类似于任务管理器，把所有的进程信息都列举出来</li>
<li><code>ps aux | grep ‘内容’</code> : 找到了所有的任务，交给 grep 去执行搜索 ，如果只有一个代表没有找到，两个以上才算有</li>
</ul>
<p>| ： 管道 （进程间的通信），相当于 | 前的结果，作为输出给到 | 后</p>
<p>常用选项：</p>
<pre><code>　　-e ：开启扩展（Extend）的正则表达式。

　　-i ：忽略大小写（ignore case）。

　　-v ：反过来（invert），只打印没有匹配的，而匹配的反而不打印。

　　-n ：显示行号

　　-w ：被匹配的文本只能是单词，而不能是单词中的某一部分，如文本中有liker，而我搜寻的只是like，就可以使用-w选项来避免匹配liker

　　-c ：显示总共有多少行被匹配到了，而不是显示被匹配到的内容，注意如果同时使用-cv选项是显示有多少行没有被匹配到。

　　-o ：只显示被模式匹配到的字符串。

　　--color :将匹配到的内容以颜色高亮显示。

　　-A  n：显示匹配到的字符串所在的行及其后n行，after

　　-B  n：显示匹配到的字符串所在的行及其前n行，before

　　-C  n：显示匹配到的字符串所在的行及其前后各n行，context</code></pre><h1 id="5-软件安装"><a href="#5-软件安装" class="headerlink" title="5.软件安装"></a>5.软件安装</h1><h2 id="5-1-命令行安装"><a href="#5-1-命令行安装" class="headerlink" title="5.1 命令行安装"></a>5.1 命令行安装</h2><ul>
<li><code>sudo apt-get install tree</code>：tree 是要安装的程序</li>
<li><code>sudo apt-get update</code>:更新程序</li>
<li><code>sudo apt-get remove tree</code>:软件卸载</li>
</ul>
<h2 id="5-2-压缩包安装"><a href="#5-2-压缩包安装" class="headerlink" title="5.2 压缩包安装"></a>5.2 压缩包安装</h2><p>这种格式一般会采用源代码编译安装，或是解压完直接就可以运行的方式，可以通过查看目录内是否有源代码或是configure文件来确实是不是源代码。</p>
<ul>
<li><code>./configure                       //配置</code></li>
<li><code>make                              //编译</code></li>
<li><code>make install                      //安装</code></li>
</ul>
<h2 id="5-3-源码安装"><a href="#5-3-源码安装" class="headerlink" title="5.3 源码安装"></a>5.3 源码安装</h2><ul>
<li><code>./configure                       //配置</code></li>
<li><code>make                              //编译</code></li>
<li><code>make install                      //安装</code></li>
</ul>
<h1 id="6-压缩和解压缩"><a href="#6-压缩和解压缩" class="headerlink" title="6.压缩和解压缩"></a>6.压缩和解压缩</h1><h2 id="6-1-tar"><a href="#6-1-tar" class="headerlink" title="6.1 tar"></a>6.1 tar</h2><p><code>tar -zcvf &#39;压缩到的文件&#39; ‘需要压缩的文件’ ‘需要压缩的文件’</code><br><code>tar -jcvf test.tar.zip a.c file</code><br><code>tar -zxvf test.tar.zip</code> // 解压文件  </p>
<ul>
<li><p><code>-zcvf</code>　<code>z:gzip</code> ,　<code>c: create压缩</code>　<code>f: file</code>　<code>v:显示过程</code> <code>x:解压缩</code> </p>
</li>
<li><p><code>-jcvf</code>　<code>j:bizp2</code> ,　<code>c: create压缩</code>　<code>f: file</code>　<code>v:显示过程</code> <code>x:解压缩</code></p>
</li>
<li><p><code>gzip ‘需要压缩的文件’</code> 只能压缩一个文件</p>
</li>
<li><p><code>gunzip a.c.gz</code>：解压文件</p>
</li>
</ul>
<h2 id="6-2-rar和zip"><a href="#6-2-rar和zip" class="headerlink" title="6.2 rar和zip"></a>6.2 rar和zip</h2><ul>
<li><code>rar a -r test.rar</code> ：rar 压缩</li>
<li><code>unrar x test.rar</code>：rar 解压缩</li>
<li><code>zip -r test.zip a.c file</code> ：zip 压缩</li>
<li><code>unzip test.zip</code>：zip解压缩</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：07.linux系统-线程和多线程同步</title>
    <url>/78.linux%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h1 id="1-线程的本质"><a href="#1-线程的本质" class="headerlink" title="1.线程的本质"></a>1.线程的本质</h1><p>线程与进程的区别：线程大家可以简单理解为一个轻量级的进程，线程共享了栈和堆（变量），没有复制 0-3 G 的进程空间，<br>但线程会有自己的工作空间，会有自己的 pcb 块。跟 Java 是类似的。</p>
<ol>
<li>linux线程执行和windows不同，pthread有两种状态<code>joinable</code>状态和<code>unjoinable</code>状态，<br>如果线程是<code>joinable</code>状态，当<code>线程函数自己返回退出时或pthread_exit</code>时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了<code>pthread_join</code>之后这些资源才会被释放。<br>若是<code>unjoinable</code>状态的线程，这些资源在<code>线程函数退出时或pthread_exit时</code>自动会被释放。</li>
<li><code>unjoinable</code>属性可以在<code>pthread_create时指定</code>，或在线程创建后在线程中pthread_detach自己, 如：<code>pthread_detach(pthread_self())，将状态改为unjoinable状态</code>，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join.</li>
<li>其实简单的说就是在线程函数头加上 pthread_detach(pthread_self())的话，线程状态改变，在函数尾部直接 pthread_exit线程就会自动退出。省去了给线程擦屁股的麻烦。</li>
</ol>
<h1 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2.创建线程"></a>2.创建线程</h1><p><code>pthread_create(&amp;tid,NULL,thread_run,NULL);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am a thread\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure>

<h1 id="3-退出线程"><a href="#3-退出线程" class="headerlink" title="3.退出线程"></a>3.退出线程</h1><p><code>pthread_exit(-1);</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure>

<h1 id="4-回收线程"><a href="#4-回收线程" class="headerlink" title="4.回收线程"></a>4.回收线程</h1><p><code>pthread_join(tid,&amp;retval); // retval = 0代表回收成功，-1 代表线程已经退出了</code></p>
<p>pthread_join()即是子线程合入主线程，<code>主线程阻塞等待子线程结束</code>，然后回收子线程资源。</p>
<p>pthread_join()函数，<code>以阻塞的方式</code>等待thread指定的线程结束。当函数返回时，<code>被等待线程的资源被收回</code>。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p>
<p>一般情况下需要回收线程，retval 用来接收线程的返回值，tid 是线程的id，该方法会阻塞等待<br>什么情况下不需要回收呢？除非调用了分离线程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    pthread_join(tid,&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure>

<h1 id="5-杀死（取消）线程"><a href="#5-杀死（取消）线程" class="headerlink" title="5.杀死（取消）线程"></a>5.杀死（取消）线程</h1><p><code>pthread_cancel(tid);</code> // 取消线程需要有函数进入内核，也就是说需要调用系统函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 循环里面是空的，则会卡死，线程不会取消，原因是取消线程需要有函数进入内核</span></span><br><span class="line">            <span class="comment">// printf("i am a thread，no = %d\n",no);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 实在没什么写的，又想线程能够取消，可以调下面这个方法</span></span><br><span class="line">            pthread_testcancel();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;retval);<span class="comment">// 返回值是 -1 ,表示被干掉或者退出的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure>

<h1 id="6-分离线程"><a href="#6-分离线程" class="headerlink" title="6.分离线程"></a>6.分离线程</h1><p><code>pthread_detach(tid);使线程ID为tid的线程处于分离状态，一旦线程处于分离状态，该线程终止时底 层资源立即被回收</code></p>
<p>分离线程之后是当线程执行完毕或者<code>pthread_exit</code>后，残留在线程中的资源会自动回收，也就是说线程需要回收，有两种方式一种是 join 一种是 detach 分离。</p>
<p><code>该函数不会阻塞父线程。pthread_detach(tid);函数用于只是应用程序在线程tid终止时回收其存储空间。如果tid尚未终止，pthread_detach()不会终止该线程。</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对线程进行分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    pthread_join(tid,&amp;retval);<span class="comment">// 返回值是 -1 ,表示被干掉或者退出的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure>

<h1 id="7-线程同步"><a href="#7-线程同步" class="headerlink" title="7.线程同步"></a>7.线程同步</h1><ul>
<li><code>pthread_mutex_t mutex</code></li>
<li>加锁：<code>pthread_mutex_lock(&amp;mutex);</code></li>
<li>解锁：<code>pthread_mutex_unlock(&amp;mutex);</code></li>
<li>销毁锁：<code>pthread_mutex_destroy(&amp;mutex);</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 加一个锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 加一个条件</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> product_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt;<span class="number">200000000</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现加锁的出错的情况，应该是没有计算完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成者与消费者（java要能手写）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                <span class="comment">// 1. 阻塞等待唤醒</span></span><br><span class="line">                <span class="comment">// 2. 释放锁</span></span><br><span class="line">                <span class="comment">// 3. 被唤醒，解除阻塞，需要重新竞争锁</span></span><br><span class="line">                <span class="comment">// 是一个 while 循环，等待有两种方式会被唤醒，一种是条件发信号，一种是系统（不正常）惊群效应</span></span><br><span class="line">                <span class="keyword">while</span>(number &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"等待生产者生成产品"</span>);</span><br><span class="line">                        pthread_cond_wait(&amp;product_cond, &amp;mutex);</span><br><span class="line">				&#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"消费者消费产品: %ld\n"</span>,number);</span><br><span class="line">                number--;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"生成者生产产品: %ld\n"</span>,number);</span><br><span class="line">                <span class="comment">// 通知消费者消费</span></span><br><span class="line">                pthread_cond_signal(&amp;product_cond);</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;product_cond,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="keyword">int</span> *retval;</span><br><span class="line">        <span class="comment">//for(int i=0; i&lt;4;i++)&#123;</span></span><br><span class="line">                <span class="comment">// 传的是同一个 id ，tid 没有赋值的，tid 是当做一个传出参数 0</span></span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">				pthread_detach(tid);</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(5);</span></span><br><span class="line">        <span class="comment">// 销毁锁</span></span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">        pthread_cond_destroy(&amp;product_cond);</span><br><span class="line">        <span class="comment">// 销毁条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"number = %ld\n"</span>, number);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV：23.实时人脸检测和识别</title>
    <url>/71.OpenCV-%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E5%92%8C%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv71" target="_blank" rel="noopener">NDKPractice项目的opencv71</a></strong></p>
<h1 id="1-训练人脸样本"><a href="#1-训练人脸样本" class="headerlink" title="1. 训练人脸样本"></a>1. 训练人脸样本</h1><p>三种训练方法：  </p>
<ul>
<li>eigenFace 算法 : EigenFaceRecognizer</li>
<li>FisherFace 算法：FisherFaceRecognizer</li>
<li>LBPH 算法：LBPHFaceRecognizer</li>
</ul>
<p><a href="https://blog.csdn.net/akenseren/article/details/80647276" target="_blank" rel="noopener">网站1</a></p>
<p><a href="https://www.cnblogs.com/little-monkey/p/8118938.html" target="_blank" rel="noopener">网站2</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv71_FaceDetection_trainingPattern(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    <span class="comment">// 训练样本，这一步是在数据采集做的</span></span><br><span class="line">    <span class="comment">// train it</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; faces;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; labels;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 样本比较少</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; ++j) &#123;</span><br><span class="line">            Mat face = imread(format(<span class="string">"/storage/emulated/0/s%d/%d.pgm"</span>, i, j), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (face.empty()) &#123;</span><br><span class="line">                LOGE(<span class="string">"face mat is empty"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 确保大小一致</span></span><br><span class="line">            resize(face, face, Size(<span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">            faces.push_back(face);</span><br><span class="line">            labels.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        Mat face = imread(format(<span class="string">"/storage/emulated/0/face_%d.png"</span>, i), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (face.empty()) &#123;</span><br><span class="line">            LOGE(<span class="string">"face mat is empty"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resize(face, face, Size(<span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">        faces.push_back(face);</span><br><span class="line">        labels.push_back(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练方法</span></span><br><span class="line">    Ptr&lt;BasicFaceRecognizer&gt; model = EigenFaceRecognizer::create();</span><br><span class="line">    <span class="comment">// 采集了八张，同一个人 label 一样</span></span><br><span class="line">    model-&gt;train(faces, labels);</span><br><span class="line">    <span class="comment">// 训练样本是 xml ，本地</span></span><br><span class="line">    model-&gt;save(<span class="string">"/storage/emulated/0/face_darren_pattern.xml"</span>);<span class="comment">// 存的是处理的特征数据</span></span><br><span class="line">    LOGE(<span class="string">"樣本訓練成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-识别人脸"><a href="#2-识别人脸" class="headerlink" title="2. 识别人脸"></a>2. 识别人脸</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Java_com_east_opencv71_FaceDetection_loadPattern(JNIEnv *env, jobject instance,</span><br><span class="line">                                                    jstring patternPath_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *patternPath = env-&gt;GetStringUTFChars(patternPath_, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 加载样本数据，Error:(142, 12) error: no matching member function for call to 'load' 怎么搞？</span></span><br><span class="line">    <span class="comment">// model-&gt;load(patternPath);</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs</span><span class="params">(patternPath, FileStorage::READ)</span></span>;</span><br><span class="line">    <span class="comment">// 报错，没有提示</span></span><br><span class="line">    <span class="comment">// CV_Assert(fs.isOpened());</span></span><br><span class="line">    <span class="comment">// 抛个 java 异常</span></span><br><span class="line">    FileNode fn = fs.getFirstTopLevelNode();</span><br><span class="line">    model-&gt;<span class="built_in">read</span>(fn);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(patternPath_, patternPath);</span><br><span class="line">    LOGE(<span class="string">"训练样本加载成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：09.Cmake语法-详解CmakeLists.txt</title>
    <url>/80.Cmake%E8%AF%AD%E6%B3%95-%E8%AF%A6%E8%A7%A3CmakeLists.txt/</url>
    <content><![CDATA[<h1 id="1-初试-CMake-的-HelloWorld"><a href="#1-初试-CMake-的-HelloWorld" class="headerlink" title="1.初试 CMake 的 HelloWorld"></a>1.初试 CMake 的 HelloWorld</h1><p>注意：<code>PROJECT、这些不区分大小写</code>，但是<code>${HELLO_BINARY_DIR}这些，必须大写</code></p>
<ul>
<li><code>PROJECT(HELLO)</code>：给工程取一个名字</li>
<li><code>SET(SRC_LIST hello.cpp)</code>：定义一个变量</li>
<li><code>MESSAGE(STATUS &quot;this is BINARY dir &quot;${HELLO_BINARY_DIR})</code>：打印</li>
<li><code>ADD_EXECUTABLE(hello.out ${SRC_LIST})</code>：生成可执行文件</li>
</ul>
<ol>
<li><p>新建<code>CMakeLists.txt</code>文件，编写以下内容</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 给工程取一个名字</span><br><span class="line">PROJECT(HELLO)</span><br><span class="line"></span><br><span class="line"># 定义一个变量</span><br><span class="line">SET(SRC_LIST hello.cpp)</span><br><span class="line"></span><br><span class="line"># 打印</span><br><span class="line">MESSAGE(STATUS &quot;this is BINARY dir &quot;$&#123;HELLO_BINARY_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1&#x2F;build</span><br><span class="line">MESSAGE(STATUS &quot;this is SOURCE dir &quot;$&#123;HELLO_SOURCE_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1</span><br><span class="line">MESSAGE(STATUS &quot;this is PROJECT_SOURCE dir &quot;$&#123;PROJECT_SOURCE_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">ADD_EXECUTABLE(hello.out $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在同目录下创建 build 文件夹,进入执行 <code>cmake ..</code> ..代表CMakeLists.txt在上一级目录</p>
</li>
<li><p>最后在build目录中，执行 <code>make</code></p>
</li>
</ol>
<h1 id="2-构建生成-so-动态库"><a href="#2-构建生成-so-动态库" class="headerlink" title="2.构建生成 .so 动态库"></a>2.构建生成 .so 动态库</h1><p>目的：把src里的源文件，生成<code>libmath.so</code>动态库，动态库的存储路径在lib目录下</p>
<ul>
<li><code>CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</code>:指定 CMake 的最低编译版本</li>
<li><code>AUX_SOURCE_DIRECTORY(${PROJECT_SOURCE_DIR}/src SRC_LIST)</code>：搜集 src 目录下的所有源文件，并赋值为SRC_LIST</li>
<li><code>FILE(GLOB SRC_LIST &quot;${PROJECT_SOURCE_DIR}/src/*&quot;)</code>：搜集 src 目录下的所有源文件，并赋值为SRC_LIST</li>
<li><code>INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/include)</code>：指定头文件在哪个目录</li>
<li><code>SET (LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)</code>：指定 so 的生成目录 lib</li>
<li><code>ADD_LIBRARY (math SHARED ${SRC_LIST_CPP} ${SRC_LIST_C})</code>：指定生成动态库 .so， <code>math</code> 生成的so名字为 <code>libmath.so</code> 如果默认生成的是静态库.a，加入SHARED才会生成动态库.so</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定 CMake 的最低编译版本</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</span><br><span class="line"></span><br><span class="line"># 给工程取名字</span><br><span class="line">PROJECT(MATH)</span><br><span class="line"></span><br><span class="line"># 搜集 src 目录下的所有源文件，有AUX_SOURCE_DIRECTORY和FILE 两种方式</span><br><span class="line"># AUX_SOURCE_DIRECTORY($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src SRC_LIST)</span><br><span class="line"># FILE(GLOB SRC_LIST &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.cpp&quot; &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.c&quot;)</span><br><span class="line">FILE(GLOB SRC_LIST_CPP &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.cpp&quot;)</span><br><span class="line">FILE(GLOB SRC_LIST_C &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.c&quot;)</span><br><span class="line"></span><br><span class="line"># MESSAGE (STATUS &quot;src_list : &quot;$&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 指定头文件在哪个目录</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)</span><br><span class="line"></span><br><span class="line"># 指定 so 的生成目录 lib</span><br><span class="line">SET (LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)</span><br><span class="line"></span><br><span class="line"># 指定生成动态库 .so math -&gt; libmath.so 如果默认生成的是静态库.a，加入SHARED才会生成动态库.so</span><br><span class="line">ADD_LIBRARY (math SHARED $&#123;SRC_LIST_CPP&#125; $&#123;SRC_LIST_C&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="3-链接外部动态库与头文件"><a href="#3-链接外部动态库与头文件" class="headerlink" title="3.链接外部动态库与头文件"></a>3.链接外部动态库与头文件</h1><ul>
<li><code>LINK_DIRECTORIES (${PROJECT_SOURCE_DIR}/lib)</code>：<font color="red">官方不推荐使用，有时候会找不到引用。经过尝试，so库放在jniLibs下的时候可以编译成功</font>链接 lib 目录下的 libmath.so,指定 so 在哪个目录下，</li>
<li><code>TARGET_LINK_LIBRARIES (hello math)</code>：为 hello 添加编译链接库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定 CMake 的最低编译版本</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line">PROJECT (HELLO)</span><br><span class="line"></span><br><span class="line"># 指定头文件在哪个目录</span><br><span class="line">INCLUDE_DIRECTORIES ($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)</span><br><span class="line"></span><br><span class="line"># 编译是需要链接 lib 目录下的 libmath.so</span><br><span class="line"># 指定 so 在哪个目录下，so库放在jniLibs下的时候才可以编译成功</span><br><span class="line">LINK_DIRECTORIES ($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">ADD_EXECUTABLE (hello hello.cpp)</span><br><span class="line"></span><br><span class="line"># 为 hello 添加编译链接库</span><br><span class="line">TARGET_LINK_LIBRARIES (hello math)</span><br></pre></td></tr></table></figure>

<h1 id="4-根据不同的源文件夹生成不同的-so-文件"><a href="#4-根据不同的源文件夹生成不同的-so-文件" class="headerlink" title="4. 根据不同的源文件夹生成不同的 .so 文件"></a>4. 根据不同的源文件夹生成不同的 .so 文件</h1><p>1.则需要在顶层目录下创建CMakeLists.txt，内容如下</p>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure></code></pre><ol start="2">
<li>然后在 src 中再创建一个CMakeLists.txt，内容就是上边生成.so文件的内容  </li>
<li>在顶层目录下创建 build 文件夹，执行<code>cmake ..</code> ,<code>make</code> 的指令  </li>
<li>如果不指定生成的so位置，最后生成的.so文件默认在<code>build/‘源文件的目录’</code>中   </li>
</ol>
<h1 id="5-修改以前-ffmpeg-开发项目中的-CMakeLists-txt"><a href="#5-修改以前-ffmpeg-开发项目中的-CMakeLists-txt" class="headerlink" title="5.修改以前 ffmpeg 开发项目中的 CMakeLists.txt"></a>5.修改以前 ffmpeg 开发项目中的 CMakeLists.txt</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定最低版本名称</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"># 指定引入头文件目录</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;include)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;other)</span><br><span class="line"></span><br><span class="line"># 指定共享库的库目录，so库放在jniLibs下的时候才可以编译成功</span><br><span class="line">LINK_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;armeabi)</span><br><span class="line"></span><br><span class="line"># 指定源文件的目录</span><br><span class="line">AUX_SOURCE_DIRECTORY($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;cpp SRC_LIST)</span><br><span class="line"></span><br><span class="line"># 生成 native-lib</span><br><span class="line">ADD_LIBRARY(native-lib SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 为 native-lib 添加 ffmpeg 编译链接库</span><br><span class="line">TARGET_LINK_LIBRARIES(native-lib  </span><br><span class="line">avcodec-56 </span><br><span class="line">avdevice-56 </span><br><span class="line">avfilter-5 </span><br><span class="line">avformat-56 </span><br><span class="line">avutil-54 </span><br><span class="line">postproc-53 </span><br><span class="line">swresample-1 </span><br><span class="line">swscale-3 </span><br><span class="line">-landroid </span><br><span class="line">-llog)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：10.Shell脚本-详解Shell脚本基础语法</title>
    <url>/81.Shell%E8%84%9A%E6%9C%AC-%E8%AF%A6%E8%A7%A3Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="1-shell-脚本创建与执行-01-sh"><a href="#1-shell-脚本创建与执行-01-sh" class="headerlink" title="1.shell 脚本创建与执行(01.sh)"></a>1.shell 脚本创建与执行(01.sh)</h1><p>一般都是<code>**.sh</code>文件</p>
<ul>
<li><code>#!</code>：需要用谁来解析执行该 shell 脚本</li>
<li><code>echo</code>：打印输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 需要用谁来解析执行该 shell 脚本</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># echo 打印输出</span><br><span class="line">echo &quot;Hello Shell!&quot;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"># 2.自定义变量与环境变量(02.sh)</span><br><span class="line"></span><br><span class="line">变量设计规则：</span><br><span class="line"></span><br><span class="line">1. 命名跟Java规范一样</span><br><span class="line">2. shell 中&#96;默认都是字符串类&#96;，如果需要用到其他类型，需要额外处理</span><br><span class="line">3. 变量用等号连接，千万注意&#96;不能有空格&#96;</span><br><span class="line">4. 变量的值如果有空格，需要用&#96;单引号&#96;或者&#96;双引号&#96;包括</span><br><span class="line"></span><br><span class="line">- &#96;$&#96;：取变量的值</span><br><span class="line">- &#96;echo &quot;CMAKE_PATH &#x3D; $&#123;CMAKE_PATH&#125;&quot;&#96;：输出环境变量CMAKE_PATH的值</span><br><span class="line">- soPath&#x3D;&#96;pwd&#96;：记得带上&#96;&#96;代表执行命令并返回</span><br></pre></td></tr></table></figure>
<p>#指定一个命令的执行结果返回给变量<br>#soPath=$(pwd)<br>soPath=<code>pwd</code><br>echo “soPath = ${soPath}”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>str1=”str1”  // str1<br>str2=str2    // str2<br>str3=3       // 3<br>str4=”Hello Shell” // Hello Shell</p>
<h1 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h1><p>str4=str4 // str4</p>
<h1 id="取变量的值"><a href="#取变量的值" class="headerlink" title="$取变量的值"></a>$取变量的值</h1><p>echo “str1 = $str1” // str1 = str1<br>echo “str2 = $str2” // str2 = str2<br>echo “str3 = $str3” // str3 = 3<br>echo “str4 = $str4” // str4 = str4</p>
<p>#输出环境变量<br>echo “CMAKE_PATH = ${CMAKE_PATH}”</p>
<p>#指定一个命令的执行结果返回给变量<br>#soPath=$(pwd)<br>soPath=<code>pwd</code>  // soPath = 当前路径<br>echo “soPath = ${soPath}” </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 3.位置参数变量与预定义变量</span><br><span class="line"></span><br><span class="line">## 3.1.获取位置参数（03.sh）</span><br><span class="line"></span><br><span class="line">- &#96;$n&#96; 来获取参数,$0 代表程序本身，&#96;$1-$9&#96;代表第一个参数到第九个参数，十以上的参数要用大括号 &#96;$&#123;10&#125;&#96;</span><br><span class="line">- &#96;$*&#96; 代表的是命令中的所有参数，&#96;加上引号才会把参数看成一个整体&#96; &quot;$0,$1,$2,$3,$4...$n&quot;，否则区别对待</span><br><span class="line">- &#96;$@&#96; 代表命令中的所有参数，但是会把参数区分对待 &quot;$0&quot;,&quot;$1&quot;,&quot;$2&quot;...&quot;$n&quot;</span><br><span class="line">- &#96;$#&#96; 代表参数中的个数</span><br></pre></td></tr></table></figure>
<p>echo “$0=$0”<br>echo “$1=$1”<br>echo “$2=”$2</p>
<p>echo “$<em>=”$</em><br>echo “$@=”$@<br>echo “$#=”$#</p>
<p>#每次逻动（删除）第一个参数<br>shift</p>
<p>echo “$1=$1”<br>echo “$@=”$@</p>
<p>echo “========================================”<br>for i in $*<br>do<br>echo $i<br>done</p>
<p>echo “========================================”<br>for i in $@<br>do<br>echo $i<br>done</p>
<p>echo “========================================”<br>for i in “$@”<br>do<br>echo $i<br>done</p>
<p>echo “========================================”<br>for i in “$*”  // 加上引号才会看成一个整体<br>do<br>echo $i<br>done</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 3.2.预定义变量</span><br><span class="line"></span><br><span class="line">定义：是 bash 中已经定义好的，我们可以直接拿过来用，变量的作用都是固定</span><br><span class="line"></span><br><span class="line">- &#96;$?&#96;:返回的是上一个执行命令的返回值，执行成功返回 0 ，执行失败返回非0</span><br><span class="line">- &#96;$$&#96;:获取当前脚本的进程号</span><br><span class="line">- &#96;$!&#96;:获取最后一个后台执行的进程号</span><br><span class="line"></span><br><span class="line">## 3.3.获取输入的变量(04.sh)</span><br><span class="line"></span><br><span class="line">- &#96;read -p &quot;提示&quot; name&#96;：name 代表接受的变量名</span><br><span class="line">- &#96;read -sp &quot;提示&quot; pwd&#96;：&#96;-sp 看不到输入的密码&#96;，pwd 代表接受的变量名</span><br><span class="line">- &#96;read -t 5 -n 1 -p &quot;please input [y|n]&quot; input&#96;：-t 5代表5秒没响应就退出，-n 1 代表只能输入1个字符</span><br></pre></td></tr></table></figure>
<h1 id="获取用户及时输入的参数"><a href="#获取用户及时输入的参数" class="headerlink" title="获取用户及时输入的参数"></a>获取用户及时输入的参数</h1><p>#read -p “please input your name!” name<br>#echo “name = $name”</p>
<p>#输入年龄</p>
<h1 id="read-sp-“please-input-your-password”-pwd"><a href="#read-sp-“please-input-your-password”-pwd" class="headerlink" title="read -sp “please input your password” pwd"></a>read -sp “please input your password” pwd</h1><h1 id="echo-“password-pwd”"><a href="#echo-“password-pwd”" class="headerlink" title="echo “password=$pwd”"></a>echo “password=$pwd”</h1><p>read -t 5 -n 1 -p “please input [y|n]” input<br>echo “input = $input” </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 4.条件判断(测试指令)（05.sh）</span><br><span class="line">条件判断 &#96;test 表达式&#96; 或者 &#96;[]&#96;</span><br><span class="line"></span><br><span class="line">数字计算:</span><br><span class="line">- &#96;num3&#x3D;$(($num1+$num2))&#96;</span><br><span class="line">- num3&#x3D;&#96;expr $num1 + $num2&#96; &#x2F;&#x2F; 执行 expr命令，一定要有空格 传的三个参数</span><br><span class="line">- &#96;test $str1 &#x3D;&#x3D; $str2&#96; &#x2F;&#x2F; &#96;&#x3D;&#x3D;之间一定更要空格&#96;</span><br><span class="line"></span><br><span class="line">字符串空判断：</span><br><span class="line"></span><br><span class="line">- &#96;[ str ]&#96;: 测试字符串是否不为空，&lt;font color&#x3D;red&gt;[]中间必须带空格&lt;&#x2F;font&gt;</span><br><span class="line">- &#96;test -n str&#96;: 测试字符串是否不为空</span><br><span class="line">- &#96;test -z str&#96;: 测试字符串是否为空</span><br><span class="line">- &#96;[ str1 &#x3D; str2 ]&#96;: 是否相等，&lt;font color&#x3D;red&gt;[]中间必须带空格&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">数字：</span><br><span class="line"></span><br><span class="line">- &#96;[ num1 -eq num2 ]&#96;： 测试是否相等</span><br><span class="line">- &#96;[ num1 -ne num2 ]&#96;： 不等</span><br><span class="line">- &#96;[ num1 -ge num2 ]&#96;： &gt;&#x3D;</span><br><span class="line">- &#96;[ num1 -gt num2 ]&#96;： &gt;</span><br><span class="line">- &#96;[ num1 -le num2 ]&#96;： &lt;&#x3D;</span><br><span class="line">- &#96;[ num1 -lt num2 ]&#96;： &lt;</span><br><span class="line"></span><br><span class="line">文件：</span><br><span class="line"></span><br><span class="line">- &#96;test -d file&#96;：是否是目录</span><br><span class="line">- &#96;test -f file&#96;：是否是普通文件</span><br><span class="line">- &#96;test -e file&#96;：文件是否存在</span><br><span class="line">- &#96;test -L file&#96;：是否是链接</span><br><span class="line">- &#96;test -r file&#96;：是否可读</span><br><span class="line">- &#96;test -w file&#96;：是否可写</span><br><span class="line">- &#96;test -x file&#96;：是否可执行</span><br><span class="line"></span><br><span class="line"># 5.流程语句 if （06.sh）</span><br><span class="line"></span><br><span class="line">有两种方式:</span><br></pre></td></tr></table></figure>
<p>if [ 表达式 ]; then</p>
<p>if [ 表达式 ]<br>then</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="判断有没有输入"><a href="#判断有没有输入" class="headerlink" title="判断有没有输入"></a>判断有没有输入</h1><p>if [ -z $1 ]<br>then<br>    # echo “usage：./build_ogre.sh [build_type]”<br>        # echo “build_type: Release or Debug (must have)”<br>    # exit<br>    error<br>fi</p>
<h1 id="需要用户去指定编译-Debug-还是-Release"><a href="#需要用户去指定编译-Debug-还是-Release" class="headerlink" title="需要用户去指定编译 Debug 还是 Release"></a>需要用户去指定编译 Debug 还是 Release</h1><p>CMAKE_BUILD_TYPE=””<br>if [ “Debug” = $1 ]; then<br>    CMAKE_BUILD_TYPE=”Debug”<br>elif [ “Release” = $1 ]; then<br>    CMAKE_BUILD_TYPE=”Release”<br>else<br>    error arm<br>fi</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 6.自定义函数(06.sh)</span><br><span class="line"></span><br><span class="line">- 函数需要先定义再使用,&#96;function和()必须有其一&#96;</span><br><span class="line">- 可以直接采用方法名调用,不用加()</span><br><span class="line">- $1 参数不是代表的脚本参数，而是方法传递过来的参数</span><br></pre></td></tr></table></figure>
<p>// function和()可以只有一个<br>function error(){<br>    echo “usage：./build_ogre.sh [build_type]”<br>        echo “build_type: Release or Debug (must have)”<br>    # 函数需要穿参数 arm $1 参数不是代表的脚本参数，而是方法传递过来的参数<br>    echo “$1 = $1”<br>        exit<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 7.流程语句 for、while、case （06.sh）</span><br><span class="line"></span><br><span class="line">for:</span><br></pre></td></tr></table></figure>
<p>for((i=0;i&lt;10;i++))<br>do<br>echo $i<br>done</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">while:</span><br></pre></td></tr></table></figure>
<p>sum=0<br>i=1<br>while(($i&lt;=100))<br>do<br>    sum=$(($sum+$i))<br>    i=$(($i+1))<br>done<br>echo “sum = $sum”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">case:</span><br></pre></td></tr></table></figure>
<p>case $2 in<br>start)<br>    echo “start service”<br>    ;;<br>stop)<br>    echo “stop service”<br>    ;;<br>*)<br>    echo “invalid command”<br>    echo “Usage:{start|stop}”<br>esac</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 8.输出重定向(07.sh)</span><br><span class="line"></span><br><span class="line">&#96;0:&#96; 标准输入,&#96;1&#96;：标准输出 &#96;2&#96;：标准错误输出</span><br><span class="line"></span><br><span class="line">- &#96;echo &quot;Hello Shell!&quot; &gt; log.txt&#96; &#x2F;&#x2F; 输出日志到 log.txt 中，&#96;&gt;&#96; 代表重新生成</span><br><span class="line">- &#96;echo &quot;Hello Shell!&quot; &gt;&gt; log.txt&#96; &#x2F;&#x2F; 输出日志到 log.txt 中，&#96;&gt;&gt;&#96; 代表追加</span><br><span class="line">- &#96;exec 1&gt;log.txt&#96;：标准的所有输出，&#96;重新生成&#96;全部添加到log.txt中</span><br><span class="line">- &#96;exec 2&gt;&gt;log.txt&#96;：标准的错误输出，全部&#96;追加&#96;到log.txt中</span><br></pre></td></tr></table></figure>
<h1 id="永久重定向-echo-标准输入：0-标准输出：1-标准错误：2"><a href="#永久重定向-echo-标准输入：0-标准输出：1-标准错误：2" class="headerlink" title="永久重定向  echo 标准输入：0 标准输出：1 标准错误：2"></a>永久重定向  echo 标准输入：0 标准输出：1 标准错误：2</h1><p>exec 1&gt;log.txt<br>exec 2&gt;&gt;log.txt</p>
<h1 id="gt-gt-代表追加，-gt-代表重新生成"><a href="#gt-gt-代表追加，-gt-代表重新生成" class="headerlink" title="&gt;&gt; 代表追加，&gt; 代表重新生成"></a>&gt;&gt; 代表追加，&gt; 代表重新生成</h1><h1 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h1><h1 id="echo-“Hello-Shell-”-gt-log-txt"><a href="#echo-“Hello-Shell-”-gt-log-txt" class="headerlink" title="echo “Hello Shell!” &gt; log.txt"></a>echo “Hello Shell!” &gt; log.txt</h1><h1 id="echo-“Hello-Shell-”-gt-gt-log-txt"><a href="#echo-“Hello-Shell-”-gt-gt-log-txt" class="headerlink" title="echo “Hello Shell!” &gt;&gt; log.txt"></a>echo “Hello Shell!” &gt;&gt; log.txt</h1><p>echo “Hello Shell”<br>echo “Hello Shell”<br>echo “Hello Shell”</p>
<pre><code>

</code></pre>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：11.Shell脚本-动手编译FFmpeg</title>
    <url>/82.Shell%E8%84%9A%E6%9C%AC-%E5%8A%A8%E6%89%8B%E7%BC%96%E8%AF%91FFmpeg/</url>
    <content><![CDATA[<p><a href="https://www.jianshu.com/p/fe54d70a260e" target="_blank" rel="noopener">避坑指南</a></p>
<h1 id="1-Cmake交叉编译Android动态库"><a href="#1-Cmake交叉编译Android动态库" class="headerlink" title="1.Cmake交叉编译Android动态库"></a>1.Cmake交叉编译Android动态库</h1><p>交叉编译：Linux上编译Android的so</p>
<p>ndk 16的以上版本自带交叉编译工具链</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmake -DANDROID_NDK&#x3D;$&#123;NDK_PATH&#125; \ # ndk的安装目录（空格 \回车，相当于所有命令弄到同一行）</span><br><span class="line">        -DCMAKE_TOOLCHAIN_FILE&#x3D;$&#123;NDK_PATH&#125;&#x2F;build&#x2F;cmake&#x2F;android.toolchain.cmake \ # cmake 交叉编译工具链</span><br><span class="line">        -DANDROID_ABI&#x3D;&quot;armeabi-v7a&quot; \ # 指定CPU</span><br><span class="line">        -DANDROID_NATIVE_API_LEVEL&#x3D;19 \    # 指定最低版本</span><br><span class="line">        ..</span><br></pre></td></tr></table></figure>

<h1 id="2-配置NDK环境"><a href="#2-配置NDK环境" class="headerlink" title="2.配置NDK环境"></a>2.配置NDK环境</h1><p>在NDKr17以后，NDK 不再支持32位和64位 MIPS 和ARM v5(armeabi)</p>
<p>所以现在NDK中只支持armeabi-v7a，armeabi-v8a，x86,x86_64四类</p>
<p>注意如果是虚拟机的linux系统 <code>需要把要拷贝的文件放到桌面，然后通过ctrl+c复制，最后在虚拟机上 ctrl+v复制</code></p>
<ol>
<li>下载<a href="https://www.jianshu.com/p/528eeb266f83" target="_blank" rel="noopener">NDK</a></li>
<li>将下载好的linux系统的ndk,<code>拷贝</code>到linux系统的 <code>/lib</code>目录下<code>新建的ndk目录</code>并<code>解压</code>,需要root权限</li>
<li>配置环境变量   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">配置环境变量:</span><br><span class="line"></span><br><span class="line">配置环境变量 vim &#x2F;etc&#x2F;profile</span><br><span class="line">文件最后面输入：</span><br><span class="line">export NDK_PATH&#x3D;&#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b</span><br><span class="line">export PATH&#x3D;$NDK_PATH:$PATH</span><br><span class="line">使环境变量生效 source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="2-1-NDK中交叉编译工具的变化"><a href="#2-1-NDK中交叉编译工具的变化" class="headerlink" title="2.1 NDK中交叉编译工具的变化"></a>2.1 NDK中交叉编译工具的变化</h2><p>在ndkr17c 以后默认使用的变成了<code>clang</code>，<code>而不是gcc</code></p>
<h3 id="2-1-1-交叉编译工具位置的变化"><a href="#2-1-1-交叉编译工具位置的变化" class="headerlink" title="2.1.1. 交叉编译工具位置的变化:"></a>2.1.1. 交叉编译工具位置的变化:</h3><p>在 NDK r19以前的 ndk 内置了一个可以自动生成交叉编译工具(toolchain) 的.py文件，放在</p>
<p>ndk路径下面的build/tool/make_standalone_toolchain.py</p>
<p>要生成toolchain，使用下面的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$NDK_HOME&#x2F;build&#x2F;tools&#x2F;make_standalone_toolchain.py --arch arm --api 21 --install-dir &#x2F;Users&#x2F;fczhao&#x2F;Desktop</span><br><span class="line"></span><br><span class="line">后面的几个都是必要的</span><br><span class="line"></span><br><span class="line">--arch 指定了生成的toolchain要在哪个CPU框架中使用</span><br><span class="line"></span><br><span class="line">--api 指定了生成的toolchain要在哪个Android API 中使用</span><br><span class="line"></span><br><span class="line">--install-dir 生成的toolchain的路径</span><br></pre></td></tr></table></figure>

<p>但是NDK r19以后的NDK已经内置了这些文件，如果运行上面的命令，会出现这样的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING:__main__:make_standalone_toolchain.py is no longer necessary. The</span><br><span class="line"></span><br><span class="line">#$NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin 这个路径已经有了我们要生成的文件</span><br><span class="line">$NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin directory contains target-specific scripts that perform</span><br><span class="line">the same task. For example, instead of:</span><br><span class="line"></span><br><span class="line">    $ python $NDK&#x2F;build&#x2F;tools&#x2F;make_standalone_toolchain.py \</span><br><span class="line">        --arch arm --api 21 --install-dir toolchain</span><br><span class="line">    $ toolchain&#x2F;bin&#x2F;clang++ src.cpp</span><br><span class="line"></span><br><span class="line">Instead use:</span><br><span class="line"></span><br><span class="line">    $ $NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin&#x2F;armv7a-linux-androideabi21-clang++ src.cpp</span><br><span class="line"></span><br><span class="line">Installation directory already exists. Use --force.</span><br></pre></td></tr></table></figure>


<h1 id="3-手写FFmpeg编译脚本"><a href="#3-手写FFmpeg编译脚本" class="headerlink" title="3.手写FFmpeg编译脚本"></a>3.手写FFmpeg编译脚本</h1><p>关于版本问题：学习尽量使用最新的版本（api过时，api改进），开发尽量使用大众的版本（方便查询解决问题）版本<code>3.3.9</code></p>
<p><font color="red">第三方库编译的通用思想：</font></p>
<ol>
<li>首先先看下<code>README.md</code>文件</li>
<li>编译项目（动静态库）需要 Makefile 管理，如果<code>已经有写好的Makefile可以尝试着用make命令去编译</code>，如果没有需要自己写<code>Makefile</code>或者采用 <code>cmake</code> 构建</li>
<li>如果Makefile报错需要解决，一般情况下都是Makefile的一些配置文件没生成，所以一般需要先运行<code>configure</code>文件</li>
<li>生成配置文件之后，再次运行make,但是编译后的文件（elf,so,a）只能在当前类型系统上运行。如果需要跑到android或ios那么需要<code>交叉编译</code>。<code>因此我们一般都需要往configure文件里面传一些交叉编译参数</code></li>
</ol>
<ul>
<li><code>./configure --help &gt; help.txt</code>:将configure 的帮助说明写到<code>help.txt</code>中去</li>
</ul>
<p><code>NDKr16以上的版本NDKr19</code>以下需要我们自己去生成android版本的交叉编译链 ,NDKr19以上不需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 创建目录 &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b&#x2F;android-toolchains&#x2F;android-19&#x2F;arch-arm</span><br><span class="line">2. 进入 &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b&#x2F;build&#x2F;tools 目录下</span><br><span class="line">3. 执行命令：</span><br><span class="line">    sudo .&#x2F;make_standalone_toolchain.py --arch arm --api 19 --install-dir &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r16b&#x2F;android-toolchains&#x2F;android-19&#x2F;arch-arm</span><br><span class="line"></span><br><span class="line">如果出现 Installation directory already exists. Use --force.</span><br><span class="line"></span><br><span class="line">在上条命令最后面加上 --force就行</span><br></pre></td></tr></table></figure>

<p><code>ndk-r16b和ffmpeg3.3.9</code>的脚本文件请查看<a href="../makefile、cmake、shell/82.Shell脚本-动手编译FFmpeg/ffmpeg_build_r16b.sh">ffmpeg_build_r16b.sh</a>,还需要注意修改configure里生成文件名的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">按 esc 键输入 &#x2F;build setting 查找</span><br><span class="line"></span><br><span class="line"># SLIBNAME_WITH_MAJOR&#x3D;&#39;$(SLIBNAME).$(LIBMAJOR)&#39;</span><br><span class="line"># LIB_INSTALL_EXTRA_CMD&#x3D;&#39;$$(RANLIB) &quot;$(LIBDIR)&#x2F;$(LIBNAME)&quot;&#39;</span><br><span class="line"># SLIB_INSTALL_NAME&#x3D;&#39;$(SLIBNAME_WITH_VERSION)&#39;</span><br><span class="line"># SLIB_INSTALL_LINKS&#x3D;&#39;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&#39;</span><br><span class="line"># 替换成如下</span><br><span class="line">SLIBNAME_WITH_MAJOR&#x3D;&#39;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&#39;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD&#x3D;&#39;$$(RANLIB)&quot;$(LIBDIR)&#x2F;$(LIBNAME)&quot;&#39;</span><br><span class="line">SLIB_INSTALL_NAME&#x3D;&#39;$(SLIBNAME_WITH_MAJOR)&#39;</span><br><span class="line">SLIB_INSTALL_LINKS&#x3D;&#39;$(SLIBNAME)&#39;</span><br></pre></td></tr></table></figure>

<p><code>ndk-r16b和ffmpeg3.3.9</code>的脚本文件请查看<a href="../makefile、cmake、shell/82.Shell脚本-动手编译FFmpeg/ffmpeg_build_r21b.sh">ffmpeg_build_r21b.sh</a></p>
<h1 id="4-编译遇到的问题"><a href="#4-编译遇到的问题" class="headerlink" title="4.编译遇到的问题"></a>4.编译遇到的问题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang is unable to create an executable file. C compiler test failed.</span><br><span class="line">C compiler test failed.</span><br><span class="line"></span><br><span class="line">If you think configure made a mistake, make sure you are using the latest</span><br><span class="line">version from Git. If the latest version fails, report the problem to the</span><br><span class="line">ffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net.</span><br><span class="line">Include the log file &quot;config.log&quot; produced by configure as this will help</span><br><span class="line">solving the problem.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当遇到这个问题的时候</span><br><span class="line"></span><br><span class="line">大部分是NDK支持平台错了</span><br><span class="line"></span><br><span class="line">sudo uname --m</span><br><span class="line"></span><br><span class="line">如果显示i686,你安装的是32位操作系统</span><br><span class="line">如果显示 x86_64，你安装的是64位操作系统</span><br><span class="line"></span><br><span class="line">下载的时候按下面</span><br><span class="line"></span><br><span class="line">android-ndk64-r10b-linux-x86.tar</span><br><span class="line">支持的是32位操作系统</span><br><span class="line">android-ndk64-r10b-linux-x86_64.tar.bz2 </span><br><span class="line">支持的是64位操作系统</span><br></pre></td></tr></table></figure>

<h1 id="5-如何适配so框架"><a href="#5-如何适配so框架" class="headerlink" title="5.如何适配so框架"></a>5.如何适配so框架</h1><p>目前支持有不同的 7 中 cpu 的架构，<code>ARMv5</code>,<code>ARMv7(2010年)</code>,<code>ARMv8</code>,<code>x86(2011年)</code>,<code>mips(2012年)</code>,<code>mip64</code>,<code>x86_64</code>。  </p>
<p>每一种架构都关联着一种<code>ABI</code>。  现在一般只需要arm架构就行</p>
<p>armv5,armv7（32位）,armv8（64位）：高版本会兼容低版本的，因此只需要放一个低版本的就可以了，armeabi或者armeabi-v7a(现在一般都是v7a，AS上只支持v7以上的，AS4.1提示后面上架到google play 的应用都需要支持64位的)  </p>
<p>armeabi：v5因为比较旧，因此早期缺少浮点计算的硬件支持，在需要大量计算是有一定的性能影响。</p>
<h1 id="6-编译参数传递"><a href="#6-编译参数传递" class="headerlink" title="6.编译参数传递"></a>6.编译参数传递</h1><h1 id="7-运行调试音频解码"><a href="#7-运行调试音频解码" class="headerlink" title="7.运行调试音频解码"></a>7.运行调试音频解码</h1>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：08.Cmake语法-makefile、cmake、shell 自动编译和链接</title>
    <url>/79.Cmake%E8%AF%AD%E6%B3%95-makefile%E3%80%81cmake%E3%80%81shell%20%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="1-makefile、cmake-与-shell-之间的联系"><a href="#1-makefile、cmake-与-shell-之间的联系" class="headerlink" title="1.makefile、cmake 与 shell 之间的联系"></a>1.makefile、cmake 与 shell 之间的联系</h1><ul>
<li><p>makefile ： 帮助我们管理编译项目   </p>
</li>
<li><p>cmake：是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的 Makefile 或者 project 文件，CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Makefile 或 projects）。</p>
</li>
<li><p>shell 脚本：一系列命令和语法</p>
</li>
</ul>
<h1 id="2-makefile-自动编译和链接"><a href="#2-makefile-自动编译和链接" class="headerlink" title="2.makefile 自动编译和链接"></a>2.makefile 自动编译和链接</h1><h2 id="2-1-gcc-如何编译相互依赖，却没直接引入的文件"><a href="#2-1-gcc-如何编译相互依赖，却没直接引入的文件" class="headerlink" title="2.1 gcc 如何编译相互依赖，却没直接引入的文件"></a>2.1 gcc 如何编译相互依赖，却没直接引入的文件</h2><p>Android.mk  Application.mk </p>
<p><code>gcc hello.cpp div.cpp sub.cpp add.cpp -o hello</code>// hello.cpp 中并没引入 div.cpp等文件，但是这样编译会自动找寻到依赖的文件</p>
<p>gcc 四步骤：生成 .o 文件比较耗时（<code>汇编阶段</code>）</p>
<p>上面的编译步骤其实就是省略了编译四步骤，假设现在我改了一个文件，需要重新编译，那么每次都会重新生成 .o 文件，因此需要把上面的步骤进行拆分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c sub.cpp -o sub.o</span><br><span class="line">gcc -c add.cpp -o add.o</span><br><span class="line">gcc -c div.cpp -o div.o</span><br><span class="line">gcc -c hello.cpp -o hello.o</span><br><span class="line">gcc add.o sub.o div.o hello.o -o hello</span><br></pre></td></tr></table></figure>

<p>这样如何只修改了 sub.cpp ，就只需要重新生成 sub.o 文件，然后重新生成最终的可执行文件</p>
<h2 id="2-2-如何编写Makefile文件"><a href="#2-2-如何编写Makefile文件" class="headerlink" title="2.2 如何编写Makefile文件"></a><font color="red">2.2 如何编写Makefile文件</font></h2><p>执行 Makefile 文件，只需要在Makefile 的目录下 执行<code>make</code>指令就行</p>
<h3 id="2-2-1-一个规则（观看makefile、cmake、shell目录下的m1）"><a href="#2-2-1-一个规则（观看makefile、cmake、shell目录下的m1）" class="headerlink" title="2.2.1. 一个规则（观看makefile、cmake、shell目录下的m1）"></a>2.2.1. 一个规则（观看makefile、cmake、shell目录下的m1）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目标：依赖条件</span><br><span class="line">（一个tab缩进） 命令</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">hello.out:hello.o sub.o add.o div.o</span><br><span class="line">	gcc hello.o sub.o add.o div.o -o hello.out</span><br><span class="line">div.o:div.cpp</span><br><span class="line">	gcc -c div.cpp -o div.o</span><br></pre></td></tr></table></figure>

<p><code>默认情况下只会执行 MakeFile 中的第一个命令。</code></p>
<ol>
<li><p>但若想生成目标文件，则会检查命令中的依赖是否存在，如果不存在就会往下查找是否有生成该依赖条件的命令，如有就会执行生成依赖再生成目标文件。</p>
</li>
<li><p>会检测规则中的目标是否需要更新，必须先检测它的依赖性（通过更新时间判断），只需要重新生成依赖中被修改的依赖，然后再更新目标文件</p>
</li>
</ol>
<h3 id="2-2-2-两个函数（观看makefile、cmake、shell目录下的m2）"><a href="#2-2-2-两个函数（观看makefile、cmake、shell目录下的m2）" class="headerlink" title="2.2.2. 两个函数（观看makefile、cmake、shell目录下的m2）"></a>2.2.2. 两个函数（观看makefile、cmake、shell目录下的m2）</h3><ol>
<li><code>src = $(wildcard *.cpp)</code>　// 找到当前目录下所有后缀为.cpp的文件，然后赋值给src <code>$(src) 取变量src的值</code></li>
<li><code>obj = $(patsubst %cpp,%o,$(src))</code>　//把src变量中所有后缀为.cpp的文件替换成.o文件 <code>$(obj) 取变量obj的值</code></li>
</ol>
<p>make clean -n 注意加上 -n 预执行</p>
<p>make clean 执行 clean 命令</p>
<p>如果目录下有 clean 文件夹，则会有冲突，这时只需要生成伪目标就行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src &#x3D; $(wildcard *.cpp)</span><br><span class="line">obj &#x3D; $(patsubst %cpp,%o,$(src))</span><br><span class="line"></span><br><span class="line"># 默认情况下只会执行第一个</span><br><span class="line">hello.out:$(obj)</span><br><span class="line">	gcc $(obj) -o hello.out</span><br><span class="line"></span><br><span class="line">div.o:div.cpp</span><br><span class="line">	gcc -c div.cpp -o div.o</span><br><span class="line"></span><br><span class="line">add.o:add.cpp</span><br><span class="line">	gcc -c add.cpp -o add.o</span><br><span class="line"></span><br><span class="line">sub.o:sub.cpp</span><br><span class="line">	gcc -c sub.cpp -o sub.o</span><br><span class="line"></span><br><span class="line">hello.o:hello.cpp</span><br><span class="line">	gcc -c hello.cpp -o hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># $(xxx) 取变量的值</span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(obj) hello.out	</span><br><span class="line"></span><br><span class="line"># 生成伪目标</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>


<h3 id="2-2-3-三个自动变量（观看makefile、cmake、shell目录下的m3）"><a href="#2-2-3-三个自动变量（观看makefile、cmake、shell目录下的m3）" class="headerlink" title="2.2.3. 三个自动变量（观看makefile、cmake、shell目录下的m3）"></a>2.2.3. 三个自动变量（观看makefile、cmake、shell目录下的m3）</h3><p>多行注释 <code>:&#39;</code></p>
<ul>
<li>$@：表示规则中的目标</li>
<li>$^：表示规则中所有的依赖条件,组成一个列表，以空格隔开，如果这个列表有重复项则消除重复项</li>
<li>$&lt;：表示规则中的第一个依赖条件，如果运行在模式套用中，相当于取出依赖条件套用在该模式中</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">src &#x3D; $(wildcard *.cpp)</span><br><span class="line">obj &#x3D; $(patsubst %cpp,%o,$(src))</span><br><span class="line"></span><br><span class="line"># 默认情况下只会执行第一个</span><br><span class="line">hello.out:$(obj)</span><br><span class="line">	gcc $^ -o $@ </span><br><span class="line"></span><br><span class="line">:&#39;</span><br><span class="line">div.o:div.cpp</span><br><span class="line">	gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">add.o:add.cpp</span><br><span class="line">	gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">sub.o:sub.cpp</span><br><span class="line">	gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">hello.o:hello.cpp</span><br><span class="line">	gcc -c $&lt; -o $@</span><br><span class="line">:&#39;</span><br><span class="line"># 模式规则</span><br><span class="line"># gcc -c $(src) -o $(obj)</span><br><span class="line">%o:%cpp</span><br><span class="line">	gcc -c $&lt; -o $@ </span><br><span class="line"></span><br><span class="line"># $(xxx) 取变量的值</span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(obj) hello.out	</span><br><span class="line"></span><br><span class="line"># 生成伪目标</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure>


<h1 id="3-cmake简介和安装"><a href="#3-cmake简介和安装" class="headerlink" title="3.cmake简介和安装"></a>3.<a href="https://www.jianshu.com/p/528eeb266f83" target="_blank" rel="noopener">cmake简介和安装</a></h1><p>写 CMakeLists.txt 里面用 CMake 语法写，会帮我们生成 Makefile 用于编译管理项目</p>
<p><a href="https://blog.csdn.net/qq_27525611/article/details/104651517" target="_blank" rel="noopener">安装：</a></p>
<ol>
<li>去<a href="https://cmake.org/download/" target="_blank" rel="noopener">官网</a> 下载cmake的最新linux版本，这里下载的是<code>cmake-3.18.3.tar.gz</code></li>
<li><code>拷贝</code>到linux系统的 <code>/lib</code>目录下<code>新建的cmake目录</code>并<code>解压</code>,需要root权限</li>
<li>cd到解压后的cmake目录中运行<code>sudo ./bootstrap</code>命令进行安装</li>
<li>安装完成执行<code>sudo make</code></li>
<li>最后执行<code>sudo make install</code></li>
<li>可以在任一位置 使用<code>cmake --version</code> 查看安装的版本</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果不能在任一位置 使用&#96;cmake --version&#96; 查看安装的版本,则配置环境变量</span><br><span class="line"></span><br><span class="line">配置环境变量 vim &#x2F;etc&#x2F;profile</span><br><span class="line">文件最后面输入：</span><br><span class="line">export CMAKE_PATH&#x3D;&#x2F;lib&#x2F;cmake&#x2F;cmake-3.18.3&#x2F;bin</span><br><span class="line">export PATH&#x3D;$CMAKE_PATH:$PATH</span><br><span class="line">使环境变量生效 source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>安装问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">有的会出现没安装 make的情况,使用以下命令</span><br><span class="line">sudo apt-get install make</span><br><span class="line"></span><br><span class="line">Could not find OpenSSL.  Install an OpenSSL development package or</span><br><span class="line">  configure CMake with -DCMAKE_USE_OPENSSL&#x3D;OFF to build without OpenSSL.</span><br><span class="line"></span><br><span class="line">解决：sudo apt-get install libssl-dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error when bootstrapping CMake:</span><br><span class="line">Cannot find a C++ compiler that supports both C++11 and the specified C++ flags.</span><br><span class="line"></span><br><span class="line">1.没有装gcc 和 g++。使用 sudo apt-get install g++ 安装</span><br><span class="line"></span><br><span class="line">2. gcc 或者 g++ 版本过低，需要安装高版本的。升级风险较大，可以采用新的编译环境安装新版本的 gcc和g++ 。</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/jiangjiang_jian/article/details/80694799" target="_blank" rel="noopener">gcc升级</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r&#x2F;test</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-7 g++-7</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cnblogs.com/uestc-mm/p/7511063.html" target="_blank" rel="noopener">升级后切换 gcc 和 g++ 版本</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你在安装完之后可以采用下面的指令来查看当前系统中安装的所有的gcc和g++的版本：</span><br><span class="line">ls &#x2F;usr&#x2F;bin&#x2F;gcc*</span><br><span class="line">ls &#x2F;usr&#x2F;bin&#x2F;g++*</span><br><span class="line"></span><br><span class="line">将gcc-6加入gcc候选中，最后的数字是优先级，我自己是直接设为100（测试没有问题）</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-6 100</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-6 100</span><br><span class="line"></span><br><span class="line">完成上面的操作之后，我们就可以通过下面的指令来选择不同的gcc和g++的版本了</span><br><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br><span class="line"></span><br><span class="line">注意一个问题：</span><br><span class="line">  当切换使用了其他版本的gcc时，请务必保持g++的版本和gcc版本的一致性，否则用cmake配置出来的项目遇到c++代码还是会用之前版本的gcc。</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：12.FFmpeg-音乐播放器1</title>
    <url>/83.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A81/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83" target="_blank" rel="noopener">NDKPractice项目的ffmpeg83</a></strong></p>
<p>先来看下流程图：</p>
<p><img src="/images/83.%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p>
<h1 id="1-获取音频-Meta-信息"><a href="#1-获取音频-Meta-信息" class="headerlink" title="1.获取音频 Meta 信息"></a>1.获取音频 Meta 信息</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_east_ffmpeg83_media_JaminPlayer_nPlay(JNIEnv *env, jobject instance,</span><br><span class="line">                                                       jstring url_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *url = env-&gt;GetStringUTFChars(url_,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 1.初始化所有组件，只有调用了该函数，才能使用复用器和编解码器（源码）</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    <span class="comment">// 2.初始化网络</span></span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> formatOpenInputRes = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> formatFindStreamInfoRes = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> audioStreamIndex = <span class="number">-1</span>;</span><br><span class="line">    AVStream *audio_stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.打开输入</span></span><br><span class="line">    formatOpenInputRes = avformat_open_input(&amp;pFormatContext,url,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(formatOpenInputRes !=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">// 第一件事，需要回调给 Java层</span></span><br><span class="line">        <span class="comment">// 第二件 事，需要释放资源</span></span><br><span class="line">        LOGE(<span class="string">"format open input error：%s"</span>,av_err2str(formatOpenInputRes));</span><br><span class="line">        <span class="comment">// 一般不推荐这么写，但是的确很方便。</span></span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.找出输入流的信息</span></span><br><span class="line">    formatFindStreamInfoRes = avformat_find_stream_info(pFormatContext,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(formatFindStreamInfoRes &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"format find stream info error: %s"</span>,av_err2str(formatFindStreamInfoRes));</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.查找音频流的 index</span></span><br><span class="line">    audioStreamIndex = av_find_best_stream(pFormatContext,AVMediaType::AVMEDIA_TYPE_AUDIO,<span class="number">-1</span>,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(audioStreamIndex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"format audio stream error"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取采样率和通道</span></span><br><span class="line">    audio_stream = pFormatContext-&gt;streams[audioStreamIndex];</span><br><span class="line">    LOGE(<span class="string">"采样率：%d, 通道数: %d"</span>, audio_stream-&gt;codecpar-&gt;sample_rate, audio_stream-&gt;codecpar-&gt;channels);</span><br><span class="line"></span><br><span class="line">    __av_resources_destroy:</span><br><span class="line">    <span class="keyword">if</span>(pFormatContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        avformat_close_input(&amp;pFormatContext);</span><br><span class="line">        avformat_free_context(pFormatContext);</span><br><span class="line">        pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_network_deinit();</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(url_,url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-解码音频数据"><a href="#2-解码音频数据" class="headerlink" title="2.解码音频数据"></a>2.解码音频数据</h1><p>关于解码函数 avcodec_decode_audio4 已经过时了，取而代之的是 avcodec_send_packet 和 avcodec_receive_frame 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6.查找解码</span></span><br><span class="line">    pCodecParameters = pFormatContext-&gt;streams[audioStreamIndex]-&gt;codecpar;</span><br><span class="line">    pCodec = avcodec_find_decoder(pCodecParameters-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"codec find audio decoder error"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.创建一个解码器的上下文</span></span><br><span class="line">    pCodecContext = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span>(pCodecContext == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"codec alloc context error"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8.根据参数值填充Codec上下文参数</span></span><br><span class="line">    codecParametersToContextRes = avcodec_parameters_to_context(pCodecContext,pCodecParameters);</span><br><span class="line">    <span class="keyword">if</span> (codecParametersToContextRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"codec parameters to context error: %s"</span>, av_err2str(codecParametersToContextRes));</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 9.打开解码器</span></span><br><span class="line">    codecOpenRes = avcodec_open2(pCodecContext,pCodec,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (codecOpenRes != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"codec audio open error: %s"</span>, av_err2str(codecOpenRes));</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pPacket = av_packet_alloc();</span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line">    <span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatContext,pPacket) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pPacket-&gt;stream_index == audioStreamIndex)&#123;</span><br><span class="line">            <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">            <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext,pPacket);</span><br><span class="line">            <span class="keyword">if</span>(codecSendPacketRes == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext,pFrame);</span><br><span class="line">                <span class="keyword">if</span>(codecReceiveFrameRes == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                    index++;</span><br><span class="line">                    LOGE(<span class="string">"解码第 %d 帧"</span>,index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解引用</span></span><br><span class="line">        av_packet_unref(pPacket);</span><br><span class="line">        av_frame_unref(pFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">    av_packet_free(&amp;pPacket);</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line"></span><br><span class="line">    __av_resources_destroy:</span><br><span class="line">    <span class="keyword">if</span>(pCodecContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        avcodec_close(pCodecContext);</span><br><span class="line">        avcodec_free_context(&amp;pCodecContext);</span><br><span class="line">        pCodecContext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pFormatContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        avformat_close_input(&amp;pFormatContext);</span><br><span class="line">        avformat_free_context(pFormatContext);</span><br><span class="line">        pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_network_deinit();</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(url_,url);</span><br></pre></td></tr></table></figure>

<h1 id="3-播放音频"><a href="#3-播放音频" class="headerlink" title="3.播放音频"></a>3.播放音频</h1><p>播放 pcm 数据目前比较流行的有两种方式，一种是通过 Android 的 AudioTrack 来播放，另一种是采用跨平台的 OpenSLES(直接用的底层操作驱动播放) 来播放，<br>个人比较倾向于用更加高效的 <a href="https://github.com/googlesamples/android-ndk/tree/master/native-audio" target="_blank" rel="noopener">OpenSLES</a> 来播放音频，大家可以先看看 Google 官方的 native-audio 事例，这里我们先采用 AudioTrack 来播放</p>
<p>AudioTrack 来播：  </p>
<ol>
<li>创建 AudioTack 对象 </li>
<li>启动循环，设置为播放状态 (play)</li>
<li>把数据推到指定数组中 (write)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">createAudioTrack</span><span class="params">(JNIEnv *env)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*AudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat,</span></span><br><span class="line"><span class="comment">        int bufferSizeInBytes, int mode)*/</span></span><br><span class="line">    jclass jAudioTrackClass = env-&gt;FindClass(<span class="string">"android/media/AudioTrack"</span>);</span><br><span class="line">    jmethodID  jAudioTackCMid = env-&gt;GetMethodID(jAudioTrackClass,<span class="string">"&lt;init&gt;"</span>,<span class="string">"(IIIIII)V"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> streamType = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sampleRateInHz = AUDIO_SAMPLE_RATE;</span><br><span class="line">    <span class="keyword">int</span> channelConfig = (<span class="number">0x4</span> | <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">int</span> audioFormat = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat)</span></span><br><span class="line">    jmethodID  getMinBufferSizeMID = env-&gt;GetStaticMethodID(jAudioTrackClass,<span class="string">"getMinBufferSize"</span>,<span class="string">"(III)I"</span>);</span><br><span class="line">    <span class="keyword">int</span> bufferSizeInBytes = env-&gt;CallStaticIntMethod(jAudioTrackClass,getMinBufferSizeMID,sampleRateInHz,</span><br><span class="line">            channelConfig,audioFormat);</span><br><span class="line">    LOGE(<span class="string">"bufferSizeInBytes = %d"</span>,bufferSizeInBytes);</span><br><span class="line"></span><br><span class="line">    jobject jAudioTrackObj = env-&gt;NewObject(jAudioTrackClass,jAudioTackCMid,streamType,sampleRateInHz,channelConfig,</span><br><span class="line">            audioFormat,bufferSizeInBytes,mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// play</span></span><br><span class="line">    jmethodID playMid = env-&gt;GetMethodID(jAudioTrackClass,<span class="string">"play"</span>,<span class="string">"()V"</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(jAudioTrackObj,playMid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jAudioTrackObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 10.使用AudioTrack播放</span></span><br><span class="line">        jAudioTrackClass = env-&gt;FindClass(<span class="string">"android/media/AudioTrack"</span>);</span><br><span class="line">        <span class="comment">//  public int write(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes)</span></span><br><span class="line">        jWriteMid = env-&gt;GetMethodID(jAudioTrackClass,<span class="string">"write"</span>,<span class="string">"([BII)I"</span>);</span><br><span class="line">        jAudioTrackObj = createAudioTrack(env);</span><br><span class="line">    </span><br><span class="line">        pPacket = av_packet_alloc();</span><br><span class="line">        pFrame = av_frame_alloc();</span><br><span class="line">        <span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line">        <span class="keyword">while</span>(av_read_frame(pFormatContext,pPacket) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pPacket-&gt;stream_index == audioStreamIndex)&#123;</span><br><span class="line">                <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">                <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext,pPacket);</span><br><span class="line">                <span class="keyword">if</span>(codecSendPacketRes == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext,pFrame);</span><br><span class="line">                    <span class="keyword">if</span>(codecReceiveFrameRes == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                        index++;</span><br><span class="line">                        LOGE(<span class="string">"解码第 %d 帧"</span>,index);</span><br><span class="line">    </span><br><span class="line">                        <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                        <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                        <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                        <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line">                        <span class="keyword">int</span> dataSize = av_samples_get_buffer_size(<span class="literal">NULL</span>,pFrame-&gt;channels,</span><br><span class="line">                                                                  pFrame-&gt;nb_samples,pCodecContext-&gt;sample_fmt,<span class="number">0</span>);</span><br><span class="line">                        jbyteArray jPcmByteArray = env-&gt;NewByteArray(dataSize);</span><br><span class="line">                        <span class="comment">// native 创建 c 数组</span></span><br><span class="line">                        jbyte *jPcmData= env-&gt;GetByteArrayElements(jPcmByteArray,<span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">memcpy</span>(jPcmData,pFrame-&gt;data,dataSize);</span><br><span class="line">                        <span class="comment">// 0 把 c 的数组的数据同步到 jbyteArray,然后释放native数组</span></span><br><span class="line">                        env-&gt;ReleaseByteArrayElements(jPcmByteArray,jPcmData,<span class="number">0</span>);</span><br><span class="line">                        env-&gt;CallIntMethod(jAudioTrackObj,jWriteMid,jPcmByteArray,<span class="number">0</span>,dataSize);</span><br><span class="line">                        <span class="comment">// 解除 jPcmDataArray 的持有，让 javaGC 回收</span></span><br><span class="line">                        env-&gt;DeleteLocalRef(jPcmByteArray);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解引用</span></span><br><span class="line">            av_packet_unref(pPacket);</span><br><span class="line">            av_frame_unref(pFrame);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">        av_packet_free(&amp;pPacket);</span><br><span class="line">        av_frame_free(&amp;pFrame);</span><br><span class="line">        env-&gt;DeleteLocalRef(jAudioTrackObj);</span><br><span class="line">    </span><br><span class="line">        __av_resources_destroy:</span><br><span class="line">        <span class="keyword">if</span>(pCodecContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            avcodec_close(pCodecContext);</span><br><span class="line">            avcodec_free_context(&amp;pCodecContext);</span><br><span class="line">            pCodecContext = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(pFormatContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            avformat_close_input(&amp;pFormatContext);</span><br><span class="line">            avformat_free_context(pFormatContext);</span><br><span class="line">            pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        avformat_network_deinit();</span><br><span class="line">    </span><br><span class="line">        env-&gt;ReleaseStringUTFChars(url_,url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块播放还是有杂音，而且内存持续上涨，下节我们通过多线程播放来解决</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：13.FFmpeg-音乐播放器2</title>
    <url>/84.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A82/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83" target="_blank" rel="noopener">NDKPractice项目的ffmpeg83</a></strong></p>
<h1 id="1-解决内存上涨的问题"><a href="#1-解决内存上涨的问题" class="headerlink" title="1.解决内存上涨的问题"></a>1.解决内存上涨的问题</h1><p>将循环中<code>新建数组操作提到循环外面去</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">jbyteArray jPcmByteArray =  env-&gt;NewByteArray(dataSize);</span><br><span class="line"><span class="comment">// native 创建 c 数组</span></span><br><span class="line">jbyte *jPcmData =  env-&gt;GetByteArrayElements(jPcmByteArray, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pPacket = av_packet_alloc();</span><br><span class="line">pFrame = av_frame_alloc();</span><br><span class="line"><span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStreamIndex) &#123;</span><br><span class="line">        <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">        <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">        <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">            <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                index++;</span><br><span class="line">                LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用重采样的方法</span></span><br><span class="line">                swr_convert(swrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(jPcmData, resampleOutBuffer, dataSize);</span><br><span class="line">                <span class="comment">// 1 把 c 的数组的数据同步到 jbyteArray,然后不释放native数组</span></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, JNI_COMMIT);</span><br><span class="line">                pJniCall-&gt;callAudioTrackWrite(jPcmByteArray, <span class="number">0</span>, dataSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解引用</span></span><br><span class="line">    av_packet_unref(pPacket);</span><br><span class="line">    av_frame_unref(pFrame);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">av_packet_free(&amp;pPacket);</span><br><span class="line">av_frame_free(&amp;pFrame);</span><br><span class="line"><span class="comment">// 0 把 c 的数组的数据同步到 jbyteArray,然后释放native数组</span></span><br><span class="line">env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 解除 jPcmDataArray 的持有，让 javaGC 回收</span></span><br><span class="line">env-&gt;DeleteLocalRef(jPcmByteArray);</span><br></pre></td></tr></table></figure>

<h1 id="2-解决杂音问题"><a href="#2-解决杂音问题" class="headerlink" title="2.解决杂音问题"></a>2.解决杂音问题</h1><p>分析  </p>
<ul>
<li>原因：是因为音频的的采样率和采用格式跟我们使用AudioTrack播放设置的会不一致。</li>
<li>解决：使用重采样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// --------------- 重采样 start --------------</span></span><br><span class="line">  <span class="comment">//输出的声道布局（立体声）</span></span><br><span class="line">  <span class="keyword">int64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line">  <span class="comment">//输出采样格式16bit PCM</span></span><br><span class="line">  <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AVSampleFormat::AV_SAMPLE_FMT_S16;</span><br><span class="line">  <span class="comment">//输出采样率</span></span><br><span class="line">  <span class="keyword">int</span> out_sample_rate = AUDIO_SAMPLE_RATE;</span><br><span class="line">  <span class="comment">//获取输入的声道布局</span></span><br><span class="line">  <span class="comment">//根据声道个数获取默认的声道布局（2个声道，默认立体声stereo）</span></span><br><span class="line">  <span class="keyword">int64_t</span> in_ch_layout = pCodecContext-&gt;channel_layout;</span><br><span class="line">  <span class="comment">//输入的采样格式</span></span><br><span class="line">  <span class="keyword">enum</span> AVSampleFormat in_sample_fmt = pCodecContext-&gt;sample_fmt;</span><br><span class="line">  <span class="comment">//输入采样率</span></span><br><span class="line">  <span class="keyword">int</span> in_sample_rate = pCodecContext-&gt;sample_rate;</span><br><span class="line">  swrContext = swr_alloc_set_opts(<span class="literal">NULL</span>, out_ch_layout, out_sample_fmt,</span><br><span class="line">                                              out_sample_rate, in_ch_layout, in_sample_fmt,</span><br><span class="line">                                              in_sample_rate, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (swrContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LOGE(<span class="string">"swr alloc set opts error"</span>);</span><br><span class="line">      callPlayerJniError(SWR_ALLOC_SET_OPTS_ERROR_CODE, <span class="string">"swr alloc set opts error"</span>);</span><br><span class="line">      <span class="comment">// 提示错误</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> swrInitRes = swr_init(swrContext);</span><br><span class="line">  <span class="keyword">if</span> (swrInitRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      LOGE(<span class="string">"swr context swr init error"</span>);</span><br><span class="line">      callPlayerJniError(SWR_CONTEXT_INIT_ERROR_CODE, <span class="string">"swr context swr init error"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// size 是播放指定的大小，是最终输出的大小</span></span><br><span class="line">  <span class="keyword">int</span> outChannels = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line">  <span class="keyword">int</span> dataSize = av_samples_get_buffer_size(<span class="literal">NULL</span>, outChannels, pCodecParameters-&gt;frame_size,</span><br><span class="line">                                            out_sample_fmt, <span class="number">0</span>);</span><br><span class="line">  resampleOutBuffer = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(dataSize);</span><br><span class="line">  <span class="comment">// --------------- 重采样 end --------------</span></span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStreamIndex) &#123;</span><br><span class="line">          <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">          <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">          <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">              <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                  index++;</span><br><span class="line">                  LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 调用重采样的方法</span></span><br><span class="line">                  swr_convert(swrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                              (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line">                  </span><br><span class="line">                  ....</span><br><span class="line"></span><br><span class="line">                  <span class="built_in">memcpy</span>(jPcmData, resampleOutBuffer, dataSize);</span><br><span class="line">                  <span class="comment">// 1 把 c 的数组的数据同步到 jbyteArray,然后不释放native数组</span></span><br><span class="line">                  env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, JNI_COMMIT);</span><br><span class="line">                  pJniCall-&gt;callAudioTrackWrite(jPcmByteArray, <span class="number">0</span>, dataSize);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解引用</span></span><br><span class="line">      av_packet_unref(pPacket);</span><br><span class="line">      av_frame_unref(pFrame);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-添加错误回调到-Java"><a href="#3-添加错误回调到-Java" class="headerlink" title="3. 添加错误回调到 Java"></a>3. 添加错误回调到 Java</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> jPlayerErrorMid = jniEnv-&gt;GetMethodID(jPlayerClass, <span class="string">"onError"</span>, <span class="string">"(ILjava/lang/String;)V"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JNICall::callPlayerError</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    jstring jMsg = jniEnv-&gt;NewStringUTF(msg);</span><br><span class="line">    jniEnv-&gt;CallVoidMethod(jPlayerObj, jPlayerErrorMid, code, jMsg);</span><br><span class="line">    jniEnv-&gt;DeleteLocalRef(jMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-多线程解码播放"><a href="#4-多线程解码播放" class="headerlink" title="4.多线程解码播放"></a>4.多线程解码播放</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadPlay</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    FFmpeg *pFFmpeg = (FFmpeg *) arg;</span><br><span class="line">    pFFmpeg-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFmpeg::play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程去播放，多线程边解码边播放</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,threadPlay,<span class="keyword">this</span>);</span><br><span class="line">    pthread_detach(tid); <span class="comment">// 回收线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-ffmpeg的一些常用指令"><a href="#5-ffmpeg的一些常用指令" class="headerlink" title="5.ffmpeg的一些常用指令"></a>5.ffmpeg的一些常用指令</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ffmpeg 命令</span><br><span class="line">转格式</span><br><span class="line">ffmpeg -i input.mp4 -vcodec copy -acodec copy out.flv</span><br><span class="line">抽取视频</span><br><span class="line">ffmpeg -i input.mp4 -an -vcodec copy out.h264</span><br><span class="line">抽取音频</span><br><span class="line">ffmpeg -i input.mp4 -vn -acodec copy out.aac</span><br><span class="line">提取 YUV </span><br><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br><span class="line">提取 PCM</span><br><span class="line">ffmpeg -i input.mp4 -vn -ar <span class="number">44100</span> -ac2 -f s16le out.pcm</span><br><span class="line">视频裁剪</span><br><span class="line">ffmpeg -i input.mp4 -vf corp=in_w<span class="number">-200</span>:in_h<span class="number">-200</span> -c:v libx264 -c:a copy out.mp4</span><br><span class="line">视频裁剪</span><br><span class="line">ffmpeg -i input.mp4 -ss <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -t <span class="number">10</span> out.mp4</span><br><span class="line">视频转图片</span><br><span class="line">ffmpeg -i input.mp4 -r <span class="number">1</span> -f image2 <span class="built_in">image</span>-%<span class="number">3</span>d.jpeg</span><br><span class="line">图片转视频</span><br><span class="line">ffmpeg -i <span class="built_in">image</span>-%<span class="number">3</span>d.jpeg out.mp4</span><br><span class="line">直播推流</span><br><span class="line">ffmpeg -re -i output.mp4 -c copy -f flv rtmp:<span class="comment">//server/live/streamName</span></span><br><span class="line">直播拉流</span><br><span class="line">ffmpeg -i rtmp:<span class="comment">//server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure>

<p>问题：<font color="red">子线程中返回 java 错误会有问题</font></p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：14.FFmpeg-音乐播放器3</title>
    <url>/85.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A83/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83" target="_blank" rel="noopener">NDKPractice项目的ffmpeg83</a></strong></p>
<h1 id="1-添加准备完毕回调"><a href="#1-添加准备完毕回调" class="headerlink" title="1.添加准备完毕回调"></a>1.添加准备完毕回调</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">JNICall::JNICall(JavaVM *javaVM, JNIEnv *jniEnv, jobject jPlayerObj) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;javaVM = javaVM;</span><br><span class="line">    <span class="keyword">this</span>-&gt;jniEnv = jniEnv;</span><br><span class="line">    <span class="keyword">this</span>-&gt;jPlayerObj = jniEnv-&gt;NewGlobalRef(jPlayerObj);</span><br><span class="line"></span><br><span class="line">    jclass jPlayerClass = jniEnv-&gt;GetObjectClass(jPlayerObj);</span><br><span class="line">    jPlayerErrorMid = jniEnv-&gt;GetMethodID(jPlayerClass, <span class="string">"onError"</span>, <span class="string">"(ILjava/lang/String;)V"</span>);</span><br><span class="line">    jPlayerPreparedMid = jniEnv-&gt;GetMethodID(jPlayerClass, <span class="string">"onPrepared"</span>, <span class="string">"()V"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JNICall::CallPlayerPrepared</span><span class="params">(ThreadMode threadMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子线程(pThread)用不了主线程(native线程)的 jniEnv</span></span><br><span class="line">    <span class="comment">// 子线程是不共享 jniEnv，他们有自己所独有的</span></span><br><span class="line">    <span class="keyword">if</span> (threadMode == THREAD_MAIN) &#123;</span><br><span class="line">        jniEnv-&gt;CallVoidMethod(jPlayerObj, jPlayerPreparedMid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 JavaVM获取当前线程的 JniEnv</span></span><br><span class="line">        JNIEnv *env;</span><br><span class="line">        <span class="keyword">if</span> (javaVM-&gt;AttachCurrentThread(&amp;env, <span class="number">0</span>) != JNI_OK) &#123;</span><br><span class="line">            LOGE(<span class="string">"get child thread jniEnv error"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;CallVoidMethod(jPlayerObj, jPlayerPreparedMid);</span><br><span class="line">        javaVM-&gt;DetachCurrentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-用队列边解码边播放"><a href="#2-用队列边解码边播放" class="headerlink" title="2.用队列边解码边播放"></a>2.用队列边解码边播放</h1><p>为什么要用队列边解码边播放？</p>
<p>原因：<font color="red">首先解码成pcm是耗时的，如果播放的网络音频，网络卡顿时读取也会耗时，这个时候读取本来就耗时的情况下每次读取成功还等待解码完成后再去读取就会有点卡顿。所以咱们读取和解码分开就会提升性能</font></p>
<p><code>av_read_frame：从流里面解析一个一个的 packet ，流可能是本地流也可以是网络流</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 读取</span></span><br><span class="line">           <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStreamIndex) &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//--------------------- 解码开始 -------------------------/</span></span><br><span class="line">               <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">               <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">               <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">                   <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                       index++;</span><br><span class="line">                       LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 调用重采样的方法</span></span><br><span class="line">                       swr_convert(swrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                                   (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                       <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                       <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                       <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line"></span><br><span class="line">                       <span class="built_in">memcpy</span>(jPcmData, resampleOutBuffer, dataSize);</span><br><span class="line">                       <span class="comment">// 1 把 c 的数组的数据同步到 jbyteArray,然后不释放native数组</span></span><br><span class="line">                       env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, JNI_COMMIT);</span><br><span class="line"></span><br><span class="line">                       pJniCall-&gt;callAudioTrackWrite(env,jPcmByteArray, <span class="number">0</span>, dataSize);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//--------------------- 解码结束 -------------------------/</span></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 解引用</span></span><br><span class="line">           av_packet_unref(pPacket);</span><br><span class="line">           av_frame_unref(pFrame);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">       av_packet_free(&amp;pPacket);</span><br><span class="line">       av_frame_free(&amp;pFrame);</span><br></pre></td></tr></table></figure>

<p>修改过后,具体请看文件<a href="https://github.com/EastUp/NDKPractice/blob/master/ffmpeg83/src/main/cpp/Audio.cpp" target="_blank" rel="noopener">Audio.cpp</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadReadPacket</span><span class="params">(<span class="keyword">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Audio</span> *pAudio = (<span class="built_in">Audio</span>*)args;</span><br><span class="line">    <span class="keyword">while</span>(pAudio-&gt;pPlayerStatus != <span class="literal">NULL</span> &amp;&amp; !pAudio-&gt;pPlayerStatus-&gt;isExit)&#123;</span><br><span class="line">       AVPacket *pPacket = av_packet_alloc();</span><br><span class="line">        <span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line">        <span class="keyword">if</span> (av_read_frame(pAudio-&gt;pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pPacket-&gt;stream_index == pAudio-&gt;audioStreamIndex) &#123;</span><br><span class="line">                <span class="comment">// 读取音频压缩包数据后，将其push 到 队列中</span></span><br><span class="line">                pAudio-&gt;pPacketQueue-&gt;push(pPacket);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 解引用</span></span><br><span class="line">                av_packet_unref(pPacket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">            av_packet_free(&amp;pPacket);</span><br><span class="line">            <span class="comment">// 睡眠一下，尽量不去消耗 cpu 的资源，也可以退出销毁这个线程</span></span><br><span class="line">            <span class="comment">// break;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码的线程 OpenSLES</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Audio::resampleAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dataSize = <span class="number">0</span>;</span><br><span class="line">    AVPacket *pPacket = <span class="literal">nullptr</span>;</span><br><span class="line">    AVFrame *pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pPlayerStatus != <span class="literal">nullptr</span> &amp;&amp; !pPlayerStatus-&gt;isExit) &#123;</span><br><span class="line">        pPacket = pPacketQueue-&gt;pop();</span><br><span class="line">        <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">        <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">        <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">            <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                <span class="comment">// 调用重采样的方法，返回值是返回重采样的个数，也就是 pFrame-&gt;nb_samples</span></span><br><span class="line">                dataSize = swr_convert(pSwrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                                       (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line">                LOGE(<span class="string">"解码音频帧：%d %d"</span>,dataSize,pFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                dataSize = pFrame-&gt;nb_samples * <span class="number">2</span> * <span class="number">2</span>; <span class="comment">// 采样率 * 通道数 * 两字节</span></span><br><span class="line">                <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解引用</span></span><br><span class="line">        av_packet_unref(pPacket);</span><br><span class="line">        av_frame_unref(pFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">    av_packet_free(&amp;pPacket);</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line">    <span class="keyword">return</span> dataSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：17.FFmpeg-直播推、拉流</title>
    <url>/88.FFmpeg-%E7%9B%B4%E6%92%AD%E6%8E%A8%E3%80%81%E6%8B%89%E6%B5%81/</url>
    <content><![CDATA[<p><font color="red"> 以下使用&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu&nbsp;&nbsp;&nbsp;&nbsp;环境搭建的</font></p>
<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p>
<h1 id="1-搭建流媒体服务器"><a href="#1-搭建流媒体服务器" class="headerlink" title="1.搭建流媒体服务器"></a>1.搭建流媒体服务器</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><ol>
<li><p>在ubuntu系统中首先切换到<code>root</code>用户,然后cd到<code>lib</code>目录下，<code>mkdir新建nginx</code>文件夹。</p>
</li>
<li><p>使用 <code>wget ftp://ftp.pcre.org/pub/pcre/pcre-8.38.zip</code> 下载 <code>pcre-8.38.zip版本</code>，也可以直接下载最新的版本.  </p>
<ul>
<li>下载下来后使用<code>chmod u+x pcre-8.38.zip</code>修改权限,<code>unzip pcre-8.38.zip</code>解压然后进入解压的文件夹中。</li>
<li>使用<code>./configure</code>运行会生成CMakeLists.txt  </li>
<li>接着使用<code>make</code>指令执行.    </li>
<li>最后使用<code>make install</code>指令执行.  </li>
</ul>
</li>
<li><p>下载<code>zlib</code>,点击 <a href="https://github.com/madler/zlib/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p>
<ul>
<li>返回nginx目录下使用 <code>wget https://github.com/madler/zlib/archive/v1.2.11.tar.gz</code> 下载。</li>
<li>下载下来后使用<code>chmod u+x v1.2.11.tar.gz</code>修改权限,<code>tar -zxvf v1.2.11.tar.gz</code>解压然后进入解压的文件夹中。</li>
<li>使用<code>./configure</code>运行会生成CMakeLists.txt  </li>
<li>接着使用<code>make</code>指令执行.    </li>
<li>最后使用<code>make install</code>指令执行.  </li>
</ul>
</li>
<li><p>下载<code>rtmp</code>,点击 <a href="https://github.com/arut/nginx-rtmp-module/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p>
<ul>
<li>返回nginx目录下使用 <code>wget https://github.com/arut/nginx-rtmp-module/archive/v1.2.1.tar.gz</code> 下载。</li>
<li>下载下来后使用<code>chmod u+x v1.2.1.tar.gz</code>修改权限,<code>tar -zxvf v1.2.1.tar.gz</code>解压。这个不需要安装。</li>
</ul>
</li>
<li><p>下载<code>openssl</code>,点击 <a href="https://github.com/openssl/openssl/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p>
<ul>
<li>返回nginx目录下使用 <code>wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_1c.tar.gz</code> 下载。</li>
<li>下载下来后使用<code>chmod u+x OpenSSL_1_1_1c.tar.gz</code>修改权限,<code>tar -zxvf OpenSSL_1_1_1c.tar.gz</code>解压然后进入解压的文件夹中。</li>
<li>使用 <code>./config --prefix=</code>&#96;<code>pwd</code>&#96;<code>/libs</code> 运行会生成CMakeLists.txt文件，&#96;pwd&#96;指令代表当前目录文件</li>
<li>接着使用<code>make</code>指令执行.    </li>
<li>最后使用<code>make install</code>指令执行.  </li>
</ul>
</li>
<li><p>下载<code>nginx</code>,<font color="red">必须依赖前面安装的所有东西</font> 点击 <a href="https://github.com/nginx/nginx/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p>
<ul>
<li>返回nginx目录下使用 <code>wget https://github.com/nginx/nginx/archive/release-1.17.1.tar.gz</code> 下载。</li>
<li>下载下来后使用<code>chmod u+x release-1.17.1.tar.gz</code>修改权限,<code>tar -zxvf release-1.17.1.tar.gz</code>解压然后进入解压的文件夹中。</li>
<li>使用 <code>./auto/configure --add-module=/lib/nginx/nginx-rtmp-module-1.2.1 --with-cc-opt=&quot;-Wimplicit-fallthrough=0&quot; --with-openssl=/lib/nginx/openssl-OpenSSL_1_1_1c</code></li>
<li>接着使用<code>make</code>指令执行.    </li>
<li>最后使用<code>make install</code>指令执行.  </li>
</ul>
</li>
</ol>
<ul>
<li>nginx:  <a href="https://github.com/nginx/nginx/releases" target="_blank" rel="noopener">https://github.com/nginx/nginx/releases</a></li>
<li>rtmp:  <a href="https://github.com/arut/nginx-rtmp-module/releases" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module/releases</a></li>
<li>pcre:  <a href="ftp://ftp.pcre.org/pub/pcre/">ftp://ftp.pcre.org/pub/pcre/</a> 下载最新版本，这边下载 pcre-8.38.zip</li>
<li>zlib:  <a href="https://github.com/madler/zlib/releases" target="_blank" rel="noopener">https://github.com/madler/zlib/releases</a></li>
<li>openssl:  <a href="https://github.com/openssl/openssl" target="_blank" rel="noopener">https://github.com/openssl/openssl</a></li>
</ul>
<p><strong>出现的问题</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checking for OS</span><br><span class="line"> + Linux 5.4.0-48-generic x86_64</span><br><span class="line">checking for C compiler ... not found</span><br><span class="line"></span><br><span class="line">.&#x2F;auto&#x2F;configure: error: C compiler cc is not found</span><br><span class="line"></span><br><span class="line">解决：sudo apt-get install gcc</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nginx 执行make时出现的问题</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">..&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.c: In function ‘ngx_rtmp_eval’:</span><br><span class="line">..&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.c:160:17: error: this statement may fall through [-Werror&#x3D;implicit-fallthrough&#x3D;]</span><br><span class="line">                 switch (c) &#123;</span><br><span class="line">                 ^~~~~~</span><br><span class="line">..&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.c:170:13: note: here</span><br><span class="line">             case ESCAPE:</span><br><span class="line">             ^~~~</span><br><span class="line">cc1: all warnings being treated as errors</span><br><span class="line">make[1]: *** [objs&#x2F;Makefile:1349: objs&#x2F;addon&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.o] Error 1</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;pi&#x2F;nginx-1.19.0&#39;</span><br><span class="line">make: *** [Makefile:8: build] Error 2</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">禁用gcc中的“ fallthrough”，在配置时添加选项</span><br><span class="line">.&#x2F;auto&#x2F;configure --add-module&#x3D;&#x2F;lib&#x2F;nginx&#x2F;nginx-rtmp-module-1.2.1 --with-cc-opt&#x3D;&quot;-Wimplicit-fallthrough&#x3D;0&quot; --with-openssl&#x3D;&#x2F;lib&#x2F;nginx&#x2F;openssl-OpenSSL_1_1_1c</span><br></pre></td></tr></table></figure>



<h2 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h2><p>执行命令<code>cp /lib/nginx/nginx-rtmp-module-1.2.1/test/nginx.conf /usr/local/nginx/conf/</code>  </p>
<p>替换<code>nginx.cong</code>。具体的可参考<a href="https://github.com/arut/nginx-rtmp-module" target="_blank" rel="noopener">链接</a>中的<code>Example nginx.conf</code></p>
<p>类似下面这种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">orker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  logs&#x2F;error.log debug;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line"></span><br><span class="line">        application myapp &#123;</span><br><span class="line">            live on;</span><br><span class="line"></span><br><span class="line">            #record keyframes;</span><br><span class="line">            #record_path &#x2F;tmp;</span><br><span class="line">            #record_max_size 128K;</span><br><span class="line">            #record_interval 30s;</span><br><span class="line">            #record_suffix .this.is.flv;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h2 id="1-3-启动和停止"><a href="#1-3-启动和停止" class="headerlink" title="1.3 启动和停止"></a>1.3 启动和停止</h2><ul>
<li>启动：<code>./nginx</code></li>
<li>停止：<code>./nginx -s stop</code></li>
</ul>
<p>常见问题：</p>
<ol>
<li><p>端口被占用（默认8080端口）</p>
</li>
<li><p>启动错误：比如 xxx.so 找不到。</p>
<p> 解决：<br> 使用<code>ldd $(which ./nginx)</code>查看依赖包。<br> 调用<code>export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</code>  </p>
</li>
</ol>
<h2 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h2><p>windows ffmpeg<a href="https://github.com/BtbN/FFmpeg-Builds/releases" target="_blank" rel="noopener">下载地址</a></p>
<p>mac 和 linux 类似，进入<a href="http://www.ffmpeg.org/download.html" target="_blank" rel="noopener">官网下载</a> 。</p>
<p>下面以windows为例测试步骤：</p>
<ol>
<li>进入下载好的ffmpeg解压目录的/bin目录文件夹下</li>
<li>使用命令推流：<code>.\ffmpeg.exe -re -i 等风来不如追风去.mp4 -vcodec libx264 -acodec aac -f flv rtmp://192.168.1.20/myapp/mystream</code></li>
<li>使用命令拉流：<code>ffplay.exe rtmp://192.168.1.20/myapp/mystream</code></li>
</ol>
<p>推流命令说明：</p>
<ul>
<li><code>等风来不如追风去.mp4</code>：是要推流的视频绝对路径。</li>
<li><code>rtmp://192.168.1.20/myapp/mystream</code>：要推流的地址。192.168.1.20为公网地址或局域网的地址。</li>
</ul>
<h1 id="2-集成-RTMP-推流源码"><a href="#2-集成-RTMP-推流源码" class="headerlink" title="2.集成 RTMP 推流源码"></a>2.集成 RTMP 推流源码</h1><p><img src="/images/88.%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%8B%89%E6%B5%81%E5%8E%9F%E7%90%86.png" alt>  </p>
<p><img src="/images/91.%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%8E%9F%E7%90%86.png" alt></p>
<p>采用一种 socket 通讯方案 <a href="http://rtmpdump.mplayerhq.hu/" target="_blank" rel="noopener">RTMPDump</a></p>
<ol>
<li>git clone 上面网站中的地址 <code>git clone git://git.ffmpeg.org/rtmpdump</code></li>
<li>将clone下来的文件夹中的librtmp目录中的所有<code>*.c</code>和<code>*.h</code>文件拷贝到工程目录中开始开发。</li>
<li>如果出现下面的错误就在CMakeLists.txt 中添加 <code>set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -DNO_CRYPTO&quot;)</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****\src\main\cpp\rtmp\hashswf.c:56:10: fatal error: &#39;openssl&#x2F;ssl.h&#39; file not found</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadInitConnect</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    LivePush *livePush = (LivePush *) args;</span><br><span class="line">    <span class="comment">// 1.创建RTMP</span></span><br><span class="line">    livePush-&gt;pRtmp = RTMP_Alloc();</span><br><span class="line">    <span class="comment">// 2. 初始化</span></span><br><span class="line">    RTMP_Init(livePush-&gt;pRtmp);</span><br><span class="line">    <span class="comment">// 3. 设置参数</span></span><br><span class="line">    livePush-&gt;pRtmp-&gt;Link.timeout = <span class="number">10</span>; <span class="comment">// 超时时间 10 秒</span></span><br><span class="line">    livePush-&gt;pRtmp-&gt;Link.lFlags = RTMP_LF_LIVE; <span class="comment">// 长连接</span></span><br><span class="line">    RTMP_SetupURL(livePush-&gt;pRtmp, livePush-&gt;liveUrl);<span class="comment">// 设置推流的地址</span></span><br><span class="line">    RTMP_EnableWrite(livePush-&gt;pRtmp);<span class="comment">// 可写</span></span><br><span class="line">    <span class="comment">// 4. 开始连接</span></span><br><span class="line">    <span class="keyword">if</span> (!RTMP_Connect(livePush-&gt;pRtmp, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        <span class="comment">// 回调到java层</span></span><br><span class="line">        LOGE(<span class="string">"rtmp connect error"</span>);</span><br><span class="line">        livePush-&gt;pJniCall-&gt;callConnectError(THREAD_CHILD, INIT_RTMP_CONNECT_ERROR_CODE,</span><br><span class="line">                                             <span class="string">"rtmp connect error"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)(INIT_RTMP_CONNECT_ERROR_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTMP_ConnectStream(livePush-&gt;pRtmp, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 回调到java层</span></span><br><span class="line">        LOGE(<span class="string">"rtmp connect stream error"</span>);</span><br><span class="line">        livePush-&gt;pJniCall-&gt;callConnectError(THREAD_CHILD, INIT_RTMP_CONNECT_STREAM_ERROR_CODE,</span><br><span class="line">                                             <span class="string">"rtmp connect stream error"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)(INIT_RTMP_CONNECT_STREAM_ERROR_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">"rtmp connect success"</span>);</span><br><span class="line">    livePush-&gt;pJniCall-&gt;callConnectSuccess(THREAD_CHILD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：15.FFmpeg-视频播放器1</title>
    <url>/86.FFmpeg-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A81/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg86" target="_blank" rel="noopener">NDKPractice项目的ffmpeg86</a></strong></p>
<p>将之前的音乐播放器代码整合进来</p>
<h1 id="1-使用FFmpeg解码视频"><a href="#1-使用FFmpeg解码视频" class="headerlink" title="1.使用FFmpeg解码视频"></a>1.使用FFmpeg解码视频</h1><p>跟使用FFmpeg解码音频流程一致，但需要判断是否能硬解码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//-------------需要将视频的格式一般为yuv420P转为RBGA8888-------------------------//</span></span><br><span class="line">   <span class="comment">// 1. 获取窗体</span></span><br><span class="line">   ANativeWindow *pNativeWindow = ANativeWindow_fromSurface(env,surface);</span><br><span class="line">   <span class="comment">// 2.设置缓冲区的数据</span></span><br><span class="line">   ANativeWindow_setBuffersGeometry(pNativeWindow,pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,</span><br><span class="line">           WINDOW_FORMAT_RGBA_8888);</span><br><span class="line">   <span class="comment">// Window 缓冲区的 Buffer</span></span><br><span class="line">   ANativeWindow_Buffer outBuffer;</span><br><span class="line">   <span class="comment">// 3.初始化转换上下文</span></span><br><span class="line">   SwsContext *pSwsContext = sws_getContext(pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,pCodecContext-&gt;pix_fmt,</span><br><span class="line">                  pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,AV_PIX_FMT_RGBA,</span><br><span class="line">                  SWS_BILINEAR,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">   AVFrame *pRgbaFrame = av_frame_alloc();</span><br><span class="line">   <span class="keyword">int</span> frameSize = av_image_get_buffer_size(AV_PIX_FMT_RGBA,pCodecContext-&gt;<span class="built_in">width</span>,</span><br><span class="line">           pCodecContext-&gt;<span class="built_in">height</span>,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">uint8_t</span> *frameBuffer = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(frameSize);</span><br><span class="line">   <span class="comment">// 填充</span></span><br><span class="line">   av_image_fill_arrays(pRgbaFrame-&gt;data,pRgbaFrame-&gt;linesize,frameBuffer,AV_PIX_FMT_RGBA,</span><br><span class="line">                        pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   pPacket = av_packet_alloc();</span><br><span class="line">   pFrame = av_frame_alloc();</span><br><span class="line">   <span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStramIndex) &#123;</span><br><span class="line">           <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">           <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">           <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">               <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                   index++;</span><br><span class="line">                   LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line">                   <span class="comment">// 渲染，显示，OpenGLES (高效，硬件支持)，SurfaceView</span></span><br><span class="line">                   <span class="comment">// 硬件加速和不加速有什么区别？cup 主要是用于计算，gpu 图像支持（硬件）</span></span><br><span class="line">                   <span class="comment">// 这个 pFrame-&gt;data , 一般 yuv420P 的，RGBA8888，因此需要转换</span></span><br><span class="line">                   <span class="comment">// 假设拿到了转换后的 RGBA 的 data 数据，如何渲染，把数据推到缓冲区</span></span><br><span class="line">                   sws_scale(pSwsContext,pFrame-&gt;data,pFrame-&gt;linesize,</span><br><span class="line">                           <span class="number">0</span>,pCodecContext-&gt;<span class="built_in">height</span>,pRgbaFrame-&gt;data,pRgbaFrame-&gt;linesize);</span><br><span class="line">                   <span class="comment">// 把数据推到缓冲区</span></span><br><span class="line">                   ANativeWindow_lock(pNativeWindow,&amp;outBuffer,<span class="literal">NULL</span>);</span><br><span class="line">                   <span class="built_in">memcpy</span>(outBuffer.bits,frameBuffer,frameSize);</span><br><span class="line">                   ANativeWindow_unlockAndPost(pNativeWindow);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 解引用</span></span><br><span class="line">       av_packet_unref(pPacket);</span><br><span class="line">       av_frame_unref(pFrame);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p><font color="red">问题：视音频还是没同步的问题（视频快，音频正常）</font></p>
<h1 id="2-渲染视频"><a href="#2-渲染视频" class="headerlink" title="2.渲染视频"></a>2.渲染视频</h1><h2 id="2-1-OpenGLES解释（渲染视频高效，硬件支持）"><a href="#2-1-OpenGLES解释（渲染视频高效，硬件支持）" class="headerlink" title="2.1 OpenGLES解释（渲染视频高效，硬件支持）"></a>2.1 OpenGLES解释（渲染视频高效，硬件支持）</h2><h3 id="2-1-1-OpenGL概念"><a href="#2-1-1-OpenGL概念" class="headerlink" title="2.1.1 OpenGL概念"></a>2.1.1 OpenGL概念</h3><p>OpenGL 是一种应用程序的编程接口，它是一种可以对图像硬件设备进行访问的软件库，OpenGL 被设计为一个现代化的，硬件无关的接口，<br>因此我们不用考虑操作系统的前提下，在多种不同的图像硬件系统上通过软件的形式来实现 OpenGL 接口。<br>OpenGL 也没有提供任何表达三维物体模型和读取图文的操作，我们需要用一系列的几何图元来创建三维物体。<br>图元：线，三角形，点，patch  </p>
<h3 id="2-1-2-OpenGL-用来干什么"><a href="#2-1-2-OpenGL-用来干什么" class="headerlink" title="2.1.2 OpenGL 用来干什么"></a>2.1.2 OpenGL 用来干什么</h3><p>渲染视频、图形，图片处理，2D/3D 游戏引擎，科学可视化，CAD，虚拟现实，AI人工智能等等</p>
<h3 id="2-1-3-OpenGL-与-OpenGLES-有什么关系？"><a href="#2-1-3-OpenGL-与-OpenGLES-有什么关系？" class="headerlink" title="2.1.3 OpenGL 与 OpenGLES 有什么关系？"></a>2.1.3 OpenGL 与 OpenGLES 有什么关系？</h3><p>OpenGLES 是 OpenGL 阉割（精简）版本，主要用于移动端</p>
<h3 id="2-1-4-OpenGL后续学习"><a href="#2-1-4-OpenGL后续学习" class="headerlink" title="2.1.4 OpenGL后续学习"></a>2.1.4 OpenGL后续学习</h3><p>看谷歌的<a href="https://github.com/googlesamples/android-ndk/tree/master/gles3jni" target="_blank" rel="noopener">示例</a>  </p>
<p>学开发编程的约定，坐标系变化，标量向量，渲染流水线  </p>
<p>基础绘制（数学基础），纹理，模型，雾效果，相机，美容，native 层  </p>
<h2 id="2-2-SurfaceView-渲染视频（这节先用SurfaceView）"><a href="#2-2-SurfaceView-渲染视频（这节先用SurfaceView）" class="headerlink" title="2.2 SurfaceView 渲染视频（这节先用SurfaceView）"></a>2.2 SurfaceView 渲染视频（这节先用SurfaceView）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源代码分析：</span><br><span class="line">ViewRootImpl.performDraw()</span><br><span class="line">-&gt; ViewRootImpl.draw(fullRedrawNeeded);</span><br><span class="line">-&gt; ViewRootImpl.drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                           scalingRequired, dirty, surfaceInsets)</span><br><span class="line">   </span><br><span class="line">    canvas &#x3D; mSurface.lockCanvas(dirty);</span><br><span class="line">    mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">最后通过 ViewGroup 绘制子 View 将 canvas 传递下去</span><br></pre></td></tr></table></figure>


<h3 id="2-2-1-Button-和-TextView-的-Canvas-是不是同一个？"><a href="#2-2-1-Button-和-TextView-的-Canvas-是不是同一个？" class="headerlink" title="2.2.1 Button 和 TextView 的 Canvas 是不是同一个？"></a>2.2.1 Button 和 TextView 的 Canvas 是不是同一个？</h3><p>是！！！</p>
<h3 id="2-2-2-Canvas-是从哪里来的？"><a href="#2-2-2-Canvas-是从哪里来的？" class="headerlink" title="2.2.2 Canvas 是从哪里来的？"></a>2.2.2 Canvas 是从哪里来的？</h3><p>根布局的 <code>Canvas canvas = mSurface.lockCanvas(dirty)</code></p>
<h3 id="2-2-3-Canvas-绘制的东西到哪里去了（怎么渲染出来的）？"><a href="#2-2-3-Canvas-绘制的东西到哪里去了（怎么渲染出来的）？" class="headerlink" title="2.2.3 Canvas 绘制的东西到哪里去了（怎么渲染出来的）？"></a>2.2.3 Canvas 绘制的东西到哪里去了（怎么渲染出来的）？</h3><p><img src="/images/86.%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png" alt></p>
<h3 id="2-2-4-为什么-SurfaceView-能在子线程中更新-UI"><a href="#2-2-4-为什么-SurfaceView-能在子线程中更新-UI" class="headerlink" title="2.2.4 为什么 SurfaceView 能在子线程中更新 UI"></a>2.2.4 为什么 SurfaceView 能在子线程中更新 UI</h3><p>只要View是在子线程中创建的，就可以在子线程中可以更新UI。（代码中判断的是不是当前线程）</p>
<h3 id="2-2-5-SurfaceView的挖洞原理（显示机制）SurfaceFilnger"><a href="#2-2-5-SurfaceView的挖洞原理（显示机制）SurfaceFilnger" class="headerlink" title="2.2.5 SurfaceView的挖洞原理（显示机制）SurfaceFilnger"></a>2.2.5 SurfaceView的挖洞原理（显示机制）SurfaceFilnger</h3>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：18.FFmpeg-OpenGL朋友圈录制视频</title>
    <url>/89.FFmpeg-OpenGL%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p>
<h1 id="1-OpenGL渲染流程介绍"><a href="#1-OpenGL渲染流程介绍" class="headerlink" title="1.OpenGL渲染流程介绍"></a>1.OpenGL渲染流程介绍</h1><p>怎么渲染一张图片：</p>
<ol>
<li>继承<code>GLSurfaceView</code></li>
<li>继承<code>GLSurfaceView.Renderer</code></li>
<li>写顶点和纹理渲染的代码</li>
<li>编译链接生成程序</li>
<li>生成加载 bitmap 的纹理</li>
<li>绘制到屏幕</li>
</ol>
<p>介绍一下纹理坐标系：<img src="/images/89.%E7%BA%B9%E7%90%86%E5%9D%90%E6%A0%87%E7%B3%BB.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶点坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mVertexCoordinate = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        -<span class="number">1f</span>, -<span class="number">1f</span>, <span class="comment">// 左下角</span></span><br><span class="line">        <span class="number">1f</span>, -<span class="number">1f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">        -<span class="number">1f</span>, <span class="number">1f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span>    <span class="comment">// 右上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span> FloatBuffer mVertexBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纹理坐标(对应全屏)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mFragmentCoordinate = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0f</span>, <span class="number">1f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span>,</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纹理坐标(对应半屏)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mFragmentCoordinate = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>右边是OpenGL的渲染流程：<br><img src="/images/89.OpenGL%20%E7%9A%84%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.png" alt></p>
<h1 id="2-OpenGL渲染摄像头数据"><a href="#2-OpenGL渲染摄像头数据" class="headerlink" title="2.OpenGL渲染摄像头数据"></a>2.OpenGL渲染摄像头数据</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化视频的 MediaCodec</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initVideoCodec</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MediaFormat videoFormat = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, width, height);</span><br><span class="line">    <span class="comment">// 设置颜色格式</span></span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_BIT_RATE, width * height * <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 设置帧率</span></span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_FRAME_RATE, <span class="number">24</span>);</span><br><span class="line">    <span class="comment">// 设置 I 帧的间隔时间</span></span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建编码器</span></span><br><span class="line">    mVideoCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);</span><br><span class="line">    mVideoCodec.configure(videoFormat, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line"></span><br><span class="line">    mSurface = mVideoCodec.createInputSurface();</span><br><span class="line">    <span class="comment">// 开启一个编码采集 InputSurface 上的数据，合成视频</span></span><br><span class="line">    mVideoThread = <span class="keyword">new</span> VideoEncoderThread(mVideoRecorderWr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频的渲染线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoRenderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoRecorder&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> EglHelper mEglHelper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHashCreateContext = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHashSurfaceCreated = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHashSurfaceChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mHeight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoRenderThread</span><span class="params">(WeakReference&lt;BaseVideoRecorder&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mEglHelper = <span class="keyword">new</span> EglHelper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoRecorder videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 创建 EGL 上下文</span></span><br><span class="line">                <span class="keyword">if</span> (!mHashCreateContext) &#123;</span><br><span class="line">                    mEglHelper.initCreateEgl(videoRecorder.mSurface, videoRecorder.mEglContext);</span><br><span class="line">                    mHashCreateContext = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回调 Render</span></span><br><span class="line">                GL10 gl = (GL10) mEglHelper.getEglContext().getGL();</span><br><span class="line">                <span class="keyword">if</span> (!mHashSurfaceCreated) &#123;</span><br><span class="line">                    videoRecorder.mRenderer.onSurfaceCreated(gl, mEglHelper.getEGLConfig());</span><br><span class="line">                    mHashSurfaceCreated = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mHashSurfaceChanged) &#123;</span><br><span class="line">                    videoRecorder.mRenderer.onSurfaceChanged(gl, mWidth, mHeight);</span><br><span class="line">                    mHashSurfaceChanged = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                videoRecorder.mRenderer.onDrawFrame(gl);</span><br><span class="line"></span><br><span class="line">                mEglHelper.swapBuffers();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 60 fps</span></span><br><span class="line">                Thread.sleep(<span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mEglHelper.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mWidth = width;</span><br><span class="line">        <span class="keyword">this</span>.mHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-视频编码录制"><a href="#3-视频编码录制" class="headerlink" title="3.视频编码录制"></a>3.视频编码录制</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频的编码线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoEncoderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaMuxer mMediaMuxer;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoRecorder&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mVideoCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mVideoTrackIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mVideoPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier mStartCb, mDestroyCb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoEncoderThread</span><span class="params">(WeakReference&lt;BaseVideoRecorder&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mVideoCodec = videoRecorderWr.get().mVideoCodec;</span><br><span class="line">        mMediaMuxer = videoRecorderWr.get().mMediaMuxer;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        mStartCb = videoRecorderWr.get().mStartCb;</span><br><span class="line">        mDestroyCb = videoRecorderWr.get().mDestroyCb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoRecorder videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 代码先不写，先测试，从 surface 上获取数据，编码成 h264 ,通过 MediaMuxer 合成 mp4</span></span><br><span class="line">                <span class="keyword">int</span> outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    mVideoTrackIndex = mMediaMuxer.addTrack(mVideoCodec.getOutputFormat());</span><br><span class="line">                    mMediaMuxer.start();</span><br><span class="line">                    mStartCb.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取数据</span></span><br><span class="line">                        ByteBuffer outBuffer = mVideoCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                        outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                        outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改 pts</span></span><br><span class="line">                        <span class="keyword">if</span> (mVideoPts == <span class="number">0</span>) &#123;</span><br><span class="line">                            mVideoPts = mBufferInfo.presentationTimeUs;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mBufferInfo.presentationTimeUs -= mVideoPts;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 写入数据</span></span><br><span class="line">                        mMediaMuxer.writeSampleData(mVideoTrackIndex, outBuffer, mBufferInfo);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 回调当前录制的时间</span></span><br><span class="line">                        <span class="keyword">if</span> (videoRecorder.mRecordListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            videoRecorder.mRecordListener.onTime(mBufferInfo.presentationTimeUs / <span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        mVideoCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                        outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.stop();</span><br><span class="line">            mVideoCodec.release();</span><br><span class="line">            mDestroyCb.await();</span><br><span class="line">            mMediaMuxer.stop();</span><br><span class="line">            mMediaMuxer.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：19.FFmpeg-视频加背景音乐、H.264协议</title>
    <url>/90.FFmpeg-%E8%A7%86%E9%A2%91%E5%8A%A0%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90%E3%80%81H.264%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p>
<h1 id="1-实现视频加背景音乐"><a href="#1-实现视频加背景音乐" class="headerlink" title="1.实现视频加背景音乐"></a>1.实现视频加背景音乐</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> MediaInfoListener mMediaInfoListener = <span class="keyword">new</span> MediaInfoListener() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mAudioPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSampleRate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mChannels = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">musicInfo</span><span class="params">(<span class="keyword">int</span> sampleRate, <span class="keyword">int</span> channels)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取了音频的信息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initAudioCodec(sampleRate, channels);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mSampleRate = sampleRate;</span><br><span class="line">        <span class="keyword">this</span>.mChannels = channels;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callbackPcm</span><span class="params">(<span class="keyword">byte</span>[] pcmData, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把数据写入到 mAudioCodec 的 InputBuffer</span></span><br><span class="line">        <span class="keyword">int</span> inputBufferIndex = mAudioCodec.dequeueInputBuffer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (inputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ByteBuffer byteBuffer = mAudioCodec.getInputBuffers()[inputBufferIndex];</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            byteBuffer.put(pcmData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pts  44100 * 2 *2</span></span><br><span class="line">            mAudioPts += size * <span class="number">1000000</span> / mSampleRate * mChannels * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// size 22050*2*2</span></span><br><span class="line">            mAudioCodec.queueInputBuffer(inputBufferIndex, <span class="number">0</span>, size, mAudioPts, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频的编码线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioEncoderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaMuxer mMediaMuxer;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoRecorder&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mAudioCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAudioTrackIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mAudioPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier mStartCb, mDestroyCb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioEncoderThread</span><span class="params">(WeakReference&lt;BaseVideoRecorder&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mAudioCodec = videoRecorderWr.get().mAudioCodec;</span><br><span class="line">        mMediaMuxer = videoRecorderWr.get().mMediaMuxer;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        mStartCb = videoRecorderWr.get().mStartCb;</span><br><span class="line">        mDestroyCb = videoRecorderWr.get().mDestroyCb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoRecorder videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取音频数据，那这个音频数据从哪里来？音乐播放器里面来，pcm 数据</span></span><br><span class="line">                <span class="keyword">int</span> outputBufferIndex = mAudioCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    mAudioTrackIndex = mMediaMuxer.addTrack(mAudioCodec.getOutputFormat());</span><br><span class="line">                    mStartCb.await();</span><br><span class="line">                    <span class="comment">// mMediaMuxer.start();</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取数据</span></span><br><span class="line">                        ByteBuffer outBuffer = mAudioCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                        outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                        outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改 pts</span></span><br><span class="line">                        <span class="keyword">if</span> (mAudioPts == <span class="number">0</span>) &#123;</span><br><span class="line">                            mAudioPts = mBufferInfo.presentationTimeUs;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mBufferInfo.presentationTimeUs -= mAudioPts;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 写入数据</span></span><br><span class="line">                        mMediaMuxer.writeSampleData(mAudioTrackIndex, outBuffer, mBufferInfo);</span><br><span class="line"></span><br><span class="line">                        mAudioCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                        outputBufferIndex = mAudioCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAudioCodec.stop();</span><br><span class="line">            mAudioCodec.release();</span><br><span class="line">            mDestroyCb.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/90.%E8%A7%86%E9%A2%91%E5%BD%95%E5%88%B6%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt></p>
<h1 id="2-详解H-264协议"><a href="#2-详解H-264协议" class="headerlink" title="2.详解H.264协议"></a>2.详解H.264协议</h1><p><img src="/images/90.h264%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3.png" alt></p>
<p>首先需要明确 H264 可以分为两层，对于 VCL 具体的编解码算法这里暂时先不介绍，只介绍常用的 NAL 层，即网络提取层，这是解码的基础。：<br>1.VCL video codinglayer（视频编码层）<br>2.NAL network abstraction layer（网络提取层）。</p>
<p><img src="/images/90.NAL.png" alt></p>
<ul>
<li>SPS：序列参数集</li>
<li>PPS：图像参数集</li>
<li>I帧：帧内编码帧，可独立解码生成完整的图片。</li>
<li>P帧: 前向预测编码帧，需要参考其前面的一个I 或者B 来生成一张完整的图片。</li>
<li>B帧: 双向预测内插编码帧，则要参考其前一个I或者P帧及其后面的一个P帧来生成一张完整的图片</li>
</ul>
<h1 id="4-获取-MediaCodec-的-sps-和-pps"><a href="#4-获取-MediaCodec-的-sps-和-pps" class="headerlink" title="4.获取 MediaCodec 的 sps 和 pps"></a>4.获取 MediaCodec 的 sps 和 pps</h1><ul>
<li>SPS：Sequence Paramater Set，又称作序列参数集。SPS中保存了一组编码视频序列(Coded video sequence)的全局参数。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列</li>
<li>PPS:除了序列参数集SPS之外，H.264中另一重要的参数集合为图像参数集Picture Paramater Set(PPS)。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频的编码线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoEncoderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mVideoCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mVideoPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier mStartCb, mDestroyCb;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] mVideoSps,mVideoPps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoEncoderThread</span><span class="params">(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mVideoCodec = videoRecorderWr.get().mVideoCodec;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        mStartCb = videoRecorderWr.get().mStartCb;</span><br><span class="line">        mDestroyCb = videoRecorderWr.get().mDestroyCb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoPush videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 代码先不写，先测试，从 surface 上获取数据，编码成 h264 ,通过 MediaMuxer 合成 mp4</span></span><br><span class="line">                <span class="keyword">int</span> outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    <span class="comment">// mStartCb.await();</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取 sps 和 pps</span></span><br><span class="line">                    Log.e(<span class="string">"TAG"</span>, <span class="string">"获取 sps 和 pps"</span>);</span><br><span class="line">                    ByteBuffer byteBuffer = mVideoCodec.getOutputFormat().getByteBuffer(<span class="string">"csd-0"</span>);</span><br><span class="line">                    mVideoSps = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                    byteBuffer.get(mVideoSps, <span class="number">0</span>, mVideoSps.length);</span><br><span class="line"></span><br><span class="line">                    Log.e(<span class="string">"sps"</span>, bytesToHexString(mVideoSps));</span><br><span class="line"></span><br><span class="line">                    byteBuffer = mVideoCodec.getOutputFormat().getByteBuffer(<span class="string">"csd-1"</span>);</span><br><span class="line">                    mVideoPps = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                    byteBuffer.get(mVideoPps, <span class="number">0</span>, mVideoPps.length);</span><br><span class="line"></span><br><span class="line">                    Log.e(<span class="string">"pps"</span>, bytesToHexString(mVideoPps));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取数据</span></span><br><span class="line">                        ByteBuffer outBuffer = mVideoCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                        outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                        outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改 pts</span></span><br><span class="line">                        <span class="keyword">if</span> (mVideoPts == <span class="number">0</span>) &#123;</span><br><span class="line">                            mVideoPts = mBufferInfo.presentationTimeUs;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mBufferInfo.presentationTimeUs -= mVideoPts;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[outBuffer.remaining()];</span><br><span class="line">                        outBuffer.get(data, <span class="number">0</span>, data.length);</span><br><span class="line">                        Log.e(<span class="string">"TAG"</span>,bytesToHexString(data));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 回调当前录制的时间</span></span><br><span class="line">                        <span class="keyword">if</span> (videoRecorder.mRecordListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            videoRecorder.mRecordListener.onTime(mBufferInfo.presentationTimeUs / <span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        mVideoCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                        outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.stop();</span><br><span class="line">            mVideoCodec.release();</span><br><span class="line">            <span class="comment">// mDestroyCb.await();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：16.FFmpeg-视频播放器2</title>
    <url>/87.FFmpeg-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A82/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg86" target="_blank" rel="noopener">NDKPractice项目的ffmpeg87</a></strong></p>
<h1 id="1-调整音乐播放器项目架构"><a href="#1-调整音乐播放器项目架构" class="headerlink" title="1.调整音乐播放器项目架构"></a>1.调整音乐播放器项目架构</h1><p>解码的流程 Video 和 Audio 很多相同的，所以抽离出来了公共类: Media.cpp</p>
<p>音频和视频单独处理成：Audio.cpp 和 Video.cpp，都继承自Media,cpp</p>
<p>遇到的问题：<font color="red">下面这个方法的env 不能使用 pJniCall-&gt;jniEnv</font></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Video::setSurface</span><span class="params">(JNIEnv *env, jobject surface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里不能使用pJniCall-&gt;jniEnv-&gt;的env，因为和native方法传递过来的不一样，而且不相等</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注释的这行代码会报错</span></span><br><span class="line"><span class="comment">     *   'JNI DETECTED ERROR IN APPLICATION: invalid address...,thread Thread[21,tid=25717,Native,Thread*=0xc2e4a000,peer=0x12e40000,"Thread-3"] using JNIEnv* from thread Thread[1,tid=25650,Runnable,Thread*=0xf1b71e00,peer=0x757719a0,"main"]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    this-&gt;surface = pJniCall-&gt;jniEnv-&gt;NewGlobalRef(surface);</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;videoJNIEnv = env;</span><br><span class="line">    <span class="keyword">this</span>-&gt;surface = env-&gt;NewGlobalRef(surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-视音频的同步"><a href="#2-视音频的同步" class="headerlink" title="2. 视音频的同步"></a>2. 视音频的同步</h1><p><img src="/images/87.%E8%A7%86%E9%9F%B3%E9%A2%91%E5%90%8C%E6%AD%A5.png" alt></p>
<ul>
<li>pts：显示时间戳，用来告诉播放器该在什么时候显示这一帧数据。单位是不确定，所以使用时间基来获取单位</li>
<li>time_base：时间度量单位（时间基）。</li>
</ul>
<p>有三种办法：</p>
<ol>
<li>参考一个外部时钟，将音频与视频同步至此时间。</li>
<li>以视频为基准，音频去同步视频的时间。</li>
<li>以音频为基准，视频去同步音频的时间。</li>
</ol>
<p><code>由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以采用方案 3</code></p>
<ul>
<li><code>static inline double av_q2d(AVRational a)</code>：使用时间基获取单位</li>
<li><code>timeBase = pFormatContext-&gt;streams[streamIndex]-&gt;time_base;</code>：获取时间基</li>
<li><code>duration = pFormatContext-&gt;duration;</code>：获取音视频时长（<code>单位微秒</code>）</li>
<li><code>double times = av_frame_get_best_effort_timestamp(pFrame) * av_q2d(timeBase);</code>: 获取当前时间</li>
<li><code>double times = pPacket-&gt;pts * av_q2d(timeBase);</code>: 获取当前时间</li>
<li><code>av_usleep(frameSleepTime * 1000000);</code>：休眠（<code>单位毫秒</code>）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 播放之前判断一下要休眠多久</span></span><br><span class="line"><span class="keyword">double</span> frameSleepTime = pVideo-&gt;getFrameSleepTime(pPacket,pFrame); <span class="comment">// 这是秒</span></span><br><span class="line">av_usleep(frameSleepTime * <span class="number">1000000</span>);<span class="comment">// 这是毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Video::getFrameSleepTime</span><span class="params">(AVPacket *pPacket,AVFrame *pFrame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这两种方法都能算出当前显示帧的时间</span></span><br><span class="line"><span class="comment">//    double times = av_frame_get_best_effort_timestamp(pFrame) * av_q2d(timeBase);</span></span><br><span class="line">    <span class="keyword">double</span> times = pPacket-&gt;pts * av_q2d(timeBase);</span><br><span class="line">    <span class="keyword">if</span> (times &gt; currentTime) &#123;</span><br><span class="line">        currentTime = times;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相差多少秒</span></span><br><span class="line">    <span class="keyword">double</span> diffTime = pAudio-&gt;currentTime - currentTime; <span class="comment">// 负数，音频比视频慢</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视频快了就慢点，视频慢了就快点</span></span><br><span class="line">    <span class="comment">// 但是尽量把事件控制在视频的帧率时间范围左右  1/24 0.04 1/30 0.033</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次控制 0.016s 到 -0.016s</span></span><br><span class="line">    <span class="keyword">if</span> (diffTime &gt; <span class="number">0.016</span> || diffTime &lt; <span class="number">-0.016</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (diffTime &gt; <span class="number">0.016</span>) &#123;</span><br><span class="line">            delayTime = delayTime * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diffTime &lt; <span class="number">-0.016</span>) &#123;</span><br><span class="line">            delayTime = delayTime * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次控制 defaultDelayTIme * 2 / 3 到 defaultDelayTime * 3 / 2</span></span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt; defaultDelayTime / <span class="number">2</span>) &#123;</span><br><span class="line">            delayTime = defaultDelayTime * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delayTime &gt; defaultDelayTime * <span class="number">2</span>) &#123;</span><br><span class="line">            delayTime = defaultDelayTime * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三次控制，这基本是异常情况</span></span><br><span class="line">    <span class="keyword">if</span> (diffTime &gt;= <span class="number">0.25</span>)</span><br><span class="line">        delayTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diffTime &lt;= <span class="number">-0.25</span>)</span><br><span class="line">        delayTime = defaultDelayTime * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">"diffTime = %lf秒,delayTime = %lf秒,\n"</span></span><br><span class="line">         <span class="string">"pAudio-&gt;currentTime = %lf秒,cureentTime = %lf秒,duration = %d秒"</span>,diffTime,delayTime,pAudio-&gt;currentTime,currentTime,duration/<span class="number">1000</span>/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delayTime;</span><br><span class="line"><span class="comment">//    return -diffTime;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还差：暂停，停止，回调，倍速播放，硬解码</p>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next博客搭建</title>
    <url>/Hexo+Next%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>这里我们使用 GitHub Pages 来搭建 Hexo 静态博客网站，其最吸引人的莫过于完全免费使用，并且非常稳定。</p>
<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h1><h2 id="GitHub-Pages-是什么？"><a href="#GitHub-Pages-是什么？" class="headerlink" title="GitHub Pages 是什么？"></a>GitHub Pages 是什么？</h2><p>GitHub Pages 是由 GitHub 官方提供的一种免费的静态站点托管服务，让我们可以在 GitHub 仓库里托管和发布自己的静态网站页面。</p>
<h2 id="Hexo-是什么？"><a href="#Hexo-是什么？" class="headerlink" title="Hexo 是什么？"></a>Hexo 是什么？</h2><p>Hexo 是一个快速、简洁且高效的静态博客框架，它基于 Node.js 运行，可以将我们撰写的 Markdown 文档解析渲染成静态的 HTML 网页。</p>
<h2 id="Hexo-GitHub-文章发布原理"><a href="#Hexo-GitHub-文章发布原理" class="headerlink" title="Hexo + GitHub 文章发布原理"></a>Hexo + GitHub 文章发布原理</h2><p>在本地撰写 Markdown 格式文章后，通过 Hexo 解析文档，渲染生成具有主题样式的 HTML 静态网页，再推送到 GitHub 上完成博文的发布。  </p>
<h1 id="2-环境安装"><a href="#2-环境安装" class="headerlink" title="2.环境安装"></a>2.环境安装</h1><p>Hexo 基于 <code>Node.js</code>，搭建过程中还需要使用 npm（Node.js 已带） 和 <code>git</code>，因此先搭建本地操作环境，安装 Node.js 和 Git。</p>
<ul>
<li>下载安装<a href="https://nodejs.org/zh-cn" target="_blank" rel="noopener">Node.js</a></li>
<li>下载安装<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a></li>
</ul>
<p>检查是否安装成功：进入终端，依次输入 <code>node -v</code>、<code>npm -v</code> 和 <code>git --version</code> 并回车，出现程序版本号即可。</p>
<h1 id="3-Github配置"><a href="#3-Github配置" class="headerlink" title="3.Github配置"></a>3.Github配置</h1><h2 id="3-1连接Github"><a href="#3-1连接Github" class="headerlink" title="3.1连接Github"></a>3.1连接Github</h2><p>右键 -&gt; Git Bash Here，设置用户名和邮箱：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;GitHub 用户名&quot;</span><br><span class="line">git config --global user.email &quot;GitHub 邮箱&quot;</span><br></pre></td></tr></table></figure>

<h2 id="3-2创建-SSH-密匙添加到Github上"><a href="#3-2创建-SSH-密匙添加到Github上" class="headerlink" title="3.2创建 SSH 密匙添加到Github上"></a>3.2创建 SSH 密匙添加到Github上</h2><p>输入 <code>ssh-keygen -t rsa -C &quot;GitHub 邮箱&quot;</code>，然后一路回车。</p>
<p>进入 [C:\Users\用户名.ssh] 目录（要勾选显示“隐藏的项目”），用记事本打开公钥 id_rsa.pub 文件并复制里面的内容。</p>
<p>登陆 GitHub ，点击用户头像进入 Settings 页面，选择左边栏的 SSH and GPG keys，点击 New SSH key。</p>
<p>Title 随便取个名字，粘贴复制的 id_rsa.pub 内容到 Key 中，点击 Add SSH key 完成添加。</p>
<p><strong>验证连接</strong>：打开 Git Bash，输入 <code>ssh -T git@github.com</code> 出现 <code>“Are you sure……”</code>，输入 yes 回车确认。显示 <code>“Hi xxx! You&#39;ve successfully……”</code> 即连接成功。</p>
<h2 id="3-3创建-Github-Pages-仓库"><a href="#3-3创建-Github-Pages-仓库" class="headerlink" title="3.3创建 Github Pages 仓库"></a>3.3创建 Github Pages 仓库</h2><p>GitHub 主页右上角加号 -&gt; New repository：</p>
<ul>
<li>Repository name 中输入 用户名.github.io</li>
<li>勾选 “Initialize this repository with a README”</li>
<li>Description 选填</li>
</ul>
<p>填好后点击 Create repository 创建。</p>
<p>创建后默认自动启用 HTTPS，博客地址为：<code>https://用户名.github.io</code></p>
<h1 id="4-本地安装-Hexo-博客程序"><a href="#4-本地安装-Hexo-博客程序" class="headerlink" title="4.本地安装 Hexo 博客程序"></a>4.本地安装 Hexo 博客程序</h1><h2 id="4-1安装-Hexo"><a href="#4-1安装-Hexo" class="headerlink" title="4.1安装 Hexo"></a>4.1安装 Hexo</h2><p>使用使用 npm 一键安装 Hexo 博客程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; linux或mac用户需要管理员权限（sudo），运行这条命令：</span><br><span class="line"></span><br><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Hexo-初始化和本地预览"><a href="#4-2-Hexo-初始化和本地预览" class="headerlink" title="4.2 Hexo 初始化和本地预览"></a>4.2 Hexo 初始化和本地预览</h2><p>初始化并安装所需组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init      # 初始化</span><br><span class="line">npm install    # 安装组件</span><br></pre></td></tr></table></figure>

<p>完成后依次输入下面命令，启动本地服务器进行预览：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g   # 生成页面</span><br><span class="line">hexo s   # 启动预览</span><br></pre></td></tr></table></figure>

<p>访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 出现 Hexo 默认页面，本地博客安装成功！</p>
<p>Hexo 博客文件夹目录结构如下：<br><img src="/images/hexo%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg" alt></p>
<h1 id="5-部署-Hexo-到-GitHub-Pages"><a href="#5-部署-Hexo-到-GitHub-Pages" class="headerlink" title="5. 部署 Hexo 到 GitHub Pages"></a>5. 部署 Hexo 到 GitHub Pages</h1><p>首先安装 hexo-deployer-git：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>然后修改 _config.yml 文件末尾的 Deployment 部分，修改成如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名&#x2F;用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>完成后运行 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d #部署到GitHub Pages</span><br></pre></td></tr></table></figure>

<p>将网站上传部署到 GitHub Pages。这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p>
<h1 id="6-安装Next主题"><a href="#6-安装Next主题" class="headerlink" title="6.安装Next主题"></a>6.安装Next主题</h1><p>进入网站目录打开 Git Bash Here 下载主题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>然后修改 hexo的 <code>_config.yml</code> 中的 <code>theme</code> 为新主题名称 <code>next</code>。</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：20.FFmpeg-直播推流到服务器、加滤镜效果</title>
    <url>/91.FFmpeg-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E5%8A%A0%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p>
<h1 id="ffmpeg测试流媒体服务器播放地址"><a href="#ffmpeg测试流媒体服务器播放地址" class="headerlink" title="ffmpeg测试流媒体服务器播放地址"></a>ffmpeg测试流媒体服务器播放地址</h1><p>windows ffmpeg<a href="https://github.com/BtbN/FFmpeg-Builds/releases" target="_blank" rel="noopener">下载地址</a></p>
<p>mac 和 linux 类似，进入<a href="http://www.ffmpeg.org/download.html" target="_blank" rel="noopener">官网下载</a> 。</p>
<p>下面以windows为例测试步骤：</p>
<ol>
<li>进入下载好的ffmpeg解压目录的/bin目录文件夹下</li>
<li>使用命令拉流：<code>ffplay.exe rtmp://192.168.1.20/myapp/mystream</code></li>
</ol>
<h1 id="1-录制声音获取-PCM-数据"><a href="#1-录制声音获取-PCM-数据" class="headerlink" title="1.录制声音获取 PCM 数据"></a>1.录制声音获取 PCM 数据</h1><p>使用<code>AudioRecord</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频的采集线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioRecordThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMinBufferSize;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mAudioCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAudioTrackIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mAudioPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> AudioRecord mAudioRecord; <span class="comment">//录音的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] mAudioData;<span class="comment">// 这是 pcm 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioRecordThread</span><span class="params">(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mAudioCodec = videoRecorderWr.get().mAudioCodec;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line"></span><br><span class="line">        mMinBufferSize = AudioRecord.getMinBufferSize(</span><br><span class="line">                BaseVideoPush.AUDIO_SAMPLE_RATE,</span><br><span class="line">                AudioFormat.CHANNEL_IN_STEREO,<span class="comment">//立体声</span></span><br><span class="line">                AudioFormat.ENCODING_PCM_16BIT);</span><br><span class="line"></span><br><span class="line">        mAudioRecord = <span class="keyword">new</span> AudioRecord(MediaRecorder.AudioSource.MIC,</span><br><span class="line">                BaseVideoPush.AUDIO_SAMPLE_RATE,</span><br><span class="line">                AudioFormat.CHANNEL_IN_STEREO,<span class="comment">//立体声</span></span><br><span class="line">                AudioFormat.ENCODING_PCM_16BIT,</span><br><span class="line">                mMinBufferSize);</span><br><span class="line"></span><br><span class="line">        mAudioData = <span class="keyword">new</span> <span class="keyword">byte</span>[mMinBufferSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启录制</span></span><br><span class="line">            mAudioRecord.startRecording();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不断读取 pcm 数据</span></span><br><span class="line">                mAudioRecord.read(mAudioData, <span class="number">0</span>, mMinBufferSize);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把数据写入到 mAudioCodec 的 InputBuffer</span></span><br><span class="line">                <span class="keyword">int</span> inputBufferIndex = mAudioCodec.dequeueInputBuffer(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (inputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ByteBuffer byteBuffer = mAudioCodec.getInputBuffers()[inputBufferIndex];</span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                    byteBuffer.put(mAudioData);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// pts  44100 * 2 *2</span></span><br><span class="line">                    mAudioPts += mMinBufferSize * <span class="number">1000000</span> / BaseVideoPush.AUDIO_SAMPLE_RATE * BaseVideoPush.AUDIO_CHANNELS * <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// size 22050*2*2</span></span><br><span class="line">                    mAudioCodec.queueInputBuffer(inputBufferIndex, <span class="number">0</span>, mMinBufferSize, mAudioPts, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAudioCodec.stop();</span><br><span class="line">            mAudioCodec.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-推送视频画面到媒体房间"><a href="#2-推送视频画面到媒体房间" class="headerlink" title="2.推送视频画面到媒体房间"></a>2.推送视频画面到媒体房间</h1><p><img src="/images/91.%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%8E%9F%E7%90%86.png" alt></p>
<p>为什么要封装成<code>flv</code>：为了不定死 <code>h264</code>协议</p>
<p>flv 封装格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; FLV 的封装格式</span><br><span class="line">&#x2F;&#x2F; frame type : 1关键帧，2 非关键帧（4Bit）</span><br><span class="line">&#x2F;&#x2F; CodecID : 7表示 AVC(4bit) , 与 frame type组合起来刚好是 1 个字节 0x17</span><br><span class="line">&#x2F;&#x2F; fixed ： 0x00 0x00 0x00 0x00 (4byte)</span><br><span class="line">&#x2F;&#x2F; configurationVersion  (1byte) 0x01版本</span><br><span class="line">&#x2F;&#x2F; AVCProfileIndication  (1byte) sps[1] profile</span><br><span class="line">&#x2F;&#x2F; profile_compatibility (1byte) sps[2] compatibility</span><br><span class="line">&#x2F;&#x2F; AVCLevelIndication    (1byte) sps[3] Profile level</span><br><span class="line">&#x2F;&#x2F; lengthSizeMinusOne    (1byte) 0xff   包长数据所使用的字节数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sps + pps 的数据</span><br><span class="line">&#x2F;&#x2F; sps number            (1byte) 0xe1   sps 个数</span><br><span class="line">&#x2F;&#x2F; sps data length       (2byte) sps 长度</span><br><span class="line">&#x2F;&#x2F; sps data                      sps 的内容</span><br><span class="line">&#x2F;&#x2F; pps number            (1byte) 0x01 pps 个数</span><br><span class="line">&#x2F;&#x2F; pps data length       (2byte) pps 长度</span><br><span class="line">&#x2F;&#x2F; pps data                      pps 的内容</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BaseVideoPush：VideoEncoderThread</span><br><span class="line"></span><br><span class="line"> private static final class VideoEncoderThread extends Thread &#123;</span><br><span class="line">        private WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">        private volatile boolean mShouldExit &#x3D; false;</span><br><span class="line">        private MediaCodec mVideoCodec;</span><br><span class="line">        private MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">        private long mVideoPts &#x3D; 0;</span><br><span class="line">        private byte[] mVideoSps, mVideoPps;</span><br><span class="line"></span><br><span class="line">        public VideoEncoderThread(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr) &#123;</span><br><span class="line">            this.mVideoRecorderWr &#x3D; videoRecorderWr;</span><br><span class="line">            mVideoCodec &#x3D; videoRecorderWr.get().mVideoCodec;</span><br><span class="line">            mBufferInfo &#x3D; new MediaCodec.BufferInfo();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mVideoCodec.start();</span><br><span class="line"></span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (mShouldExit) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    BaseVideoPush videoRecorder &#x3D; mVideoRecorderWr.get();</span><br><span class="line">                    if (videoRecorder &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 代码先不写，先测试，从 surface 上获取数据，编码成 h264 ,通过 MediaMuxer 合成 mp4</span><br><span class="line">                    int outputBufferIndex &#x3D; mVideoCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line">                    if (outputBufferIndex &#x3D;&#x3D; MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F; 获取 sps 和 pps</span><br><span class="line">&#x2F;&#x2F;                        Log.e(&quot;TAG&quot;, &quot;获取 sps 和 pps&quot;);</span><br><span class="line">                        ByteBuffer byteBuffer &#x3D; mVideoCodec.getOutputFormat().getByteBuffer(&quot;csd-0&quot;);</span><br><span class="line">                        mVideoSps &#x3D; new byte[byteBuffer.remaining()];</span><br><span class="line">                        byteBuffer.get(mVideoSps, 0, mVideoSps.length);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                        Log.e(&quot;sps&quot;, bytesToHexString(mVideoSps));</span><br><span class="line"></span><br><span class="line">                        byteBuffer &#x3D; mVideoCodec.getOutputFormat().getByteBuffer(&quot;csd-1&quot;);</span><br><span class="line">                        mVideoPps &#x3D; new byte[byteBuffer.remaining()];</span><br><span class="line">                        byteBuffer.get(mVideoPps, 0, mVideoPps.length);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                        Log.e(&quot;pps&quot;, bytesToHexString(mVideoPps));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        while (outputBufferIndex &gt;&#x3D; 0) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 获取数据</span><br><span class="line">                            ByteBuffer outBuffer &#x3D; mVideoCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                            outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                            outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; 修改 pts</span><br><span class="line">                            if (mVideoPts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                mVideoPts &#x3D; mBufferInfo.presentationTimeUs;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mBufferInfo.presentationTimeUs -&#x3D; mVideoPts;</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; 在关键帧之前先把 sps 和 pps 推到流媒体服务器</span><br><span class="line">                            if(mBufferInfo.flags &#x3D;&#x3D; MediaCodec.BUFFER_FLAG_KEY_FRAME)&#123;</span><br><span class="line">                                mVideoRecorderWr.get().mLivePush.pushSpsPps(mVideoSps,mVideoSps.length,</span><br><span class="line">                                        mVideoPps,mVideoPps.length);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            byte[] data &#x3D; new byte[outBuffer.remaining()];</span><br><span class="line">                            outBuffer.get(data, 0, data.length);</span><br><span class="line">                            &#x2F;&#x2F; 推送视频到流媒体服务器上</span><br><span class="line">                            mVideoRecorderWr.get().mLivePush.pushVideo(data,data.length,</span><br><span class="line">                                    mBufferInfo.flags &#x3D;&#x3D; MediaCodec.BUFFER_FLAG_KEY_FRAME);</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; 回调当前录制的时间</span><br><span class="line">                            if (videoRecorder.mRecordListener !&#x3D; null) &#123;</span><br><span class="line">                                videoRecorder.mRecordListener.onTime(mBufferInfo.presentationTimeUs &#x2F; 1000);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            mVideoCodec.releaseOutputBuffer(outputBufferIndex, false);</span><br><span class="line">                            outputBufferIndex &#x3D; mVideoCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                onDestroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void onDestroy() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mVideoCodec.stop();</span><br><span class="line">                mVideoCodec.release();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void requestExit() &#123;</span><br><span class="line">            mShouldExit &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> LivePush::pushSpsPps(jbyte *spsData, jint spsLen, jbyte *ppsData, jint ppsLen) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FLV 的封装格式</span></span><br><span class="line">    <span class="comment">// frame type : 1关键帧，2 非关键帧（4Bit）</span></span><br><span class="line">    <span class="comment">// CodecID : 7表示 AVC(4bit) , 与 frame type组合起来刚好是 1 个字节 0x17</span></span><br><span class="line">    <span class="comment">// fixed ： 0x00 0x00 0x00 0x00 (4byte)</span></span><br><span class="line">    <span class="comment">// configurationVersion  (1byte) 0x01版本</span></span><br><span class="line">    <span class="comment">// AVCProfileIndication  (1byte) sps[1] profile</span></span><br><span class="line">    <span class="comment">// profile_compatibility (1byte) sps[2] compatibility</span></span><br><span class="line">    <span class="comment">// AVCLevelIndication    (1byte) sps[3] Profile level</span></span><br><span class="line">    <span class="comment">// lengthSizeMinusOne    (1byte) 0xff   包长数据所使用的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sps + pps 的数据</span></span><br><span class="line">    <span class="comment">// sps number            (1byte) 0xe1   sps 个数</span></span><br><span class="line">    <span class="comment">// sps data length       (2byte) sps 长度</span></span><br><span class="line">    <span class="comment">// sps data                      sps 的内容</span></span><br><span class="line">    <span class="comment">// pps number            (1byte) 0x01 pps 个数</span></span><br><span class="line">    <span class="comment">// pps data length       (2byte) pps 长度</span></span><br><span class="line">    <span class="comment">// pps data                      pps 的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据的长度（大小） = sps 大小 + pps 大小 + 头 16字节</span></span><br><span class="line">    <span class="keyword">int</span> bodySize = spsLen + ppsLen + <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 构建 RTMPPacket</span></span><br><span class="line">    RTMPPacket *pPacket = (RTMPPacket *) malloc(sizeof(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(pPacket, bodySize);</span><br><span class="line">    RTMPPacket_Reset(pPacket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 body 按上面的一个一个开始赋值</span></span><br><span class="line">    <span class="keyword">char</span> *body = pPacket-&gt;m_body;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    body[index++] = <span class="number">0x17</span>;</span><br><span class="line">    <span class="comment">// fixed ： 0x00 0x00 0x00 0x00 (4byte)</span></span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// configurationVersion  (1byte) 0x01版本</span></span><br><span class="line">    body[index++] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// AVCProfileIndication  (1byte) sps[1] profile</span></span><br><span class="line">    body[index++] = spsData[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// profile_compatibility (1byte) sps[2] compatibility</span></span><br><span class="line">    body[index++] = spsData[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// AVCLevelIndication    (1byte) sps[3] Profile level</span></span><br><span class="line">    body[index++] = spsData[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// lengthSizeMinusOne    (1byte) 0xff   包长数据所使用的字节数</span></span><br><span class="line">    body[index++] = <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// sps + pps 的数据</span></span><br><span class="line">    <span class="comment">// sps number            (1byte) 0xe1   sps 个数</span></span><br><span class="line">    body[index++] = <span class="number">0xe1</span>;</span><br><span class="line">    <span class="comment">// sps data length       (2byte) sps 长度</span></span><br><span class="line">    body[index++] = (spsLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    body[index++] = spsLen &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="comment">// sps data                      sps 的内容</span></span><br><span class="line">    memcpy(&amp;body[index], spsData, spsLen);</span><br><span class="line">    index += spsLen;</span><br><span class="line">    <span class="comment">// pps number            (1byte) 0x01 pps 个数</span></span><br><span class="line">    body[index++] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// pps data length       (2byte) pps 长度</span></span><br><span class="line">    body[index++] = (ppsLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    body[index++] = ppsLen &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="comment">// pps data                      pps 的内容</span></span><br><span class="line">    memcpy(&amp;body[index], ppsData, ppsLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RTMPPacket 设置一些信息</span></span><br><span class="line">    pPacket-&gt;m_hasAbsTimestamp = <span class="number">0</span>;</span><br><span class="line">    pPacket-&gt;m_nTimeStamp = <span class="number">0</span>;</span><br><span class="line">    pPacket-&gt;m_headerType = RTMP_PACKET_SIZE_MEDIUM;</span><br><span class="line">    pPacket-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    pPacket-&gt;m_nBodySize = bodySize;</span><br><span class="line">    pPacket-&gt;m_nChannel = <span class="number">0x04</span>;</span><br><span class="line">    pPacket-&gt;m_nInfoField2 = <span class="keyword">this</span>-&gt;pRtmp-&gt;m_stream_id;</span><br><span class="line"></span><br><span class="line">    pPacketQueue-&gt;push(pPacket);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LivePush::pushVideoData(jbyte *videoData, jint dataLen, jboolean keyFrame) &#123;</span><br><span class="line">    &#x2F;&#x2F; frame type : 1关键帧，2非关键帧 (4bit)</span><br><span class="line">    &#x2F;&#x2F; CodecID: 7表示 AVC(4bit),与 frame type 组合起来刚好是 1 个字节 0x17</span><br><span class="line">    &#x2F;&#x2F; fixed：0x01 0x00 0x00 0x00 (4byte),0x01 表示 NALU 单元</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; video data length  (4byte) video长度</span><br><span class="line">    &#x2F;&#x2F; video data</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据的长度（大小） &#x3D; dataLen + 头 9字节</span><br><span class="line">    int bodySize &#x3D; dataLen + 9;</span><br><span class="line">    &#x2F;&#x2F; 构建 RTMPPacket</span><br><span class="line">    RTMPPacket *pPacket &#x3D; (RTMPPacket *) malloc(sizeof(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(pPacket, bodySize);</span><br><span class="line">    RTMPPacket_Reset(pPacket);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构建 body 按上面的一个一个开始赋值</span><br><span class="line">    char *body &#x3D; pPacket-&gt;m_body;</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; frame type : 1关键帧，2非关键帧 (4bit)</span><br><span class="line">    &#x2F;&#x2F; CodecID: 7表示 AVC(4bit),与 frame type 组合起来刚好是 1 个字节 0x17</span><br><span class="line">    if (keyFrame)</span><br><span class="line">        body[index++] &#x3D; 0x17;</span><br><span class="line">    else</span><br><span class="line">        body[index++] &#x3D; 0x27;</span><br><span class="line">    &#x2F;&#x2F; fixed：0x01 0x00 0x00 0x00 (4byte),0x01 表示 NALU 单元</span><br><span class="line">    body[index++] &#x3D; 0x01;</span><br><span class="line">    body[index++] &#x3D; 0x00;</span><br><span class="line">    body[index++] &#x3D; 0x00;</span><br><span class="line">    body[index++] &#x3D; 0x00;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; video data length  (4byte) video长度</span><br><span class="line">    body[index++] &#x3D; (dataLen &gt;&gt; 24) &amp; 0xFF;</span><br><span class="line">    body[index++] &#x3D; (dataLen &gt;&gt; 16) &amp; 0xFF;</span><br><span class="line">    body[index++] &#x3D; (dataLen &gt;&gt; 8) &amp; 0xFF;</span><br><span class="line">    body[index++] &#x3D; dataLen &amp; 0xFF;</span><br><span class="line">    &#x2F;&#x2F; video data</span><br><span class="line">    memcpy(&amp;body[index], videoData, dataLen);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; RTMPPacket 设置一些信息</span><br><span class="line">    pPacket-&gt;m_headerType &#x3D; RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    pPacket-&gt;m_packetType &#x3D; RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    pPacket-&gt;m_hasAbsTimestamp &#x3D; 0;</span><br><span class="line">    pPacket-&gt;m_nTimeStamp &#x3D; RTMP_GetTime() - startTime;</span><br><span class="line">    pPacket-&gt;m_nBodySize &#x3D; bodySize;</span><br><span class="line">    pPacket-&gt;m_nChannel &#x3D; 0x04;</span><br><span class="line">    pPacket-&gt;m_nInfoField2 &#x3D; this-&gt;pRtmp-&gt;m_stream_id;</span><br><span class="line"></span><br><span class="line">    pPacketQueue-&gt;push(pPacket);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="3-推送声音到媒体房间"><a href="#3-推送声音到媒体房间" class="headerlink" title="3.推送声音到媒体房间"></a>3.推送声音到媒体房间</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 音频的编码线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final class AudioEncoderThread extends Thread &#123;</span><br><span class="line">    private WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">    private volatile boolean mShouldExit &#x3D; false;</span><br><span class="line">    private MediaCodec mAudioCodec;</span><br><span class="line">    private MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    private long mAudioPts &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public AudioEncoderThread(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr) &#123;</span><br><span class="line">        this.mVideoRecorderWr &#x3D; videoRecorderWr;</span><br><span class="line">        mAudioCodec &#x3D; videoRecorderWr.get().mAudioCodec;</span><br><span class="line">        mBufferInfo &#x3D; new MediaCodec.BufferInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 开启 start AudioCodec</span><br><span class="line">            mAudioCodec.start();</span><br><span class="line"></span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (mShouldExit) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoPush videoRecorder &#x3D; mVideoRecorderWr.get();</span><br><span class="line">                if (videoRecorder &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 获取音频数据，那这个音频数据从哪里来？音乐播放器里面来，pcm 数据</span><br><span class="line">                int outputBufferIndex &#x3D; mAudioCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line"></span><br><span class="line">                while (outputBufferIndex &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取数据</span><br><span class="line">                    ByteBuffer outBuffer &#x3D; mAudioCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                    outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                    outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 修改 pts</span><br><span class="line">                    if (mAudioPts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        mAudioPts &#x3D; mBufferInfo.presentationTimeUs;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mBufferInfo.presentationTimeUs -&#x3D; mAudioPts;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 打印一下音频的 AAC 数据</span><br><span class="line">                    byte[] data &#x3D; new byte[outBuffer.remaining()];</span><br><span class="line">                    outBuffer.get(data, 0, data.length);</span><br><span class="line">                    &#x2F;&#x2F; 推送音频数据到流媒体</span><br><span class="line">                    mVideoRecorderWr.get().mLivePush.pushAudio(data,data.length);</span><br><span class="line"></span><br><span class="line">                    mAudioCodec.releaseOutputBuffer(outputBufferIndex, false);</span><br><span class="line">                    outputBufferIndex &#x3D; mAudioCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void onDestroy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mAudioCodec.stop();</span><br><span class="line">            mAudioCodec.release();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void requestExit() &#123;</span><br><span class="line">        mShouldExit &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void LivePush::pushAudioData(jbyte *audioData, jint dataLen) &#123;</span><br><span class="line">    &#x2F;&#x2F; 2个字节头信息：</span><br><span class="line">        &#x2F;&#x2F; 前四位表示音频数据格式 AAC ：十进制的10(A) -&gt; 二进制：1010 -&gt; 十六进制：A</span><br><span class="line">        &#x2F;&#x2F; 五六位表示采样率 十进制：0&#x3D;5.5k   十进制：1&#x3D;11k   十进制：2&#x3D;22k   十进制：3(二进制：11)&#x3D;44k</span><br><span class="line">        &#x2F;&#x2F; 七位表示采样的精度 0&#x3D;8bits  1&#x3D;16bits</span><br><span class="line">        &#x2F;&#x2F; 八位表示音频类型 0&#x3D;mono   1&#x3D;stereo</span><br><span class="line">        &#x2F;&#x2F; 我们这里算出来第一个字节是 0xAF &#x3D; 1010 1111</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 0x01 代表 aac 原始数据</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据的长度（大小） &#x3D; dataLen + 2</span><br><span class="line">    int bodySize &#x3D; dataLen + 2;</span><br><span class="line">    &#x2F;&#x2F; 构建 RTMPPacket</span><br><span class="line">    RTMPPacket *pPacket &#x3D; (RTMPPacket *) malloc(sizeof(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(pPacket, bodySize);</span><br><span class="line">    RTMPPacket_Reset(pPacket);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构建 body 按上面的一个一个开始赋值</span><br><span class="line">    char *body &#x3D; pPacket-&gt;m_body;</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    body[index++] &#x3D; 0xAF;</span><br><span class="line">    &#x2F;&#x2F; 0x01 代表 aac 原始数据</span><br><span class="line">    body[index++] &#x3D; 0x01;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; audio data</span><br><span class="line">    memcpy(&amp;body[index], audioData, dataLen);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; RTMPPacket 设置一些信息</span><br><span class="line">    pPacket-&gt;m_headerType &#x3D; RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    pPacket-&gt;m_packetType &#x3D; RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">    pPacket-&gt;m_hasAbsTimestamp &#x3D; 0;</span><br><span class="line">    pPacket-&gt;m_nTimeStamp &#x3D; RTMP_GetTime() - startTime;</span><br><span class="line">    pPacket-&gt;m_nBodySize &#x3D; bodySize;</span><br><span class="line">    pPacket-&gt;m_nChannel &#x3D; 0x04;</span><br><span class="line">    pPacket-&gt;m_nInfoField2 &#x3D; this-&gt;pRtmp-&gt;m_stream_id;</span><br><span class="line"></span><br><span class="line">    pPacketQueue-&gt;push(pPacket);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-滤镜效果处理"><a href="#4-滤镜效果处理" class="headerlink" title="4.滤镜效果处理"></a>4.滤镜效果处理</h1><p>// 设置纹理渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * |---------------------------------------------------------------------------------------------------------------|</span><br><span class="line"> *  @description:  灰色视频的推流</span><br><span class="line"> *  @author: jamin</span><br><span class="line"> *  @date: 2020&#x2F;10&#x2F;20 13:39</span><br><span class="line"> * |---------------------------------------------------------------------------------------------------------------|</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class GrayVideoPush extends BaseVideoPush &#123;</span><br><span class="line">    private PushRenderer mPushRenderer;</span><br><span class="line"></span><br><span class="line">    public GrayVideoPush(Context context, EGLContext eglContext, int textureId) &#123;</span><br><span class="line">        super(context, eglContext);</span><br><span class="line">        mPushRenderer &#x3D; new PushRenderer(context, textureId);</span><br><span class="line">        setRenderer(mPushRenderer);</span><br><span class="line">        mPushRenderer.setFragmentRender(R.raw.filter_fragment_gray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next配置</title>
    <url>/Hexo+Next%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-博客中图片的显示问题："><a href="#1-博客中图片的显示问题：" class="headerlink" title="1.博客中图片的显示问题："></a>1.博客中图片的显示问题：</h1><p>markdown中使用相对路径访问图片，博客上面不会显示。：原因为生成的html文件和图片的相对位置不对了。</p>
<p>解决：</p>
<p><strong>在Hexo根目录的<code>source</code>目录下创建<code>images</code>文件夹，将图片放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</strong></p>
<h1 id="2-添加分类和标签"><a href="#2-添加分类和标签" class="headerlink" title="2.添加分类和标签"></a>2.添加分类和标签</h1><h2 id="2-1-添加分类"><a href="#2-1-添加分类" class="headerlink" title="2.1.添加分类"></a>2.1.添加分类</h2><p>新建一个页面，命名为categories,命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>

<p>在进入<code>source/categories</code>目录下，编辑<code>index.md</code>文件，将页面的类型设置为categories,主题将自动为这个页面显示所有分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果集成了评论，这里需要关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h2 id="2-2-添加标签"><a href="#2-2-添加标签" class="headerlink" title="2.2.添加标签"></a>2.2.添加标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure>

<p>在进入<code>source/tags</code>目录下，编辑<code>index.md</code>文件，将页面的类型设置为categories,主题将自动为这个页面显示所有分类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果集成了评论，这里需要关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="2-3-配置菜单"><a href="#2-3-配置菜单" class="headerlink" title="2.3.配置菜单"></a>2.3.配置菜单</h2><p>修改<code>hexo目录/theme/next/_config.yml</code>如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;|| home</span><br><span class="line">  #about: &#x2F;about&#x2F; || user</span><br><span class="line">  #tags: &#x2F;tags&#x2F; || tags</span><br><span class="line">  #categories: &#x2F;categories&#x2F; || th</span><br><span class="line">  archives: &#x2F;archives&#x2F;|| archive</span><br><span class="line">  tags: &#x2F;tags&#x2F;|| tag</span><br><span class="line">  categories: &#x2F;categories&#x2F;|| th</span><br><span class="line">  about: &#x2F;about&#x2F;|| user  </span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar</span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap</span><br><span class="line">  commonweal: &#x2F;404.html|| heartbeat</span><br></pre></td></tr></table></figure>

<p>然后跑去 language 文件夹 zh-Hans.yml 修改中文名字，菜单就以中文显示了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: 首&amp;emsp;&amp;emsp;页</span><br><span class="line">  archives: 归&amp;emsp;&amp;emsp;档</span><br><span class="line">  categories: 分&amp;emsp;&amp;emsp;类</span><br><span class="line">  schedule: 日程表</span><br><span class="line">  sitemap: 站点地图</span><br><span class="line">  tags: 标&amp;emsp;&amp;emsp;签</span><br><span class="line">  about: 关于博主</span><br><span class="line">  search: 站内搜索</span><br><span class="line">  top: 最受欢迎</span><br><span class="line">  # commonweal: 公益404</span><br></pre></td></tr></table></figure>


<p>我们发表文章使用「tags」「categories」只需在文章开头添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 利用GitHub和HEXO免费搭建个人博客高级 美化篇</span><br><span class="line">date: 2019-01-29 22:58:56</span><br><span class="line">tags: [hexo建站,hexo部署,github部署,个人博客]      #添加的标签</span><br><span class="line">categories: hexo博客                              #添加的分类</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如此即可在菜单栏里的「tags」「categories」看见相应的效果。但是实际上打开是空白页面 本文的重点来了。<br>小tips：每次的手输入 categories 我们可以在<code>hexo目录\scaffolds\post.md</code> 添加如下代码，这样每次新建文章，就自动有了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:           #新加</span><br><span class="line">categories:     #新加</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h1 id="3-添加评论"><a href="#3-添加评论" class="headerlink" title="3.添加评论"></a><span id="评论">3.添加评论</span></h1><p>这里我们使用<code>Valine</code>评论，我们的评论系统其实是放在Leancloud上的，因此首先需要去注册一个账号</p>
<p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">Leancloud官网，点我注册</a></p>
<p>注册完以后需要创建一个应用，名字可以随便起，然后<strong>进入应用-&gt;设置-&gt;应用key</strong>,获取<code>appid</code> 和 <code>appkey</code> </p>
<p>打开<code>hexo目录/theme/next/_config.yml</code>,搜索 <code>valine</code>，填入<code>appid</code> 和 <code>appkey</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid:  your app id</span><br><span class="line">  appkey: your app key</span><br><span class="line">  notify: false # mail notifier , https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: ヾﾉ≧∀≦)o来啊，快活啊! </span><br><span class="line">  guest_info: nick,mail,link</span><br><span class="line">  pageSize: 10</span><br></pre></td></tr></table></figure>

<p>最后记得在<strong>Leancloud -&gt; 设置 -&gt; 安全中心 -&gt; Web 安全域名</strong>把你的域名加进去</p>
<h1 id="4-添加阅读次数"><a href="#4-添加阅读次数" class="headerlink" title="4.添加阅读次数"></a>4.添加阅读次数</h1><p>使用<a href="#评论">3.添加评论</a>中应用的<code>appid</code> 和 <code>appkey</code> ，打开<code>hexo目录/theme/next/_config.yml</code>,搜索 <code>leancloud_visitors</code>，填入<code>appid</code> 和 <code>appkey</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: nGS6I8Lhxl6RuW9rWHtlzQgi-gzGzoHsz</span><br><span class="line">  app_key: osxkNrrnKC4USSNpLUJyfsCb</span><br><span class="line">  security: false</span><br><span class="line">  betterPerformance: false</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>音视频：01.音视频技术-启动篇</title>
    <url>/72.%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0-%E5%90%AF%E5%8A%A8%E7%AF%87/</url>
    <content><![CDATA[<h1 id="1-音视频学习"><a href="#1-音视频学习" class="headerlink" title="1. 音视频学习"></a>1. 音视频学习</h1><ul>
<li>视音频播放器（华为视频，腾讯视频，喜马拉雅，QQ音乐）</li>
<li>短视频（抖音，小火山，微视）</li>
<li>视音频的直播（有信，QQ音乐的电台，视频直播）+ OpengGl </li>
</ul>
<p><a href="https://blog.csdn.net/leixiaohua1020" target="_blank" rel="noopener">雷霄骅</a></p>
<p>Android + NDK　　FFmpeg + SurfaceView + AudioTrack </p>
<h1 id="2-音视频编解码"><a href="#2-音视频编解码" class="headerlink" title="2. 音视频编解码"></a>2. 音视频编解码</h1><p>先来看下视频的播放流程：</p>
<p><img src="/images/72.%E8%A7%86%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B.png" alt></p>
<ul>
<li>RGB：8字节，24字节，32字节（RGBA）</li>
<li>YUV：Y黑白电视，亮度；U 色度，V 饱和度  ， YUV440，YUV420，YUV444 </li>
</ul>
<p>YUV：发现比例可以不一样，为什么可以，人脸对亮度比较敏感，对色度没这么敏感</p>
<p>YUV444 : Y：U：V 比例 1:1:1，YUV420 比例 2:1:0   </p>
<p>H264 编解码码的思想，认为每一帧每一帧都有相同的数据，就充分利用这个特性  </p>
<p>涉计到的算法：熵编码，帧内预测，帧间预测，环形滤波… </p>
<p>补充：H264码流怎么存？一个一个的 <code>NALU</code> 存起来的，大小是不固定的，一个  <code>NALU</code> 代表的是一帧画面，区分每个 <code>NALU</code> 的办法就是设置两个标志位 </p>
<p>PCM 采样：麦克风，  </p>
<ul>
<li>声道　　　　　: 2声道 （左右声道，立体声） 5point1 环绕声</li>
<li>采样率　　　　: 48.0 KHz      1秒钟采样多少个点 48*1000 ， 44100HZ 人耳</li>
<li>位深度　　　　: 16位              16byte 存的   最大值？   8 位   </li>
</ul>
<h1 id="3-FFmpeg"><a href="#3-FFmpeg" class="headerlink" title="3. FFmpeg"></a>3. FFmpeg</h1><ul>
<li><p>ijkplayer ： ffmpeg ， libyuv ， opensl es , 自己代码</p>
</li>
<li><p>微视：基于这个 ffmpeg </p>
</li>
<li><p>音视频通话：基于 webrtc</p>
<p>ffmpeg 是一个 c 库，要用你的编译 so , 自己去编译，你可以按需加载，减少so库的体积<br>shell 脚本，cmake 语法，linux ， 买最便宜，ubuntu ，mac 可以不用买，终端 -&gt; shell<br>inux 内核基础，android 底层基于 linux 内核 mmap() 等等  </p>
</li>
</ul>
]]></content>
      <categories>
        <category>音视频</category>
      </categories>
      <tags>
        <tag>音视频</tag>
      </tags>
  </entry>
</search>
