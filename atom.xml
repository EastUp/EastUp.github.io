<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jamin</title>
  
  <subtitle>人生没有终点！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://eastup.github.io/"/>
  <updated>2020-12-28T09:42:32.586Z</updated>
  <id>http://eastup.github.io/</id>
  
  <author>
    <name>jamin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>性能优化：2.UI绘制优化</title>
    <link href="http://eastup.github.io/2.UI%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/"/>
    <id>http://eastup.github.io/2.UI%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/</id>
    <published>2020-12-02T00:12:43.000Z</published>
    <updated>2020-12-28T09:42:32.586Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-CPU与GPU工作流程"><a href="#1-CPU与GPU工作流程" class="headerlink" title="1.CPU与GPU工作流程"></a>1.CPU与GPU工作流程</h1><p>CPU 的任务繁多，做逻辑计算外，还要做内存管理、显示操作，因此在实际运算的时候性能会大打折扣，在没有 GPU 的时代，不能显示复<br>杂的图形，其运算速度远跟不上今天复杂三维游戏的要求。即使 CPU的工作频率超过 2GHz 或更高，对它绘制图形提高也不大。这时 GPU<br>的设计就出来了。</p><p><img src="/images/CPU、GPU传递工作.png" alt></p><p><img src="/images/CPU、GPU结构图.png" alt></p><ul><li>黄色的 Control 为控制器，用于协调控制整个 CPU 的运行，包括取出指令、控制其他模块的运行等；</li><li>绿色的 ALU （ Arithmetic Logic Unit ）是算术逻辑单元，用于进行数学、逻辑运算；</li><li>橙色的 Cache 和 DRAM 分别为缓存和 RAM ，用于存储信息。</li></ul><p>从结构图可以看出， CPU 的控制器较为复杂，而 ALU 数量较少。因此 CPU 擅长各种复杂的逻辑运算，但不擅长数学尤其是浮点运算。</p><p><img src="/images/CPU、GPU绘制的流程.png" alt></p><p><img src="/images/CPU、GPU绘制的流程2.png" alt></p><h1 id="2-60Hz-刷新频率由来"><a href="#2-60Hz-刷新频率由来" class="headerlink" title="2.60Hz 刷新频率由来"></a>2.60Hz 刷新频率由来</h1><ul><li>12 fps ：由于人类眼睛的特殊生理结构，如果所看画面之帧率高于每秒约 10-12 帧的时候，就会认为是连贯的</li><li>24 fps ：有声电影的拍摄及播放帧率均为每秒 24 帧，对一般人而言已算可接受</li><li>30 fps ：早期的高动态电子游戏，帧率少于每秒 30 帧的话就会显得不连贯，这是因为没有动态模糊使流畅度降低</li><li><code>60 fps</code> <code>在与手机交互过程中</code>，如触摸和反馈 60 帧以下人是能感觉出来的。 60 帧以上不能察觉变化当帧率<br>低于 60 fps 时感觉的画面的卡顿和迟滞现象</li></ul><p>Android 系统每隔 <code>16ms</code> 发出 <code>VSYNC(垂直同步信号)</code> 信号 (1000ms/60=16.66ms) ，触发对 UI 进行渲染， 如果每次渲染都成<br>功这样就能够达到流畅的画面所需要的 60fps ，为了能够实现 60fps ，这意味着计算渲染的大多数操作都必须在 16ms 内完成。</p><h1 id="3-卡顿原理分析和解决方案"><a href="#3-卡顿原理分析和解决方案" class="headerlink" title="3.卡顿原理分析和解决方案"></a>3.卡顿原理分析和解决方案</h1><p>当这一帧画面渲染时间超过16ms的时候,垂直同步机制会让显示器硬件 等待GPU完成栅格化渲染操作<br>这样会让湿一帧画面，多停留了 16ms,甚至更多.这样就这造成了用户看起来画面停顿.</p><p><code>16 毫秒的时间主要被两件事情所占用</code></p><ul><li>第一件：将 UI 对象转换为一系列多边形和纹理</li><li>第二件： CPU 传递处理数据到 GPU 。</li></ul><p>所以很明显，我们要缩短这两部分的时间，也就是说需要尽量减少对象转换的次数，以及Cpu传递到GPU数据的次数。</p><p><code>如何减少这两部分的时间以至于在16ms完成呢</code></p><ul><li>CPU减少xml转换成对象的时间(<code>布局优化</code>)</li><li>GPU减少重复绘制的时间（<code>减少过度绘制</code>）</li></ul><h1 id="4-减少过度绘制-减少GPU工作量"><a href="#4-减少过度绘制-减少GPU工作量" class="headerlink" title="4.减少过度绘制(减少GPU工作量)"></a><code>4.减少过度绘制(减少GPU工作量)</code></h1><h2 id="4-1-过度绘制定义"><a href="#4-1-过度绘制定义" class="headerlink" title="4.1.过度绘制定义"></a>4.1.过度绘制定义</h2><p>GPU的绘制过程，就跟刷墙一样,一层层的进行,16ms刷一次.这样就会造成图层覆盖的现象，即无用的图层还被绘制在底层,造成不必要的浪费.</p><h2 id="4-2-GPU过度绘制几种情况"><a href="#4-2-GPU过度绘制几种情况" class="headerlink" title="4.2.GPU过度绘制几种情况"></a>4.2.GPU过度绘制几种情况</h2><ol><li>自定义控件中onDraw方法做了过多重复绘制(可以使用裁剪，只绘制用户看的到的地方)</li><li>布局层次太深，重叠性太强。用户看不到的区域GPU也会渲染，导致耗时增加.</li></ol><h2 id="4-3-过度绘制査看工具"><a href="#4-3-过度绘制査看工具" class="headerlink" title="4.3.过度绘制査看工具"></a>4.3.过度绘制査看工具</h2><p>手机端的开发者选项—-&gt;<code>调试GPU过度绘制</code>——&gt;显示过度绘制区域</p><p><img src="/images/查看过度绘制区域.png" alt></p><p><img src="/images/查看过度绘制区域2.png" alt></p><ul><li>蓝色过度绘制一次无过度绘制</li><li>淡绿过度绘制两次</li><li>淡红过度绘制三次</li><li>深红过度绘制四次</li></ul><p>代表了4种不同程度Overdraw情况 我们的目标就是尽量减少红色Overdraw ,看到更多的蓝色区域。</p><h2 id="4-4-优化方案"><a href="#4-4-优化方案" class="headerlink" title="4.4.优化方案"></a><code>4.4.优化方案</code></h2><h3 id="4-4-1-减少背景重复"><a href="#4-4-1-减少背景重复" class="headerlink" title="4.4.1. 减少背景重复"></a>4.4.1. 减少背景重复</h3><p>去掉默认背景<br><img src="/images/去掉默认背景.png" alt></p><p>去掉二层容器背景<br><img src="/images/去掉容器背景.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.去掉所有activity主题设置中的属性</span><br><span class="line">直接在styles.xml中设置&lt;item name&#x3D;&quot;android:windowBackground&quot;&gt;@null&lt;&#x2F;item&gt;</span><br><span class="line"></span><br><span class="line">2.去掉单个activity的主题设置的属性</span><br><span class="line">可以在setContentView之前getWindow().setBackgroundDrawable(null); </span><br><span class="line"></span><br><span class="line">3.非业务需要，不要去设置背景</span><br></pre></td></tr></table></figure><h3 id="4-4-2-使用裁减减少控件之间的重合部分"><a href="#4-4-2-使用裁减减少控件之间的重合部分" class="headerlink" title="4.4.2. 使用裁减减少控件之间的重合部分"></a>4.4.2. 使用裁减减少控件之间的重合部分</h3><p>Android7.0之后系统做出的优化,<code>invalidate()</code>不再执行测量和布局动作</p><p><img src="/images/重合区域过度绘制情况.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void drawDroidCard(Canvas canvas,List&lt;DroidCard&gt; mDroidCards,int i) &#123;</span><br><span class="line">    DroidCard c &#x3D; mDroidCards.get(i);</span><br><span class="line">    canvas.save();</span><br><span class="line">    canvas.clipRect((float)c.x,0f,(float)(mDroidCards.get(i+1).x),(float)c.height);</span><br><span class="line">    canvas.drawBitmap(c.bitmap,c.x,0f,paint);</span><br><span class="line">    canvas.restore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-布局优化-减少CPU工作量"><a href="#5-布局优化-减少CPU工作量" class="headerlink" title="5.布局优化(减少CPU工作量)"></a><code>5.布局优化(减少CPU工作量)</code></h1><h2 id="5-1-布局查看常用工具"><a href="#5-1-布局查看常用工具" class="headerlink" title="5.1.布局查看常用工具"></a>5.1.布局查看常用工具</h2><ol><li>Tool—-&gt;<code>Layout Inspector</code>,<code>AndroidStudio自带</code></li><li>sdk目录/tools/bin/uiautomatorviewer.bat</li><li>sdk目录tools\monitor.bat打开<code>Device Monitor</code>中Hierarchy view，<code>AndroidStudio3.1过后已经遗弃，但是真的好用</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三个点也是代表着View的Measure, Layout和Draw。</span><br><span class="line">绿: 表示该View的此项性能比该View Tree中超过50%的View都要快；例如,代表Measure的是绿点,意味着这个视图的测量时间快于树中的视图对象的50%。</span><br><span class="line">黄: 表示该View的此项性能比该View Tree中超过50%的View都要慢； </span><br><span class="line">红: 表示该View的此项性能是View Tree中最慢的；。</span><br></pre></td></tr></table></figure></li></ol><p><img src="/images/AndroidDeviceMonitor.png" alt></p><h2 id="5-2-优化方案"><a href="#5-2-优化方案" class="headerlink" title="5.2.优化方案"></a><code>5.2.优化方案</code></h2><ol><li>能在一个平面显示的内容，尽量只用一个容器。</li><li>尽可能把相同的容器合并merge。</li><li>能复用的代码，用include处理，可以减少GPU重复工。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-CPU与GPU工作流程&quot;&gt;&lt;a href=&quot;#1-CPU与GPU工作流程&quot; class=&quot;headerlink&quot; title=&quot;1.CPU与GPU工作流程&quot;&gt;&lt;/a&gt;1.CPU与GPU工作流程&lt;/h1&gt;&lt;p&gt;CPU 的任务繁多，做逻辑计算外，还要做内存管理、显
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://eastup.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>性能优化：1.App启动优化(源码)</title>
    <link href="http://eastup.github.io/1.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96(%E6%BA%90%E7%A0%81)/"/>
    <id>http://eastup.github.io/1.App%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96(%E6%BA%90%E7%A0%81)/</id>
    <published>2020-12-01T00:12:43.000Z</published>
    <updated>2020-12-28T09:31:06.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-系统的启动"><a href="#1-系统的启动" class="headerlink" title="1.系统的启动"></a>1.系统的启动</h1><ol><li>打开电源  引导芯片代码加载引导程序Boot Loader到RAM中去执行</li><li>BootLoader把操作系统拉起来</li><li>Linux 内核启动开始系统设置，找到一个init.rc文件启动初始化进程</li><li>init进程初始化和启动属性服务，之后开启Zygote进程</li><li>Zygote开始创建JVM并注册JNI方法，开启SystemServer</li><li>启动Binder线程沲和SystemServiceManager,并启动各种服务</li><li>AMS启动Launcher</li></ol><p><img src="/images/系统的启动流程.png" alt></p><h1 id="2-Launcher启动应用程序"><a href="#2-Launcher启动应用程序" class="headerlink" title="2.Launcher启动应用程序"></a>2.Launcher启动应用程序</h1><p>当我们用手点击一个图标时，就到了这个类<code>public final class Launcher extends Activity</code>,<br>类路径在<code>E:\tools\android-src\android-6.0.1_r1\packages\apps\Launcher2\src\com\android\launcher2\Launcher.java</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">执行&#96;onClick(View view)&#96;方法，会把这个应用的相关信息传入  </span><br><span class="line">先获取一个intent---&gt;startActivitySafely(v, intent, tag)--&gt;startActivity(v, intent, tag);--&gt;startActivity(intent);</span><br><span class="line">startActivity(intent)会开一个APP进程</span><br><span class="line"></span><br><span class="line">ActivityThread.java的main方法作为入口     用attach开启app    再加载application和activity</span><br><span class="line">thread.attach(false);---&gt;mgr.attachApplication(mAppThread)会通过远端进程去回调private void handleBindApplication(AppBindData data)</span><br><span class="line">Application app &#x3D; data.info.makeApplication()----创建Application对象</span><br><span class="line">mInstrumentation.callApplicationOnCreate(app);---- Application调用onCreate方法</span><br></pre></td></tr></table></figure><p><img src="/images/新应用的启动.png" alt></p><h1 id="3-adb一些命令说明"><a href="#3-adb一些命令说明" class="headerlink" title="3.adb一些命令说明"></a>3.adb一些命令说明</h1><ol><li>通过<code>adb shell dumpsys activity activities</code>查看当前的activity名</li><li>查看进程   <code>adb shell ps</code></li></ol><h1 id="4-黑白屏问题"><a href="#4-黑白屏问题" class="headerlink" title="4.黑白屏问题"></a>4.黑白屏问题</h1><p>原因：</p><pre><code>    在res/values/styles.xml文件中      白屏   `&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt;`    黑屏   ` &lt;style name=&quot;AppTheme&quot;&gt;（在以前的老版本上有效，现在的版本默认使用透明处理了）`</code></pre><p>伪解决办法：</p><pre><code>    1.在自己的&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light&quot;&gt;中加入windowsbackground，可用于打广告    2.设置windowbackground为透明的  &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;    但这2种方法会有个问题，所有的activity启动都会显示    3.单独做成一个主题    &lt;style name=&quot;AppTheme.Launcher&quot;&gt;            &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/bg&lt;/item&gt;    &lt;/style&gt;    再在功能清单中的单独activity下设置    &lt;activity          android:theme=&quot;@style/AppTheme.Launcher&quot;    然后在程序中使用setTheme(R.style.AppTheme)    让APP中所有的activity还是使用以前的样式，这样做就只有启动时才使用自己的样式</code></pre><h1 id="5-启动时间查看"><a href="#5-启动时间查看" class="headerlink" title="5.启动时间查看"></a>5.启动时间查看</h1><p>4.4以前 <code>adb shell am start -W com.lqr.wechat/com.lqr.wechat.activity.SplashActivity</code></p><pre><code>ThisTime:最后一个启动的Activity的启动耗时；TotalTime:自己的所有Activity的启动耗时；WaitTime: ActivityManagerService启动App的Activity时的总时间（包括当前Activity的onPause()和自己Activity的启动）AM路径：E:\tools\android-src\android-6.0.1_r1\frameworks\base\cmds\am\src\com\android\commands\amAm.java   946行开始打印启动时间信息其中一个result对象，在871行初始化 result = mAm.startActivityAndWait(。。。）在这个初始化时就已经进行了时间的计算：在android-src\android-6.0.1_r1\frameworks\base\services\core\java\com\android\server\am\ActivityRecord.java文件中计算void windowsDrawnLocked() ---&gt;reportLaunchTimeLocked(SystemClock.uptimeMillis())中完成时间的统计;</code></pre><p>4.4版本以后Logcat输入<code>Display</code>筛选系统日志  <code>不过滤信息No Filters</code></p><h1 id="6-TRACE工具分析代码执行时间"><a href="#6-TRACE工具分析代码执行时间" class="headerlink" title="6.TRACE工具分析代码执行时间"></a>6.TRACE工具分析代码执行时间</h1><h1 id="6-1-代码"><a href="#6-1-代码" class="headerlink" title="6.1.代码"></a>6.1.代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Debug.startMethodTracing(filePath);</span><br><span class="line">中间为需要统计执行时间的代码</span><br><span class="line">Debug.stopMethodTracing();</span><br></pre></td></tr></table></figure><h1 id="6-2-分析"><a href="#6-2-分析" class="headerlink" title="6.2. 分析"></a>6.2. 分析</h1><p><code>adb pull /storage/emulated/0/app1.trace</code>把文件拉出来分析，把pull到电脑上的文件拖到AS中就可以分析了</p><h1 id="6-3-优化方案"><a href="#6-3-优化方案" class="headerlink" title="6.3. 优化方案"></a>6.3. 优化方案</h1><ol><li>开线程  <code>没建handler    没操作UI   对异步要求不高</code></li><li>懒加载  <code>用到的时候再初始化，如网络，数据库操作</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-系统的启动&quot;&gt;&lt;a href=&quot;#1-系统的启动&quot; class=&quot;headerlink&quot; title=&quot;1.系统的启动&quot;&gt;&lt;/a&gt;1.系统的启动&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;打开电源  引导芯片代码加载引导程序Boot Loader到RAM中去执行&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="性能优化" scheme="http://eastup.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="源码" scheme="http://eastup.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>音视频：20.FFmpeg-直播推流到服务器、加滤镜效果</title>
    <link href="http://eastup.github.io/91.FFmpeg-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E5%8A%A0%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C/"/>
    <id>http://eastup.github.io/91.FFmpeg-%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E5%8A%A0%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C/</id>
    <published>2020-08-20T00:12:43.000Z</published>
    <updated>2020-11-12T07:36:03.324Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p><h1 id="ffmpeg测试流媒体服务器播放地址"><a href="#ffmpeg测试流媒体服务器播放地址" class="headerlink" title="ffmpeg测试流媒体服务器播放地址"></a>ffmpeg测试流媒体服务器播放地址</h1><p>windows ffmpeg<a href="https://github.com/BtbN/FFmpeg-Builds/releases" target="_blank" rel="noopener">下载地址</a></p><p>mac 和 linux 类似，进入<a href="http://www.ffmpeg.org/download.html" target="_blank" rel="noopener">官网下载</a> 。</p><p>下面以windows为例测试步骤：</p><ol><li>进入下载好的ffmpeg解压目录的/bin目录文件夹下</li><li>使用命令拉流：<code>ffplay.exe rtmp://192.168.1.20/myapp/mystream</code></li></ol><h1 id="1-录制声音获取-PCM-数据"><a href="#1-录制声音获取-PCM-数据" class="headerlink" title="1.录制声音获取 PCM 数据"></a>1.录制声音获取 PCM 数据</h1><p>使用<code>AudioRecord</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频的采集线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioRecordThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMinBufferSize;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mAudioCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAudioTrackIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mAudioPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> AudioRecord mAudioRecord; <span class="comment">//录音的类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] mAudioData;<span class="comment">// 这是 pcm 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioRecordThread</span><span class="params">(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mAudioCodec = videoRecorderWr.get().mAudioCodec;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line"></span><br><span class="line">        mMinBufferSize = AudioRecord.getMinBufferSize(</span><br><span class="line">                BaseVideoPush.AUDIO_SAMPLE_RATE,</span><br><span class="line">                AudioFormat.CHANNEL_IN_STEREO,<span class="comment">//立体声</span></span><br><span class="line">                AudioFormat.ENCODING_PCM_16BIT);</span><br><span class="line"></span><br><span class="line">        mAudioRecord = <span class="keyword">new</span> AudioRecord(MediaRecorder.AudioSource.MIC,</span><br><span class="line">                BaseVideoPush.AUDIO_SAMPLE_RATE,</span><br><span class="line">                AudioFormat.CHANNEL_IN_STEREO,<span class="comment">//立体声</span></span><br><span class="line">                AudioFormat.ENCODING_PCM_16BIT,</span><br><span class="line">                mMinBufferSize);</span><br><span class="line"></span><br><span class="line">        mAudioData = <span class="keyword">new</span> <span class="keyword">byte</span>[mMinBufferSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启录制</span></span><br><span class="line">            mAudioRecord.startRecording();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 不断读取 pcm 数据</span></span><br><span class="line">                mAudioRecord.read(mAudioData, <span class="number">0</span>, mMinBufferSize);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 把数据写入到 mAudioCodec 的 InputBuffer</span></span><br><span class="line">                <span class="keyword">int</span> inputBufferIndex = mAudioCodec.dequeueInputBuffer(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (inputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    ByteBuffer byteBuffer = mAudioCodec.getInputBuffers()[inputBufferIndex];</span><br><span class="line">                    byteBuffer.clear();</span><br><span class="line">                    byteBuffer.put(mAudioData);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// pts  44100 * 2 *2</span></span><br><span class="line">                    mAudioPts += mMinBufferSize * <span class="number">1000000</span> / BaseVideoPush.AUDIO_SAMPLE_RATE * BaseVideoPush.AUDIO_CHANNELS * <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">// size 22050*2*2</span></span><br><span class="line">                    mAudioCodec.queueInputBuffer(inputBufferIndex, <span class="number">0</span>, mMinBufferSize, mAudioPts, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAudioCodec.stop();</span><br><span class="line">            mAudioCodec.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-推送视频画面到媒体房间"><a href="#2-推送视频画面到媒体房间" class="headerlink" title="2.推送视频画面到媒体房间"></a>2.推送视频画面到媒体房间</h1><p><img src="/images/91.直播推流原理.png" alt></p><p>为什么要封装成<code>flv</code>：为了不定死 <code>h264</code>协议</p><p>flv 封装格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; FLV 的封装格式</span><br><span class="line">&#x2F;&#x2F; frame type : 1关键帧，2 非关键帧（4Bit）</span><br><span class="line">&#x2F;&#x2F; CodecID : 7表示 AVC(4bit) , 与 frame type组合起来刚好是 1 个字节 0x17</span><br><span class="line">&#x2F;&#x2F; fixed ： 0x00 0x00 0x00 0x00 (4byte)</span><br><span class="line">&#x2F;&#x2F; configurationVersion  (1byte) 0x01版本</span><br><span class="line">&#x2F;&#x2F; AVCProfileIndication  (1byte) sps[1] profile</span><br><span class="line">&#x2F;&#x2F; profile_compatibility (1byte) sps[2] compatibility</span><br><span class="line">&#x2F;&#x2F; AVCLevelIndication    (1byte) sps[3] Profile level</span><br><span class="line">&#x2F;&#x2F; lengthSizeMinusOne    (1byte) 0xff   包长数据所使用的字节数</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; sps + pps 的数据</span><br><span class="line">&#x2F;&#x2F; sps number            (1byte) 0xe1   sps 个数</span><br><span class="line">&#x2F;&#x2F; sps data length       (2byte) sps 长度</span><br><span class="line">&#x2F;&#x2F; sps data                      sps 的内容</span><br><span class="line">&#x2F;&#x2F; pps number            (1byte) 0x01 pps 个数</span><br><span class="line">&#x2F;&#x2F; pps data length       (2byte) pps 长度</span><br><span class="line">&#x2F;&#x2F; pps data                      pps 的内容</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">BaseVideoPush：VideoEncoderThread</span><br><span class="line"></span><br><span class="line"> private static final class VideoEncoderThread extends Thread &#123;</span><br><span class="line">        private WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">        private volatile boolean mShouldExit &#x3D; false;</span><br><span class="line">        private MediaCodec mVideoCodec;</span><br><span class="line">        private MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">        private long mVideoPts &#x3D; 0;</span><br><span class="line">        private byte[] mVideoSps, mVideoPps;</span><br><span class="line"></span><br><span class="line">        public VideoEncoderThread(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr) &#123;</span><br><span class="line">            this.mVideoRecorderWr &#x3D; videoRecorderWr;</span><br><span class="line">            mVideoCodec &#x3D; videoRecorderWr.get().mVideoCodec;</span><br><span class="line">            mBufferInfo &#x3D; new MediaCodec.BufferInfo();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mVideoCodec.start();</span><br><span class="line"></span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (mShouldExit) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    BaseVideoPush videoRecorder &#x3D; mVideoRecorderWr.get();</span><br><span class="line">                    if (videoRecorder &#x3D;&#x3D; null) &#123;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 代码先不写，先测试，从 surface 上获取数据，编码成 h264 ,通过 MediaMuxer 合成 mp4</span><br><span class="line">                    int outputBufferIndex &#x3D; mVideoCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line">                    if (outputBufferIndex &#x3D;&#x3D; MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line"></span><br><span class="line">                        &#x2F;&#x2F; 获取 sps 和 pps</span><br><span class="line">&#x2F;&#x2F;                        Log.e(&quot;TAG&quot;, &quot;获取 sps 和 pps&quot;);</span><br><span class="line">                        ByteBuffer byteBuffer &#x3D; mVideoCodec.getOutputFormat().getByteBuffer(&quot;csd-0&quot;);</span><br><span class="line">                        mVideoSps &#x3D; new byte[byteBuffer.remaining()];</span><br><span class="line">                        byteBuffer.get(mVideoSps, 0, mVideoSps.length);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                        Log.e(&quot;sps&quot;, bytesToHexString(mVideoSps));</span><br><span class="line"></span><br><span class="line">                        byteBuffer &#x3D; mVideoCodec.getOutputFormat().getByteBuffer(&quot;csd-1&quot;);</span><br><span class="line">                        mVideoPps &#x3D; new byte[byteBuffer.remaining()];</span><br><span class="line">                        byteBuffer.get(mVideoPps, 0, mVideoPps.length);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;                        Log.e(&quot;pps&quot;, bytesToHexString(mVideoPps));</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        while (outputBufferIndex &gt;&#x3D; 0) &#123;</span><br><span class="line">                            &#x2F;&#x2F; 获取数据</span><br><span class="line">                            ByteBuffer outBuffer &#x3D; mVideoCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                            outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                            outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; 修改 pts</span><br><span class="line">                            if (mVideoPts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                                mVideoPts &#x3D; mBufferInfo.presentationTimeUs;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mBufferInfo.presentationTimeUs -&#x3D; mVideoPts;</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; 在关键帧之前先把 sps 和 pps 推到流媒体服务器</span><br><span class="line">                            if(mBufferInfo.flags &#x3D;&#x3D; MediaCodec.BUFFER_FLAG_KEY_FRAME)&#123;</span><br><span class="line">                                mVideoRecorderWr.get().mLivePush.pushSpsPps(mVideoSps,mVideoSps.length,</span><br><span class="line">                                        mVideoPps,mVideoPps.length);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            byte[] data &#x3D; new byte[outBuffer.remaining()];</span><br><span class="line">                            outBuffer.get(data, 0, data.length);</span><br><span class="line">                            &#x2F;&#x2F; 推送视频到流媒体服务器上</span><br><span class="line">                            mVideoRecorderWr.get().mLivePush.pushVideo(data,data.length,</span><br><span class="line">                                    mBufferInfo.flags &#x3D;&#x3D; MediaCodec.BUFFER_FLAG_KEY_FRAME);</span><br><span class="line"></span><br><span class="line">                            &#x2F;&#x2F; 回调当前录制的时间</span><br><span class="line">                            if (videoRecorder.mRecordListener !&#x3D; null) &#123;</span><br><span class="line">                                videoRecorder.mRecordListener.onTime(mBufferInfo.presentationTimeUs &#x2F; 1000);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            mVideoCodec.releaseOutputBuffer(outputBufferIndex, false);</span><br><span class="line">                            outputBufferIndex &#x3D; mVideoCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                onDestroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void onDestroy() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                mVideoCodec.stop();</span><br><span class="line">                mVideoCodec.release();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private void requestExit() &#123;</span><br><span class="line">            mShouldExit &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> LivePush::pushSpsPps(jbyte *spsData, jint spsLen, jbyte *ppsData, jint ppsLen) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// FLV 的封装格式</span></span><br><span class="line">    <span class="comment">// frame type : 1关键帧，2 非关键帧（4Bit）</span></span><br><span class="line">    <span class="comment">// CodecID : 7表示 AVC(4bit) , 与 frame type组合起来刚好是 1 个字节 0x17</span></span><br><span class="line">    <span class="comment">// fixed ： 0x00 0x00 0x00 0x00 (4byte)</span></span><br><span class="line">    <span class="comment">// configurationVersion  (1byte) 0x01版本</span></span><br><span class="line">    <span class="comment">// AVCProfileIndication  (1byte) sps[1] profile</span></span><br><span class="line">    <span class="comment">// profile_compatibility (1byte) sps[2] compatibility</span></span><br><span class="line">    <span class="comment">// AVCLevelIndication    (1byte) sps[3] Profile level</span></span><br><span class="line">    <span class="comment">// lengthSizeMinusOne    (1byte) 0xff   包长数据所使用的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sps + pps 的数据</span></span><br><span class="line">    <span class="comment">// sps number            (1byte) 0xe1   sps 个数</span></span><br><span class="line">    <span class="comment">// sps data length       (2byte) sps 长度</span></span><br><span class="line">    <span class="comment">// sps data                      sps 的内容</span></span><br><span class="line">    <span class="comment">// pps number            (1byte) 0x01 pps 个数</span></span><br><span class="line">    <span class="comment">// pps data length       (2byte) pps 长度</span></span><br><span class="line">    <span class="comment">// pps data                      pps 的内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据的长度（大小） = sps 大小 + pps 大小 + 头 16字节</span></span><br><span class="line">    <span class="keyword">int</span> bodySize = spsLen + ppsLen + <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 构建 RTMPPacket</span></span><br><span class="line">    RTMPPacket *pPacket = (RTMPPacket *) malloc(sizeof(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(pPacket, bodySize);</span><br><span class="line">    RTMPPacket_Reset(pPacket);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 body 按上面的一个一个开始赋值</span></span><br><span class="line">    <span class="keyword">char</span> *body = pPacket-&gt;m_body;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    body[index++] = <span class="number">0x17</span>;</span><br><span class="line">    <span class="comment">// fixed ： 0x00 0x00 0x00 0x00 (4byte)</span></span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    body[index++] = <span class="number">0x00</span>;</span><br><span class="line">    <span class="comment">// configurationVersion  (1byte) 0x01版本</span></span><br><span class="line">    body[index++] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// AVCProfileIndication  (1byte) sps[1] profile</span></span><br><span class="line">    body[index++] = spsData[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// profile_compatibility (1byte) sps[2] compatibility</span></span><br><span class="line">    body[index++] = spsData[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// AVCLevelIndication    (1byte) sps[3] Profile level</span></span><br><span class="line">    body[index++] = spsData[<span class="number">3</span>];</span><br><span class="line">    <span class="comment">// lengthSizeMinusOne    (1byte) 0xff   包长数据所使用的字节数</span></span><br><span class="line">    body[index++] = <span class="number">0xff</span>;</span><br><span class="line">    <span class="comment">// sps + pps 的数据</span></span><br><span class="line">    <span class="comment">// sps number            (1byte) 0xe1   sps 个数</span></span><br><span class="line">    body[index++] = <span class="number">0xe1</span>;</span><br><span class="line">    <span class="comment">// sps data length       (2byte) sps 长度</span></span><br><span class="line">    body[index++] = (spsLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    body[index++] = spsLen &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="comment">// sps data                      sps 的内容</span></span><br><span class="line">    memcpy(&amp;body[index], spsData, spsLen);</span><br><span class="line">    index += spsLen;</span><br><span class="line">    <span class="comment">// pps number            (1byte) 0x01 pps 个数</span></span><br><span class="line">    body[index++] = <span class="number">0x01</span>;</span><br><span class="line">    <span class="comment">// pps data length       (2byte) pps 长度</span></span><br><span class="line">    body[index++] = (ppsLen &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>;</span><br><span class="line">    body[index++] = ppsLen &amp; <span class="number">0xFF</span>;</span><br><span class="line">    <span class="comment">// pps data                      pps 的内容</span></span><br><span class="line">    memcpy(&amp;body[index], ppsData, ppsLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RTMPPacket 设置一些信息</span></span><br><span class="line">    pPacket-&gt;m_hasAbsTimestamp = <span class="number">0</span>;</span><br><span class="line">    pPacket-&gt;m_nTimeStamp = <span class="number">0</span>;</span><br><span class="line">    pPacket-&gt;m_headerType = RTMP_PACKET_SIZE_MEDIUM;</span><br><span class="line">    pPacket-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    pPacket-&gt;m_nBodySize = bodySize;</span><br><span class="line">    pPacket-&gt;m_nChannel = <span class="number">0x04</span>;</span><br><span class="line">    pPacket-&gt;m_nInfoField2 = <span class="keyword">this</span>-&gt;pRtmp-&gt;m_stream_id;</span><br><span class="line"></span><br><span class="line">    pPacketQueue-&gt;push(pPacket);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">void LivePush::pushVideoData(jbyte *videoData, jint dataLen, jboolean keyFrame) &#123;</span><br><span class="line">    &#x2F;&#x2F; frame type : 1关键帧，2非关键帧 (4bit)</span><br><span class="line">    &#x2F;&#x2F; CodecID: 7表示 AVC(4bit),与 frame type 组合起来刚好是 1 个字节 0x17</span><br><span class="line">    &#x2F;&#x2F; fixed：0x01 0x00 0x00 0x00 (4byte),0x01 表示 NALU 单元</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; video data length  (4byte) video长度</span><br><span class="line">    &#x2F;&#x2F; video data</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据的长度（大小） &#x3D; dataLen + 头 9字节</span><br><span class="line">    int bodySize &#x3D; dataLen + 9;</span><br><span class="line">    &#x2F;&#x2F; 构建 RTMPPacket</span><br><span class="line">    RTMPPacket *pPacket &#x3D; (RTMPPacket *) malloc(sizeof(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(pPacket, bodySize);</span><br><span class="line">    RTMPPacket_Reset(pPacket);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构建 body 按上面的一个一个开始赋值</span><br><span class="line">    char *body &#x3D; pPacket-&gt;m_body;</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; frame type : 1关键帧，2非关键帧 (4bit)</span><br><span class="line">    &#x2F;&#x2F; CodecID: 7表示 AVC(4bit),与 frame type 组合起来刚好是 1 个字节 0x17</span><br><span class="line">    if (keyFrame)</span><br><span class="line">        body[index++] &#x3D; 0x17;</span><br><span class="line">    else</span><br><span class="line">        body[index++] &#x3D; 0x27;</span><br><span class="line">    &#x2F;&#x2F; fixed：0x01 0x00 0x00 0x00 (4byte),0x01 表示 NALU 单元</span><br><span class="line">    body[index++] &#x3D; 0x01;</span><br><span class="line">    body[index++] &#x3D; 0x00;</span><br><span class="line">    body[index++] &#x3D; 0x00;</span><br><span class="line">    body[index++] &#x3D; 0x00;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; video data length  (4byte) video长度</span><br><span class="line">    body[index++] &#x3D; (dataLen &gt;&gt; 24) &amp; 0xFF;</span><br><span class="line">    body[index++] &#x3D; (dataLen &gt;&gt; 16) &amp; 0xFF;</span><br><span class="line">    body[index++] &#x3D; (dataLen &gt;&gt; 8) &amp; 0xFF;</span><br><span class="line">    body[index++] &#x3D; dataLen &amp; 0xFF;</span><br><span class="line">    &#x2F;&#x2F; video data</span><br><span class="line">    memcpy(&amp;body[index], videoData, dataLen);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; RTMPPacket 设置一些信息</span><br><span class="line">    pPacket-&gt;m_headerType &#x3D; RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    pPacket-&gt;m_packetType &#x3D; RTMP_PACKET_TYPE_VIDEO;</span><br><span class="line">    pPacket-&gt;m_hasAbsTimestamp &#x3D; 0;</span><br><span class="line">    pPacket-&gt;m_nTimeStamp &#x3D; RTMP_GetTime() - startTime;</span><br><span class="line">    pPacket-&gt;m_nBodySize &#x3D; bodySize;</span><br><span class="line">    pPacket-&gt;m_nChannel &#x3D; 0x04;</span><br><span class="line">    pPacket-&gt;m_nInfoField2 &#x3D; this-&gt;pRtmp-&gt;m_stream_id;</span><br><span class="line"></span><br><span class="line">    pPacketQueue-&gt;push(pPacket);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-推送声音到媒体房间"><a href="#3-推送声音到媒体房间" class="headerlink" title="3.推送声音到媒体房间"></a>3.推送声音到媒体房间</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 音频的编码线程</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static final class AudioEncoderThread extends Thread &#123;</span><br><span class="line">    private WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">    private volatile boolean mShouldExit &#x3D; false;</span><br><span class="line">    private MediaCodec mAudioCodec;</span><br><span class="line">    private MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    private long mAudioPts &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public AudioEncoderThread(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr) &#123;</span><br><span class="line">        this.mVideoRecorderWr &#x3D; videoRecorderWr;</span><br><span class="line">        mAudioCodec &#x3D; videoRecorderWr.get().mAudioCodec;</span><br><span class="line">        mBufferInfo &#x3D; new MediaCodec.BufferInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 开启 start AudioCodec</span><br><span class="line">            mAudioCodec.start();</span><br><span class="line"></span><br><span class="line">            while (true) &#123;</span><br><span class="line">                if (mShouldExit) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoPush videoRecorder &#x3D; mVideoRecorderWr.get();</span><br><span class="line">                if (videoRecorder &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; 获取音频数据，那这个音频数据从哪里来？音乐播放器里面来，pcm 数据</span><br><span class="line">                int outputBufferIndex &#x3D; mAudioCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line"></span><br><span class="line">                while (outputBufferIndex &gt;&#x3D; 0) &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取数据</span><br><span class="line">                    ByteBuffer outBuffer &#x3D; mAudioCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                    outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                    outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 修改 pts</span><br><span class="line">                    if (mAudioPts &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                        mAudioPts &#x3D; mBufferInfo.presentationTimeUs;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mBufferInfo.presentationTimeUs -&#x3D; mAudioPts;</span><br><span class="line"></span><br><span class="line">                    &#x2F;&#x2F; 打印一下音频的 AAC 数据</span><br><span class="line">                    byte[] data &#x3D; new byte[outBuffer.remaining()];</span><br><span class="line">                    outBuffer.get(data, 0, data.length);</span><br><span class="line">                    &#x2F;&#x2F; 推送音频数据到流媒体</span><br><span class="line">                    mVideoRecorderWr.get().mLivePush.pushAudio(data,data.length);</span><br><span class="line"></span><br><span class="line">                    mAudioCodec.releaseOutputBuffer(outputBufferIndex, false);</span><br><span class="line">                    outputBufferIndex &#x3D; mAudioCodec.dequeueOutputBuffer(mBufferInfo, 0);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void onDestroy() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            mAudioCodec.stop();</span><br><span class="line">            mAudioCodec.release();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void requestExit() &#123;</span><br><span class="line">        mShouldExit &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void LivePush::pushAudioData(jbyte *audioData, jint dataLen) &#123;</span><br><span class="line">    &#x2F;&#x2F; 2个字节头信息：</span><br><span class="line">        &#x2F;&#x2F; 前四位表示音频数据格式 AAC ：十进制的10(A) -&gt; 二进制：1010 -&gt; 十六进制：A</span><br><span class="line">        &#x2F;&#x2F; 五六位表示采样率 十进制：0&#x3D;5.5k   十进制：1&#x3D;11k   十进制：2&#x3D;22k   十进制：3(二进制：11)&#x3D;44k</span><br><span class="line">        &#x2F;&#x2F; 七位表示采样的精度 0&#x3D;8bits  1&#x3D;16bits</span><br><span class="line">        &#x2F;&#x2F; 八位表示音频类型 0&#x3D;mono   1&#x3D;stereo</span><br><span class="line">        &#x2F;&#x2F; 我们这里算出来第一个字节是 0xAF &#x3D; 1010 1111</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 0x01 代表 aac 原始数据</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 数据的长度（大小） &#x3D; dataLen + 2</span><br><span class="line">    int bodySize &#x3D; dataLen + 2;</span><br><span class="line">    &#x2F;&#x2F; 构建 RTMPPacket</span><br><span class="line">    RTMPPacket *pPacket &#x3D; (RTMPPacket *) malloc(sizeof(RTMPPacket));</span><br><span class="line">    RTMPPacket_Alloc(pPacket, bodySize);</span><br><span class="line">    RTMPPacket_Reset(pPacket);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 构建 body 按上面的一个一个开始赋值</span><br><span class="line">    char *body &#x3D; pPacket-&gt;m_body;</span><br><span class="line">    int index &#x3D; 0;</span><br><span class="line">    body[index++] &#x3D; 0xAF;</span><br><span class="line">    &#x2F;&#x2F; 0x01 代表 aac 原始数据</span><br><span class="line">    body[index++] &#x3D; 0x01;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; audio data</span><br><span class="line">    memcpy(&amp;body[index], audioData, dataLen);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; RTMPPacket 设置一些信息</span><br><span class="line">    pPacket-&gt;m_headerType &#x3D; RTMP_PACKET_SIZE_LARGE;</span><br><span class="line">    pPacket-&gt;m_packetType &#x3D; RTMP_PACKET_TYPE_AUDIO;</span><br><span class="line">    pPacket-&gt;m_hasAbsTimestamp &#x3D; 0;</span><br><span class="line">    pPacket-&gt;m_nTimeStamp &#x3D; RTMP_GetTime() - startTime;</span><br><span class="line">    pPacket-&gt;m_nBodySize &#x3D; bodySize;</span><br><span class="line">    pPacket-&gt;m_nChannel &#x3D; 0x04;</span><br><span class="line">    pPacket-&gt;m_nInfoField2 &#x3D; this-&gt;pRtmp-&gt;m_stream_id;</span><br><span class="line"></span><br><span class="line">    pPacketQueue-&gt;push(pPacket);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-滤镜效果处理"><a href="#4-滤镜效果处理" class="headerlink" title="4.滤镜效果处理"></a>4.滤镜效果处理</h1><p>// 设置纹理渲染</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * |---------------------------------------------------------------------------------------------------------------|</span><br><span class="line"> *  @description:  灰色视频的推流</span><br><span class="line"> *  @author: jamin</span><br><span class="line"> *  @date: 2020&#x2F;10&#x2F;20 13:39</span><br><span class="line"> * |---------------------------------------------------------------------------------------------------------------|</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class GrayVideoPush extends BaseVideoPush &#123;</span><br><span class="line">    private PushRenderer mPushRenderer;</span><br><span class="line"></span><br><span class="line">    public GrayVideoPush(Context context, EGLContext eglContext, int textureId) &#123;</span><br><span class="line">        super(context, eglContext);</span><br><span class="line">        mPushRenderer &#x3D; new PushRenderer(context, textureId);</span><br><span class="line">        setRenderer(mPushRenderer);</span><br><span class="line">        mPushRenderer.setFragmentRender(R.raw.filter_fragment_gray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：19.FFmpeg-视频加背景音乐、H.264协议</title>
    <link href="http://eastup.github.io/90.FFmpeg-%E8%A7%86%E9%A2%91%E5%8A%A0%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90%E3%80%81H.264%E5%8D%8F%E8%AE%AE/"/>
    <id>http://eastup.github.io/90.FFmpeg-%E8%A7%86%E9%A2%91%E5%8A%A0%E8%83%8C%E6%99%AF%E9%9F%B3%E4%B9%90%E3%80%81H.264%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-08-19T00:12:43.000Z</published>
    <updated>2020-11-12T07:35:30.627Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p><h1 id="1-实现视频加背景音乐"><a href="#1-实现视频加背景音乐" class="headerlink" title="1.实现视频加背景音乐"></a>1.实现视频加背景音乐</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> MediaInfoListener mMediaInfoListener = <span class="keyword">new</span> MediaInfoListener() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mAudioPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mSampleRate = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mChannels = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">musicInfo</span><span class="params">(<span class="keyword">int</span> sampleRate, <span class="keyword">int</span> channels)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取了音频的信息</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            initAudioCodec(sampleRate, channels);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.mSampleRate = sampleRate;</span><br><span class="line">        <span class="keyword">this</span>.mChannels = channels;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callbackPcm</span><span class="params">(<span class="keyword">byte</span>[] pcmData, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 把数据写入到 mAudioCodec 的 InputBuffer</span></span><br><span class="line">        <span class="keyword">int</span> inputBufferIndex = mAudioCodec.dequeueInputBuffer(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (inputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ByteBuffer byteBuffer = mAudioCodec.getInputBuffers()[inputBufferIndex];</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            byteBuffer.put(pcmData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// pts  44100 * 2 *2</span></span><br><span class="line">            mAudioPts += size * <span class="number">1000000</span> / mSampleRate * mChannels * <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// size 22050*2*2</span></span><br><span class="line">            mAudioCodec.queueInputBuffer(inputBufferIndex, <span class="number">0</span>, size, mAudioPts, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 音频的编码线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioEncoderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaMuxer mMediaMuxer;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoRecorder&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mAudioCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mAudioTrackIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mAudioPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier mStartCb, mDestroyCb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AudioEncoderThread</span><span class="params">(WeakReference&lt;BaseVideoRecorder&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mAudioCodec = videoRecorderWr.get().mAudioCodec;</span><br><span class="line">        mMediaMuxer = videoRecorderWr.get().mMediaMuxer;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        mStartCb = videoRecorderWr.get().mStartCb;</span><br><span class="line">        mDestroyCb = videoRecorderWr.get().mDestroyCb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoRecorder videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取音频数据，那这个音频数据从哪里来？音乐播放器里面来，pcm 数据</span></span><br><span class="line">                <span class="keyword">int</span> outputBufferIndex = mAudioCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    mAudioTrackIndex = mMediaMuxer.addTrack(mAudioCodec.getOutputFormat());</span><br><span class="line">                    mStartCb.await();</span><br><span class="line">                    <span class="comment">// mMediaMuxer.start();</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取数据</span></span><br><span class="line">                        ByteBuffer outBuffer = mAudioCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                        outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                        outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改 pts</span></span><br><span class="line">                        <span class="keyword">if</span> (mAudioPts == <span class="number">0</span>) &#123;</span><br><span class="line">                            mAudioPts = mBufferInfo.presentationTimeUs;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mBufferInfo.presentationTimeUs -= mAudioPts;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 写入数据</span></span><br><span class="line">                        mMediaMuxer.writeSampleData(mAudioTrackIndex, outBuffer, mBufferInfo);</span><br><span class="line"></span><br><span class="line">                        mAudioCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                        outputBufferIndex = mAudioCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mAudioCodec.stop();</span><br><span class="line">            mAudioCodec.release();</span><br><span class="line">            mDestroyCb.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/90.视频录制添加背景音乐的流程.png" alt></p><h1 id="2-详解H-264协议"><a href="#2-详解H-264协议" class="headerlink" title="2.详解H.264协议"></a>2.详解H.264协议</h1><p><img src="/images/90.h264协议详解.png" alt></p><p>首先需要明确 H264 可以分为两层，对于 VCL 具体的编解码算法这里暂时先不介绍，只介绍常用的 NAL 层，即网络提取层，这是解码的基础。：<br>1.VCL video codinglayer（视频编码层）<br>2.NAL network abstraction layer（网络提取层）。</p><p><img src="/images/90.NAL.png" alt></p><ul><li>SPS：序列参数集</li><li>PPS：图像参数集</li><li>I帧：帧内编码帧，可独立解码生成完整的图片。</li><li>P帧: 前向预测编码帧，需要参考其前面的一个I 或者B 来生成一张完整的图片。</li><li>B帧: 双向预测内插编码帧，则要参考其前一个I或者P帧及其后面的一个P帧来生成一张完整的图片</li></ul><h1 id="4-获取-MediaCodec-的-sps-和-pps"><a href="#4-获取-MediaCodec-的-sps-和-pps" class="headerlink" title="4.获取 MediaCodec 的 sps 和 pps"></a>4.获取 MediaCodec 的 sps 和 pps</h1><ul><li>SPS：Sequence Paramater Set，又称作序列参数集。SPS中保存了一组编码视频序列(Coded video sequence)的全局参数。所谓的编码视频序列即原始视频的一帧一帧的像素数据经过编码之后的结构组成的序列</li><li>PPS:除了序列参数集SPS之外，H.264中另一重要的参数集合为图像参数集Picture Paramater Set(PPS)。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频的编码线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoEncoderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoPush&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mVideoCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mVideoPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier mStartCb, mDestroyCb;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] mVideoSps,mVideoPps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoEncoderThread</span><span class="params">(WeakReference&lt;BaseVideoPush&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mVideoCodec = videoRecorderWr.get().mVideoCodec;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        mStartCb = videoRecorderWr.get().mStartCb;</span><br><span class="line">        mDestroyCb = videoRecorderWr.get().mDestroyCb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoPush videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 代码先不写，先测试，从 surface 上获取数据，编码成 h264 ,通过 MediaMuxer 合成 mp4</span></span><br><span class="line">                <span class="keyword">int</span> outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    <span class="comment">// mStartCb.await();</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取 sps 和 pps</span></span><br><span class="line">                    Log.e(<span class="string">"TAG"</span>, <span class="string">"获取 sps 和 pps"</span>);</span><br><span class="line">                    ByteBuffer byteBuffer = mVideoCodec.getOutputFormat().getByteBuffer(<span class="string">"csd-0"</span>);</span><br><span class="line">                    mVideoSps = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                    byteBuffer.get(mVideoSps, <span class="number">0</span>, mVideoSps.length);</span><br><span class="line"></span><br><span class="line">                    Log.e(<span class="string">"sps"</span>, bytesToHexString(mVideoSps));</span><br><span class="line"></span><br><span class="line">                    byteBuffer = mVideoCodec.getOutputFormat().getByteBuffer(<span class="string">"csd-1"</span>);</span><br><span class="line">                    mVideoPps = <span class="keyword">new</span> <span class="keyword">byte</span>[byteBuffer.remaining()];</span><br><span class="line">                    byteBuffer.get(mVideoPps, <span class="number">0</span>, mVideoPps.length);</span><br><span class="line"></span><br><span class="line">                    Log.e(<span class="string">"pps"</span>, bytesToHexString(mVideoPps));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取数据</span></span><br><span class="line">                        ByteBuffer outBuffer = mVideoCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                        outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                        outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改 pts</span></span><br><span class="line">                        <span class="keyword">if</span> (mVideoPts == <span class="number">0</span>) &#123;</span><br><span class="line">                            mVideoPts = mBufferInfo.presentationTimeUs;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mBufferInfo.presentationTimeUs -= mVideoPts;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[outBuffer.remaining()];</span><br><span class="line">                        outBuffer.get(data, <span class="number">0</span>, data.length);</span><br><span class="line">                        Log.e(<span class="string">"TAG"</span>,bytesToHexString(data));</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 回调当前录制的时间</span></span><br><span class="line">                        <span class="keyword">if</span> (videoRecorder.mRecordListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            videoRecorder.mRecordListener.onTime(mBufferInfo.presentationTimeUs / <span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        mVideoCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                        outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.stop();</span><br><span class="line">            mVideoCodec.release();</span><br><span class="line">            <span class="comment">// mDestroyCb.await();</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：18.FFmpeg-OpenGL朋友圈录制视频</title>
    <link href="http://eastup.github.io/89.FFmpeg-OpenGL%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/"/>
    <id>http://eastup.github.io/89.FFmpeg-OpenGL%E6%9C%8B%E5%8F%8B%E5%9C%88%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/</id>
    <published>2020-08-18T00:12:43.000Z</published>
    <updated>2020-11-12T07:33:34.813Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p><h1 id="1-OpenGL渲染流程介绍"><a href="#1-OpenGL渲染流程介绍" class="headerlink" title="1.OpenGL渲染流程介绍"></a>1.OpenGL渲染流程介绍</h1><p>怎么渲染一张图片：</p><ol><li>继承<code>GLSurfaceView</code></li><li>继承<code>GLSurfaceView.Renderer</code></li><li>写顶点和纹理渲染的代码</li><li>编译链接生成程序</li><li>生成加载 bitmap 的纹理</li><li>绘制到屏幕</li></ol><p>介绍一下纹理坐标系：<img src="/images/89.纹理坐标系.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶点坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mVertexCoordinate = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        -<span class="number">1f</span>, -<span class="number">1f</span>, <span class="comment">// 左下角</span></span><br><span class="line">        <span class="number">1f</span>, -<span class="number">1f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">        -<span class="number">1f</span>, <span class="number">1f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span>    <span class="comment">// 右上角</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span> FloatBuffer mVertexBuffer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纹理坐标(对应全屏)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mFragmentCoordinate = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0f</span>, <span class="number">1f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span>,</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">0f</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纹理坐标(对应半屏)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] mFragmentCoordinate = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">0.5f</span>,</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0f</span>,</span><br><span class="line">        <span class="number">1f</span>, <span class="number">0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>右边是OpenGL的渲染流程：<br><img src="/images/89.OpenGL%20的渲染原理.png" alt></p><h1 id="2-OpenGL渲染摄像头数据"><a href="#2-OpenGL渲染摄像头数据" class="headerlink" title="2.OpenGL渲染摄像头数据"></a>2.OpenGL渲染摄像头数据</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化视频的 MediaCodec</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> width</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> height</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initVideoCodec</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    MediaFormat videoFormat = MediaFormat.createVideoFormat(MediaFormat.MIMETYPE_VIDEO_AVC, width, height);</span><br><span class="line">    <span class="comment">// 设置颜色格式</span></span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);</span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_BIT_RATE, width * height * <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 设置帧率</span></span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_FRAME_RATE, <span class="number">24</span>);</span><br><span class="line">    <span class="comment">// 设置 I 帧的间隔时间</span></span><br><span class="line">    videoFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建编码器</span></span><br><span class="line">    mVideoCodec = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_VIDEO_AVC);</span><br><span class="line">    mVideoCodec.configure(videoFormat, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line"></span><br><span class="line">    mSurface = mVideoCodec.createInputSurface();</span><br><span class="line">    <span class="comment">// 开启一个编码采集 InputSurface 上的数据，合成视频</span></span><br><span class="line">    mVideoThread = <span class="keyword">new</span> VideoEncoderThread(mVideoRecorderWr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频的渲染线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoRenderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoRecorder&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> EglHelper mEglHelper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHashCreateContext = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHashSurfaceCreated = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mHashSurfaceChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mWidth;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mHeight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoRenderThread</span><span class="params">(WeakReference&lt;BaseVideoRecorder&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mEglHelper = <span class="keyword">new</span> EglHelper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoRecorder videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 1. 创建 EGL 上下文</span></span><br><span class="line">                <span class="keyword">if</span> (!mHashCreateContext) &#123;</span><br><span class="line">                    mEglHelper.initCreateEgl(videoRecorder.mSurface, videoRecorder.mEglContext);</span><br><span class="line">                    mHashCreateContext = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 回调 Render</span></span><br><span class="line">                GL10 gl = (GL10) mEglHelper.getEglContext().getGL();</span><br><span class="line">                <span class="keyword">if</span> (!mHashSurfaceCreated) &#123;</span><br><span class="line">                    videoRecorder.mRenderer.onSurfaceCreated(gl, mEglHelper.getEGLConfig());</span><br><span class="line">                    mHashSurfaceCreated = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!mHashSurfaceChanged) &#123;</span><br><span class="line">                    videoRecorder.mRenderer.onSurfaceChanged(gl, mWidth, mHeight);</span><br><span class="line">                    mHashSurfaceChanged = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                videoRecorder.mRenderer.onDrawFrame(gl);</span><br><span class="line"></span><br><span class="line">                mEglHelper.swapBuffers();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 60 fps</span></span><br><span class="line">                Thread.sleep(<span class="number">16</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mEglHelper.destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSize</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mWidth = width;</span><br><span class="line">        <span class="keyword">this</span>.mHeight = height;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-视频编码录制"><a href="#3-视频编码录制" class="headerlink" title="3.视频编码录制"></a>3.视频编码录制</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频的编码线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoEncoderThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MediaMuxer mMediaMuxer;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;BaseVideoRecorder&gt; mVideoRecorderWr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mShouldExit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec mVideoCodec;</span><br><span class="line">    <span class="keyword">private</span> MediaCodec.BufferInfo mBufferInfo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mVideoTrackIndex = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mVideoPts = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier mStartCb, mDestroyCb;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoEncoderThread</span><span class="params">(WeakReference&lt;BaseVideoRecorder&gt; videoRecorderWr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mVideoRecorderWr = videoRecorderWr;</span><br><span class="line">        mVideoCodec = videoRecorderWr.get().mVideoCodec;</span><br><span class="line">        mMediaMuxer = videoRecorderWr.get().mMediaMuxer;</span><br><span class="line">        mBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">        mStartCb = videoRecorderWr.get().mStartCb;</span><br><span class="line">        mDestroyCb = videoRecorderWr.get().mDestroyCb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mShouldExit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BaseVideoRecorder videoRecorder = mVideoRecorderWr.get();</span><br><span class="line">                <span class="keyword">if</span> (videoRecorder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 代码先不写，先测试，从 surface 上获取数据，编码成 h264 ,通过 MediaMuxer 合成 mp4</span></span><br><span class="line">                <span class="keyword">int</span> outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123;</span><br><span class="line">                    mVideoTrackIndex = mMediaMuxer.addTrack(mVideoCodec.getOutputFormat());</span><br><span class="line">                    mMediaMuxer.start();</span><br><span class="line">                    mStartCb.await();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (outputBufferIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 获取数据</span></span><br><span class="line">                        ByteBuffer outBuffer = mVideoCodec.getOutputBuffers()[outputBufferIndex];</span><br><span class="line">                        outBuffer.position(mBufferInfo.offset);</span><br><span class="line">                        outBuffer.limit(mBufferInfo.offset + mBufferInfo.size);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 修改 pts</span></span><br><span class="line">                        <span class="keyword">if</span> (mVideoPts == <span class="number">0</span>) &#123;</span><br><span class="line">                            mVideoPts = mBufferInfo.presentationTimeUs;</span><br><span class="line">                        &#125;</span><br><span class="line">                        mBufferInfo.presentationTimeUs -= mVideoPts;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 写入数据</span></span><br><span class="line">                        mMediaMuxer.writeSampleData(mVideoTrackIndex, outBuffer, mBufferInfo);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 回调当前录制的时间</span></span><br><span class="line">                        <span class="keyword">if</span> (videoRecorder.mRecordListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            videoRecorder.mRecordListener.onTime(mBufferInfo.presentationTimeUs / <span class="number">1000</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        mVideoCodec.releaseOutputBuffer(outputBufferIndex, <span class="keyword">false</span>);</span><br><span class="line">                        outputBufferIndex = mVideoCodec.dequeueOutputBuffer(mBufferInfo, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            onDestroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mVideoCodec.stop();</span><br><span class="line">            mVideoCodec.release();</span><br><span class="line">            mDestroyCb.await();</span><br><span class="line">            mMediaMuxer.stop();</span><br><span class="line">            mMediaMuxer.release();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestExit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mShouldExit = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：17.FFmpeg-直播推、拉流</title>
    <link href="http://eastup.github.io/88.FFmpeg-%E7%9B%B4%E6%92%AD%E6%8E%A8%E3%80%81%E6%8B%89%E6%B5%81/"/>
    <id>http://eastup.github.io/88.FFmpeg-%E7%9B%B4%E6%92%AD%E6%8E%A8%E3%80%81%E6%8B%89%E6%B5%81/</id>
    <published>2020-08-17T00:12:43.000Z</published>
    <updated>2020-11-12T07:29:04.587Z</updated>
    
    <content type="html"><![CDATA[<font color="red"> 以下使用&nbsp;&nbsp;&nbsp;&nbsp;Ubuntu&nbsp;&nbsp;&nbsp;&nbsp;环境搭建的</font><p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg88livepush" target="_blank" rel="noopener">NDKPractice项目的ffmpeg88livepush</a></strong></p><h1 id="1-搭建流媒体服务器"><a href="#1-搭建流媒体服务器" class="headerlink" title="1.搭建流媒体服务器"></a>1.搭建流媒体服务器</h1><h2 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h2><ol><li><p>在ubuntu系统中首先切换到<code>root</code>用户,然后cd到<code>lib</code>目录下，<code>mkdir新建nginx</code>文件夹。</p></li><li><p>使用 <code>wget ftp://ftp.pcre.org/pub/pcre/pcre-8.38.zip</code> 下载 <code>pcre-8.38.zip版本</code>，也可以直接下载最新的版本.  </p><ul><li>下载下来后使用<code>chmod u+x pcre-8.38.zip</code>修改权限,<code>unzip pcre-8.38.zip</code>解压然后进入解压的文件夹中。</li><li>使用<code>./configure</code>运行会生成CMakeLists.txt  </li><li>接着使用<code>make</code>指令执行.    </li><li>最后使用<code>make install</code>指令执行.  </li></ul></li><li><p>下载<code>zlib</code>,点击 <a href="https://github.com/madler/zlib/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p><ul><li>返回nginx目录下使用 <code>wget https://github.com/madler/zlib/archive/v1.2.11.tar.gz</code> 下载。</li><li>下载下来后使用<code>chmod u+x v1.2.11.tar.gz</code>修改权限,<code>tar -zxvf v1.2.11.tar.gz</code>解压然后进入解压的文件夹中。</li><li>使用<code>./configure</code>运行会生成CMakeLists.txt  </li><li>接着使用<code>make</code>指令执行.    </li><li>最后使用<code>make install</code>指令执行.  </li></ul></li><li><p>下载<code>rtmp</code>,点击 <a href="https://github.com/arut/nginx-rtmp-module/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p><ul><li>返回nginx目录下使用 <code>wget https://github.com/arut/nginx-rtmp-module/archive/v1.2.1.tar.gz</code> 下载。</li><li>下载下来后使用<code>chmod u+x v1.2.1.tar.gz</code>修改权限,<code>tar -zxvf v1.2.1.tar.gz</code>解压。这个不需要安装。</li></ul></li><li><p>下载<code>openssl</code>,点击 <a href="https://github.com/openssl/openssl/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p><ul><li>返回nginx目录下使用 <code>wget https://github.com/openssl/openssl/archive/OpenSSL_1_1_1c.tar.gz</code> 下载。</li><li>下载下来后使用<code>chmod u+x OpenSSL_1_1_1c.tar.gz</code>修改权限,<code>tar -zxvf OpenSSL_1_1_1c.tar.gz</code>解压然后进入解压的文件夹中。</li><li>使用 <code>./config --prefix=</code>&#96;<code>pwd</code>&#96;<code>/libs</code> 运行会生成CMakeLists.txt文件，&#96;pwd&#96;指令代表当前目录文件</li><li>接着使用<code>make</code>指令执行.    </li><li>最后使用<code>make install</code>指令执行.  </li></ul></li><li><p>下载<code>nginx</code>,<font color="red">必须依赖前面安装的所有东西</font> 点击 <a href="https://github.com/nginx/nginx/releases" target="_blank" rel="noopener">链接</a> 右键点击最新版本的<code>tar.gz</code>复制链接地址。</p><ul><li>返回nginx目录下使用 <code>wget https://github.com/nginx/nginx/archive/release-1.17.1.tar.gz</code> 下载。</li><li>下载下来后使用<code>chmod u+x release-1.17.1.tar.gz</code>修改权限,<code>tar -zxvf release-1.17.1.tar.gz</code>解压然后进入解压的文件夹中。</li><li>使用 <code>./auto/configure --add-module=/lib/nginx/nginx-rtmp-module-1.2.1 --with-cc-opt=&quot;-Wimplicit-fallthrough=0&quot; --with-openssl=/lib/nginx/openssl-OpenSSL_1_1_1c</code></li><li>接着使用<code>make</code>指令执行.    </li><li>最后使用<code>make install</code>指令执行.  </li></ul></li></ol><ul><li>nginx:  <a href="https://github.com/nginx/nginx/releases" target="_blank" rel="noopener">https://github.com/nginx/nginx/releases</a></li><li>rtmp:  <a href="https://github.com/arut/nginx-rtmp-module/releases" target="_blank" rel="noopener">https://github.com/arut/nginx-rtmp-module/releases</a></li><li>pcre:  ftp://ftp.pcre.org/pub/pcre/ 下载最新版本，这边下载 pcre-8.38.zip</li><li>zlib:  <a href="https://github.com/madler/zlib/releases" target="_blank" rel="noopener">https://github.com/madler/zlib/releases</a></li><li>openssl:  <a href="https://github.com/openssl/openssl" target="_blank" rel="noopener">https://github.com/openssl/openssl</a></li></ul><p><strong>出现的问题</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">checking for OS</span><br><span class="line"> + Linux 5.4.0-48-generic x86_64</span><br><span class="line">checking for C compiler ... not found</span><br><span class="line"></span><br><span class="line">.&#x2F;auto&#x2F;configure: error: C compiler cc is not found</span><br><span class="line"></span><br><span class="line">解决：sudo apt-get install gcc</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">nginx 执行make时出现的问题</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">..&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.c: In function ‘ngx_rtmp_eval’:</span><br><span class="line">..&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.c:160:17: error: this statement may fall through [-Werror&#x3D;implicit-fallthrough&#x3D;]</span><br><span class="line">                 switch (c) &#123;</span><br><span class="line">                 ^~~~~~</span><br><span class="line">..&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.c:170:13: note: here</span><br><span class="line">             case ESCAPE:</span><br><span class="line">             ^~~~</span><br><span class="line">cc1: all warnings being treated as errors</span><br><span class="line">make[1]: *** [objs&#x2F;Makefile:1349: objs&#x2F;addon&#x2F;nginx-rtmp-module-master&#x2F;ngx_rtmp_eval.o] Error 1</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;pi&#x2F;nginx-1.19.0&#39;</span><br><span class="line">make: *** [Makefile:8: build] Error 2</span><br><span class="line"></span><br><span class="line">解决：</span><br><span class="line"></span><br><span class="line">禁用gcc中的“ fallthrough”，在配置时添加选项</span><br><span class="line">.&#x2F;auto&#x2F;configure --add-module&#x3D;&#x2F;lib&#x2F;nginx&#x2F;nginx-rtmp-module-1.2.1 --with-cc-opt&#x3D;&quot;-Wimplicit-fallthrough&#x3D;0&quot; --with-openssl&#x3D;&#x2F;lib&#x2F;nginx&#x2F;openssl-OpenSSL_1_1_1c</span><br></pre></td></tr></table></figure><h2 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h2><p>执行命令<code>cp /lib/nginx/nginx-rtmp-module-1.2.1/test/nginx.conf /usr/local/nginx/conf/</code>  </p><p>替换<code>nginx.cong</code>。具体的可参考<a href="https://github.com/arut/nginx-rtmp-module" target="_blank" rel="noopener">链接</a>中的<code>Example nginx.conf</code></p><p>类似下面这种：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">orker_processes  1;</span><br><span class="line"></span><br><span class="line">error_log  logs&#x2F;error.log debug;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935;</span><br><span class="line"></span><br><span class="line">        application myapp &#123;</span><br><span class="line">            live on;</span><br><span class="line"></span><br><span class="line">            #record keyframes;</span><br><span class="line">            #record_path &#x2F;tmp;</span><br><span class="line">            #record_max_size 128K;</span><br><span class="line">            #record_interval 30s;</span><br><span class="line">            #record_suffix .this.is.flv;</span><br><span class="line"></span><br><span class="line">....</span><br></pre></td></tr></table></figure></p><h2 id="1-3-启动和停止"><a href="#1-3-启动和停止" class="headerlink" title="1.3 启动和停止"></a>1.3 启动和停止</h2><ul><li>启动：<code>./nginx</code></li><li>停止：<code>./nginx -s stop</code></li></ul><p>常见问题：</p><ol><li>端口被占用（默认8080端口）</li><li><p>启动错误：比如 xxx.so 找不到。</p><p> 解决：<br> 使用<code>ldd $(which ./nginx)</code>查看依赖包。<br> 调用<code>export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</code>  </p></li></ol><h2 id="1-4-测试"><a href="#1-4-测试" class="headerlink" title="1.4 测试"></a>1.4 测试</h2><p>windows ffmpeg<a href="https://github.com/BtbN/FFmpeg-Builds/releases" target="_blank" rel="noopener">下载地址</a></p><p>mac 和 linux 类似，进入<a href="http://www.ffmpeg.org/download.html" target="_blank" rel="noopener">官网下载</a> 。</p><p>下面以windows为例测试步骤：</p><ol><li>进入下载好的ffmpeg解压目录的/bin目录文件夹下</li><li>使用命令推流：<code>.\ffmpeg.exe -re -i 等风来不如追风去.mp4 -vcodec libx264 -acodec aac -f flv rtmp://192.168.1.20/myapp/mystream</code></li><li>使用命令拉流：<code>ffplay.exe rtmp://192.168.1.20/myapp/mystream</code></li></ol><p>推流命令说明：</p><ul><li><code>等风来不如追风去.mp4</code>：是要推流的视频绝对路径。</li><li><code>rtmp://192.168.1.20/myapp/mystream</code>：要推流的地址。192.168.1.20为公网地址或局域网的地址。</li></ul><h1 id="2-集成-RTMP-推流源码"><a href="#2-集成-RTMP-推流源码" class="headerlink" title="2.集成 RTMP 推流源码"></a>2.集成 RTMP 推流源码</h1><p><img src="/images/88.直播推拉流原理.png" alt>  </p><p><img src="/images/91.直播推流原理.png" alt></p><p>采用一种 socket 通讯方案 <a href="http://rtmpdump.mplayerhq.hu/" target="_blank" rel="noopener">RTMPDump</a></p><ol><li>git clone 上面网站中的地址 <code>git clone git://git.ffmpeg.org/rtmpdump</code></li><li>将clone下来的文件夹中的librtmp目录中的所有<code>*.c</code>和<code>*.h</code>文件拷贝到工程目录中开始开发。</li><li>如果出现下面的错误就在CMakeLists.txt 中添加 <code>set(CMAKE_C_FLAGS &quot;${CMAKE_C_FLAGS} -DNO_CRYPTO&quot;)</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">****\src\main\cpp\rtmp\hashswf.c:56:10: fatal error: &#39;openssl&#x2F;ssl.h&#39; file not found</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadInitConnect</span><span class="params">(<span class="keyword">void</span> *args)</span> </span>&#123;</span><br><span class="line">    LivePush *livePush = (LivePush *) args;</span><br><span class="line">    <span class="comment">// 1.创建RTMP</span></span><br><span class="line">    livePush-&gt;pRtmp = RTMP_Alloc();</span><br><span class="line">    <span class="comment">// 2. 初始化</span></span><br><span class="line">    RTMP_Init(livePush-&gt;pRtmp);</span><br><span class="line">    <span class="comment">// 3. 设置参数</span></span><br><span class="line">    livePush-&gt;pRtmp-&gt;Link.timeout = <span class="number">10</span>; <span class="comment">// 超时时间 10 秒</span></span><br><span class="line">    livePush-&gt;pRtmp-&gt;Link.lFlags = RTMP_LF_LIVE; <span class="comment">// 长连接</span></span><br><span class="line">    RTMP_SetupURL(livePush-&gt;pRtmp, livePush-&gt;liveUrl);<span class="comment">// 设置推流的地址</span></span><br><span class="line">    RTMP_EnableWrite(livePush-&gt;pRtmp);<span class="comment">// 可写</span></span><br><span class="line">    <span class="comment">// 4. 开始连接</span></span><br><span class="line">    <span class="keyword">if</span> (!RTMP_Connect(livePush-&gt;pRtmp, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        <span class="comment">// 回调到java层</span></span><br><span class="line">        LOGE(<span class="string">"rtmp connect error"</span>);</span><br><span class="line">        livePush-&gt;pJniCall-&gt;callConnectError(THREAD_CHILD, INIT_RTMP_CONNECT_ERROR_CODE,</span><br><span class="line">                                             <span class="string">"rtmp connect error"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)(INIT_RTMP_CONNECT_ERROR_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RTMP_ConnectStream(livePush-&gt;pRtmp, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// 回调到java层</span></span><br><span class="line">        LOGE(<span class="string">"rtmp connect stream error"</span>);</span><br><span class="line">        livePush-&gt;pJniCall-&gt;callConnectError(THREAD_CHILD, INIT_RTMP_CONNECT_STREAM_ERROR_CODE,</span><br><span class="line">                                             <span class="string">"rtmp connect stream error"</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span> *)(INIT_RTMP_CONNECT_STREAM_ERROR_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">"rtmp connect success"</span>);</span><br><span class="line">    livePush-&gt;pJniCall-&gt;callConnectSuccess(THREAD_CHILD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font color=&quot;red&quot;&gt; 以下使用&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Ubuntu&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;环境搭建的&lt;/font&gt;

&lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/Eas
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：16.FFmpeg-视频播放器2</title>
    <link href="http://eastup.github.io/87.FFmpeg-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A82/"/>
    <id>http://eastup.github.io/87.FFmpeg-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A82/</id>
    <published>2020-08-16T00:12:43.000Z</published>
    <updated>2020-11-12T07:28:31.681Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg86" target="_blank" rel="noopener">NDKPractice项目的ffmpeg87</a></strong></p><h1 id="1-调整音乐播放器项目架构"><a href="#1-调整音乐播放器项目架构" class="headerlink" title="1.调整音乐播放器项目架构"></a>1.调整音乐播放器项目架构</h1><p>解码的流程 Video 和 Audio 很多相同的，所以抽离出来了公共类: Media.cpp</p><p>音频和视频单独处理成：Audio.cpp 和 Video.cpp，都继承自Media,cpp</p><p>遇到的问题：<font color="red">下面这个方法的env 不能使用 pJniCall-&gt;jniEnv</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Video::setSurface</span><span class="params">(JNIEnv *env, jobject surface)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里不能使用pJniCall-&gt;jniEnv-&gt;的env，因为和native方法传递过来的不一样，而且不相等</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  注释的这行代码会报错</span></span><br><span class="line"><span class="comment">     *   'JNI DETECTED ERROR IN APPLICATION: invalid address...,thread Thread[21,tid=25717,Native,Thread*=0xc2e4a000,peer=0x12e40000,"Thread-3"] using JNIEnv* from thread Thread[1,tid=25650,Runnable,Thread*=0xf1b71e00,peer=0x757719a0,"main"]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">//    this-&gt;surface = pJniCall-&gt;jniEnv-&gt;NewGlobalRef(surface);</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;videoJNIEnv = env;</span><br><span class="line">    <span class="keyword">this</span>-&gt;surface = env-&gt;NewGlobalRef(surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-视音频的同步"><a href="#2-视音频的同步" class="headerlink" title="2. 视音频的同步"></a>2. 视音频的同步</h1><p><img src="/images/87.视音频同步.png" alt></p><ul><li>pts：显示时间戳，用来告诉播放器该在什么时候显示这一帧数据。单位是不确定，所以使用时间基来获取单位</li><li>time_base：时间度量单位（时间基）。</li></ul><p>有三种办法：</p><ol><li>参考一个外部时钟，将音频与视频同步至此时间。</li><li>以视频为基准，音频去同步视频的时间。</li><li>以音频为基准，视频去同步音频的时间。</li></ol><p><code>由于某些生物学的原理，人对声音的变化比较敏感，但是对视觉变化不太敏感。所以采用方案 3</code></p><ul><li><code>static inline double av_q2d(AVRational a)</code>：使用时间基获取单位</li><li><code>timeBase = pFormatContext-&gt;streams[streamIndex]-&gt;time_base;</code>：获取时间基</li><li><code>duration = pFormatContext-&gt;duration;</code>：获取音视频时长（<code>单位微秒</code>）</li><li><code>double times = av_frame_get_best_effort_timestamp(pFrame) * av_q2d(timeBase);</code>: 获取当前时间</li><li><code>double times = pPacket-&gt;pts * av_q2d(timeBase);</code>: 获取当前时间</li><li><code>av_usleep(frameSleepTime * 1000000);</code>：休眠（<code>单位毫秒</code>）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 播放之前判断一下要休眠多久</span></span><br><span class="line"><span class="keyword">double</span> frameSleepTime = pVideo-&gt;getFrameSleepTime(pPacket,pFrame); <span class="comment">// 这是秒</span></span><br><span class="line">av_usleep(frameSleepTime * <span class="number">1000000</span>);<span class="comment">// 这是毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Video::getFrameSleepTime</span><span class="params">(AVPacket *pPacket,AVFrame *pFrame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这两种方法都能算出当前显示帧的时间</span></span><br><span class="line"><span class="comment">//    double times = av_frame_get_best_effort_timestamp(pFrame) * av_q2d(timeBase);</span></span><br><span class="line">    <span class="keyword">double</span> times = pPacket-&gt;pts * av_q2d(timeBase);</span><br><span class="line">    <span class="keyword">if</span> (times &gt; currentTime) &#123;</span><br><span class="line">        currentTime = times;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相差多少秒</span></span><br><span class="line">    <span class="keyword">double</span> diffTime = pAudio-&gt;currentTime - currentTime; <span class="comment">// 负数，音频比视频慢</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 视频快了就慢点，视频慢了就快点</span></span><br><span class="line">    <span class="comment">// 但是尽量把事件控制在视频的帧率时间范围左右  1/24 0.04 1/30 0.033</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次控制 0.016s 到 -0.016s</span></span><br><span class="line">    <span class="keyword">if</span> (diffTime &gt; <span class="number">0.016</span> || diffTime &lt; <span class="number">-0.016</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (diffTime &gt; <span class="number">0.016</span>) &#123;</span><br><span class="line">            delayTime = delayTime * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diffTime &lt; <span class="number">-0.016</span>) &#123;</span><br><span class="line">            delayTime = delayTime * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二次控制 defaultDelayTIme * 2 / 3 到 defaultDelayTime * 3 / 2</span></span><br><span class="line">        <span class="keyword">if</span> (delayTime &lt; defaultDelayTime / <span class="number">2</span>) &#123;</span><br><span class="line">            delayTime = defaultDelayTime * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (delayTime &gt; defaultDelayTime * <span class="number">2</span>) &#123;</span><br><span class="line">            delayTime = defaultDelayTime * <span class="number">3</span> / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第三次控制，这基本是异常情况</span></span><br><span class="line">    <span class="keyword">if</span> (diffTime &gt;= <span class="number">0.25</span>)</span><br><span class="line">        delayTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (diffTime &lt;= <span class="number">-0.25</span>)</span><br><span class="line">        delayTime = defaultDelayTime * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    LOGE(<span class="string">"diffTime = %lf秒,delayTime = %lf秒,\n"</span></span><br><span class="line">         <span class="string">"pAudio-&gt;currentTime = %lf秒,cureentTime = %lf秒,duration = %d秒"</span>,diffTime,delayTime,pAudio-&gt;currentTime,currentTime,duration/<span class="number">1000</span>/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> delayTime;</span><br><span class="line"><span class="comment">//    return -diffTime;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还差：暂停，停止，回调，倍速播放，硬解码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的ffmpeg87
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：15.FFmpeg-视频播放器1</title>
    <link href="http://eastup.github.io/86.FFmpeg-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A81/"/>
    <id>http://eastup.github.io/86.FFmpeg-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A81/</id>
    <published>2020-08-15T00:12:43.000Z</published>
    <updated>2020-11-12T07:25:29.076Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg86" target="_blank" rel="noopener">NDKPractice项目的ffmpeg86</a></strong></p><p>将之前的音乐播放器代码整合进来</p><h1 id="1-使用FFmpeg解码视频"><a href="#1-使用FFmpeg解码视频" class="headerlink" title="1.使用FFmpeg解码视频"></a>1.使用FFmpeg解码视频</h1><p>跟使用FFmpeg解码音频流程一致，但需要判断是否能硬解码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------需要将视频的格式一般为yuv420P转为RBGA8888-------------------------//</span></span><br><span class="line">   <span class="comment">// 1. 获取窗体</span></span><br><span class="line">   ANativeWindow *pNativeWindow = ANativeWindow_fromSurface(env,surface);</span><br><span class="line">   <span class="comment">// 2.设置缓冲区的数据</span></span><br><span class="line">   ANativeWindow_setBuffersGeometry(pNativeWindow,pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,</span><br><span class="line">           WINDOW_FORMAT_RGBA_8888);</span><br><span class="line">   <span class="comment">// Window 缓冲区的 Buffer</span></span><br><span class="line">   ANativeWindow_Buffer outBuffer;</span><br><span class="line">   <span class="comment">// 3.初始化转换上下文</span></span><br><span class="line">   SwsContext *pSwsContext = sws_getContext(pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,pCodecContext-&gt;pix_fmt,</span><br><span class="line">                  pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,AV_PIX_FMT_RGBA,</span><br><span class="line">                  SWS_BILINEAR,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">   AVFrame *pRgbaFrame = av_frame_alloc();</span><br><span class="line">   <span class="keyword">int</span> frameSize = av_image_get_buffer_size(AV_PIX_FMT_RGBA,pCodecContext-&gt;<span class="built_in">width</span>,</span><br><span class="line">           pCodecContext-&gt;<span class="built_in">height</span>,<span class="number">1</span>);</span><br><span class="line">   <span class="keyword">uint8_t</span> *frameBuffer = (<span class="keyword">uint8_t</span>*)<span class="built_in">malloc</span>(frameSize);</span><br><span class="line">   <span class="comment">// 填充</span></span><br><span class="line">   av_image_fill_arrays(pRgbaFrame-&gt;data,pRgbaFrame-&gt;linesize,frameBuffer,AV_PIX_FMT_RGBA,</span><br><span class="line">                        pCodecContext-&gt;<span class="built_in">width</span>,pCodecContext-&gt;<span class="built_in">height</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   pPacket = av_packet_alloc();</span><br><span class="line">   pFrame = av_frame_alloc();</span><br><span class="line">   <span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStramIndex) &#123;</span><br><span class="line">           <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">           <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">           <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">               <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                   index++;</span><br><span class="line">                   LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line">                   <span class="comment">// 渲染，显示，OpenGLES (高效，硬件支持)，SurfaceView</span></span><br><span class="line">                   <span class="comment">// 硬件加速和不加速有什么区别？cup 主要是用于计算，gpu 图像支持（硬件）</span></span><br><span class="line">                   <span class="comment">// 这个 pFrame-&gt;data , 一般 yuv420P 的，RGBA8888，因此需要转换</span></span><br><span class="line">                   <span class="comment">// 假设拿到了转换后的 RGBA 的 data 数据，如何渲染，把数据推到缓冲区</span></span><br><span class="line">                   sws_scale(pSwsContext,pFrame-&gt;data,pFrame-&gt;linesize,</span><br><span class="line">                           <span class="number">0</span>,pCodecContext-&gt;<span class="built_in">height</span>,pRgbaFrame-&gt;data,pRgbaFrame-&gt;linesize);</span><br><span class="line">                   <span class="comment">// 把数据推到缓冲区</span></span><br><span class="line">                   ANativeWindow_lock(pNativeWindow,&amp;outBuffer,<span class="literal">NULL</span>);</span><br><span class="line">                   <span class="built_in">memcpy</span>(outBuffer.bits,frameBuffer,frameSize);</span><br><span class="line">                   ANativeWindow_unlockAndPost(pNativeWindow);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 解引用</span></span><br><span class="line">       av_packet_unref(pPacket);</span><br><span class="line">       av_frame_unref(pFrame);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><font color="red">问题：视音频还是没同步的问题（视频快，音频正常）</font><h1 id="2-渲染视频"><a href="#2-渲染视频" class="headerlink" title="2.渲染视频"></a>2.渲染视频</h1><h2 id="2-1-OpenGLES解释（渲染视频高效，硬件支持）"><a href="#2-1-OpenGLES解释（渲染视频高效，硬件支持）" class="headerlink" title="2.1 OpenGLES解释（渲染视频高效，硬件支持）"></a>2.1 OpenGLES解释（渲染视频高效，硬件支持）</h2><h3 id="2-1-1-OpenGL概念"><a href="#2-1-1-OpenGL概念" class="headerlink" title="2.1.1 OpenGL概念"></a>2.1.1 OpenGL概念</h3><p>OpenGL 是一种应用程序的编程接口，它是一种可以对图像硬件设备进行访问的软件库，OpenGL 被设计为一个现代化的，硬件无关的接口，<br>因此我们不用考虑操作系统的前提下，在多种不同的图像硬件系统上通过软件的形式来实现 OpenGL 接口。<br>OpenGL 也没有提供任何表达三维物体模型和读取图文的操作，我们需要用一系列的几何图元来创建三维物体。<br>图元：线，三角形，点，patch  </p><h3 id="2-1-2-OpenGL-用来干什么"><a href="#2-1-2-OpenGL-用来干什么" class="headerlink" title="2.1.2 OpenGL 用来干什么"></a>2.1.2 OpenGL 用来干什么</h3><p>渲染视频、图形，图片处理，2D/3D 游戏引擎，科学可视化，CAD，虚拟现实，AI人工智能等等</p><h3 id="2-1-3-OpenGL-与-OpenGLES-有什么关系？"><a href="#2-1-3-OpenGL-与-OpenGLES-有什么关系？" class="headerlink" title="2.1.3 OpenGL 与 OpenGLES 有什么关系？"></a>2.1.3 OpenGL 与 OpenGLES 有什么关系？</h3><p>OpenGLES 是 OpenGL 阉割（精简）版本，主要用于移动端</p><h3 id="2-1-4-OpenGL后续学习"><a href="#2-1-4-OpenGL后续学习" class="headerlink" title="2.1.4 OpenGL后续学习"></a>2.1.4 OpenGL后续学习</h3><p>看谷歌的<a href="https://github.com/googlesamples/android-ndk/tree/master/gles3jni" target="_blank" rel="noopener">示例</a>  </p><p>学开发编程的约定，坐标系变化，标量向量，渲染流水线  </p><p>基础绘制（数学基础），纹理，模型，雾效果，相机，美容，native 层  </p><h2 id="2-2-SurfaceView-渲染视频（这节先用SurfaceView）"><a href="#2-2-SurfaceView-渲染视频（这节先用SurfaceView）" class="headerlink" title="2.2 SurfaceView 渲染视频（这节先用SurfaceView）"></a>2.2 SurfaceView 渲染视频（这节先用SurfaceView）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">源代码分析：</span><br><span class="line">ViewRootImpl.performDraw()</span><br><span class="line">-&gt; ViewRootImpl.draw(fullRedrawNeeded);</span><br><span class="line">-&gt; ViewRootImpl.drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                           scalingRequired, dirty, surfaceInsets)</span><br><span class="line">   </span><br><span class="line">    canvas &#x3D; mSurface.lockCanvas(dirty);</span><br><span class="line">    mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">最后通过 ViewGroup 绘制子 View 将 canvas 传递下去</span><br></pre></td></tr></table></figure><h3 id="2-2-1-Button-和-TextView-的-Canvas-是不是同一个？"><a href="#2-2-1-Button-和-TextView-的-Canvas-是不是同一个？" class="headerlink" title="2.2.1 Button 和 TextView 的 Canvas 是不是同一个？"></a>2.2.1 Button 和 TextView 的 Canvas 是不是同一个？</h3><p>是！！！</p><h3 id="2-2-2-Canvas-是从哪里来的？"><a href="#2-2-2-Canvas-是从哪里来的？" class="headerlink" title="2.2.2 Canvas 是从哪里来的？"></a>2.2.2 Canvas 是从哪里来的？</h3><p>根布局的 <code>Canvas canvas = mSurface.lockCanvas(dirty)</code></p><h3 id="2-2-3-Canvas-绘制的东西到哪里去了（怎么渲染出来的）？"><a href="#2-2-3-Canvas-绘制的东西到哪里去了（怎么渲染出来的）？" class="headerlink" title="2.2.3 Canvas 绘制的东西到哪里去了（怎么渲染出来的）？"></a>2.2.3 Canvas 绘制的东西到哪里去了（怎么渲染出来的）？</h3><p><img src="/images/86.页面渲染流程.png" alt></p><h3 id="2-2-4-为什么-SurfaceView-能在子线程中更新-UI"><a href="#2-2-4-为什么-SurfaceView-能在子线程中更新-UI" class="headerlink" title="2.2.4 为什么 SurfaceView 能在子线程中更新 UI"></a>2.2.4 为什么 SurfaceView 能在子线程中更新 UI</h3><p>只要View是在子线程中创建的，就可以在子线程中可以更新UI。（代码中判断的是不是当前线程）</p><h3 id="2-2-5-SurfaceView的挖洞原理（显示机制）SurfaceFilnger"><a href="#2-2-5-SurfaceView的挖洞原理（显示机制）SurfaceFilnger" class="headerlink" title="2.2.5 SurfaceView的挖洞原理（显示机制）SurfaceFilnger"></a>2.2.5 SurfaceView的挖洞原理（显示机制）SurfaceFilnger</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg86&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的ffmpeg86
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：14.FFmpeg-音乐播放器3</title>
    <link href="http://eastup.github.io/85.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A83/"/>
    <id>http://eastup.github.io/85.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A83/</id>
    <published>2020-08-14T00:12:43.000Z</published>
    <updated>2020-11-12T07:22:52.107Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83" target="_blank" rel="noopener">NDKPractice项目的ffmpeg83</a></strong></p><h1 id="1-添加准备完毕回调"><a href="#1-添加准备完毕回调" class="headerlink" title="1.添加准备完毕回调"></a>1.添加准备完毕回调</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">JNICall::JNICall(JavaVM *javaVM, JNIEnv *jniEnv, jobject jPlayerObj) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;javaVM = javaVM;</span><br><span class="line">    <span class="keyword">this</span>-&gt;jniEnv = jniEnv;</span><br><span class="line">    <span class="keyword">this</span>-&gt;jPlayerObj = jniEnv-&gt;NewGlobalRef(jPlayerObj);</span><br><span class="line"></span><br><span class="line">    jclass jPlayerClass = jniEnv-&gt;GetObjectClass(jPlayerObj);</span><br><span class="line">    jPlayerErrorMid = jniEnv-&gt;GetMethodID(jPlayerClass, <span class="string">"onError"</span>, <span class="string">"(ILjava/lang/String;)V"</span>);</span><br><span class="line">    jPlayerPreparedMid = jniEnv-&gt;GetMethodID(jPlayerClass, <span class="string">"onPrepared"</span>, <span class="string">"()V"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JNICall::CallPlayerPrepared</span><span class="params">(ThreadMode threadMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子线程(pThread)用不了主线程(native线程)的 jniEnv</span></span><br><span class="line">    <span class="comment">// 子线程是不共享 jniEnv，他们有自己所独有的</span></span><br><span class="line">    <span class="keyword">if</span> (threadMode == THREAD_MAIN) &#123;</span><br><span class="line">        jniEnv-&gt;CallVoidMethod(jPlayerObj, jPlayerPreparedMid);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 JavaVM获取当前线程的 JniEnv</span></span><br><span class="line">        JNIEnv *env;</span><br><span class="line">        <span class="keyword">if</span> (javaVM-&gt;AttachCurrentThread(&amp;env, <span class="number">0</span>) != JNI_OK) &#123;</span><br><span class="line">            LOGE(<span class="string">"get child thread jniEnv error"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        env-&gt;CallVoidMethod(jPlayerObj, jPlayerPreparedMid);</span><br><span class="line">        javaVM-&gt;DetachCurrentThread();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-用队列边解码边播放"><a href="#2-用队列边解码边播放" class="headerlink" title="2.用队列边解码边播放"></a>2.用队列边解码边播放</h1><p>为什么要用队列边解码边播放？</p><p>原因：<font color="red">首先解码成pcm是耗时的，如果播放的网络音频，网络卡顿时读取也会耗时，这个时候读取本来就耗时的情况下每次读取成功还等待解码完成后再去读取就会有点卡顿。所以咱们读取和解码分开就会提升性能</font></p><p><code>av_read_frame：从流里面解析一个一个的 packet ，流可能是本地流也可以是网络流</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 读取</span></span><br><span class="line">           <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStreamIndex) &#123;</span><br><span class="line">               </span><br><span class="line">               <span class="comment">//--------------------- 解码开始 -------------------------/</span></span><br><span class="line">               <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">               <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">               <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">                   <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                       index++;</span><br><span class="line">                       LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// 调用重采样的方法</span></span><br><span class="line">                       swr_convert(swrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                                   (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                       <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                       <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                       <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line"></span><br><span class="line">                       <span class="built_in">memcpy</span>(jPcmData, resampleOutBuffer, dataSize);</span><br><span class="line">                       <span class="comment">// 1 把 c 的数组的数据同步到 jbyteArray,然后不释放native数组</span></span><br><span class="line">                       env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, JNI_COMMIT);</span><br><span class="line"></span><br><span class="line">                       pJniCall-&gt;callAudioTrackWrite(env,jPcmByteArray, <span class="number">0</span>, dataSize);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//--------------------- 解码结束 -------------------------/</span></span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 解引用</span></span><br><span class="line">           av_packet_unref(pPacket);</span><br><span class="line">           av_frame_unref(pFrame);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">       av_packet_free(&amp;pPacket);</span><br><span class="line">       av_frame_free(&amp;pFrame);</span><br></pre></td></tr></table></figure><p>修改过后,具体请看文件<a href="https://github.com/EastUp/NDKPractice/blob/master/ffmpeg83/src/main/cpp/Audio.cpp" target="_blank" rel="noopener">Audio.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadReadPacket</span><span class="params">(<span class="keyword">void</span> *args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">Audio</span> *pAudio = (<span class="built_in">Audio</span>*)args;</span><br><span class="line">    <span class="keyword">while</span>(pAudio-&gt;pPlayerStatus != <span class="literal">NULL</span> &amp;&amp; !pAudio-&gt;pPlayerStatus-&gt;isExit)&#123;</span><br><span class="line">       AVPacket *pPacket = av_packet_alloc();</span><br><span class="line">        <span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line">        <span class="keyword">if</span> (av_read_frame(pAudio-&gt;pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pPacket-&gt;stream_index == pAudio-&gt;audioStreamIndex) &#123;</span><br><span class="line">                <span class="comment">// 读取音频压缩包数据后，将其push 到 队列中</span></span><br><span class="line">                pAudio-&gt;pPacketQueue-&gt;push(pPacket);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 解引用</span></span><br><span class="line">                av_packet_unref(pPacket);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">            av_packet_free(&amp;pPacket);</span><br><span class="line">            <span class="comment">// 睡眠一下，尽量不去消耗 cpu 的资源，也可以退出销毁这个线程</span></span><br><span class="line">            <span class="comment">// break;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码的线程 OpenSLES</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Audio::resampleAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dataSize = <span class="number">0</span>;</span><br><span class="line">    AVPacket *pPacket = <span class="literal">nullptr</span>;</span><br><span class="line">    AVFrame *pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pPlayerStatus != <span class="literal">nullptr</span> &amp;&amp; !pPlayerStatus-&gt;isExit) &#123;</span><br><span class="line">        pPacket = pPacketQueue-&gt;pop();</span><br><span class="line">        <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">        <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">        <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">            <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                <span class="comment">// 调用重采样的方法，返回值是返回重采样的个数，也就是 pFrame-&gt;nb_samples</span></span><br><span class="line">                dataSize = swr_convert(pSwrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                                       (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line">                LOGE(<span class="string">"解码音频帧：%d %d"</span>,dataSize,pFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                dataSize = pFrame-&gt;nb_samples * <span class="number">2</span> * <span class="number">2</span>; <span class="comment">// 采样率 * 通道数 * 两字节</span></span><br><span class="line">                <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解引用</span></span><br><span class="line">        av_packet_unref(pPacket);</span><br><span class="line">        av_frame_unref(pFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">    av_packet_free(&amp;pPacket);</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line">    <span class="keyword">return</span> dataSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的ffmpeg83
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：13.FFmpeg-音乐播放器2</title>
    <link href="http://eastup.github.io/84.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A82/"/>
    <id>http://eastup.github.io/84.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A82/</id>
    <published>2020-08-13T00:12:43.000Z</published>
    <updated>2020-11-12T07:22:18.022Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83" target="_blank" rel="noopener">NDKPractice项目的ffmpeg83</a></strong></p><h1 id="1-解决内存上涨的问题"><a href="#1-解决内存上涨的问题" class="headerlink" title="1.解决内存上涨的问题"></a>1.解决内存上涨的问题</h1><p>将循环中<code>新建数组操作提到循环外面去</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">jbyteArray jPcmByteArray =  env-&gt;NewByteArray(dataSize);</span><br><span class="line"><span class="comment">// native 创建 c 数组</span></span><br><span class="line">jbyte *jPcmData =  env-&gt;GetByteArrayElements(jPcmByteArray, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pPacket = av_packet_alloc();</span><br><span class="line">pFrame = av_frame_alloc();</span><br><span class="line"><span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStreamIndex) &#123;</span><br><span class="line">        <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">        <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">        <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">            <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                index++;</span><br><span class="line">                LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 调用重采样的方法</span></span><br><span class="line">                swr_convert(swrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                            (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">memcpy</span>(jPcmData, resampleOutBuffer, dataSize);</span><br><span class="line">                <span class="comment">// 1 把 c 的数组的数据同步到 jbyteArray,然后不释放native数组</span></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, JNI_COMMIT);</span><br><span class="line">                pJniCall-&gt;callAudioTrackWrite(jPcmByteArray, <span class="number">0</span>, dataSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解引用</span></span><br><span class="line">    av_packet_unref(pPacket);</span><br><span class="line">    av_frame_unref(pFrame);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">av_packet_free(&amp;pPacket);</span><br><span class="line">av_frame_free(&amp;pFrame);</span><br><span class="line"><span class="comment">// 0 把 c 的数组的数据同步到 jbyteArray,然后释放native数组</span></span><br><span class="line">env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 解除 jPcmDataArray 的持有，让 javaGC 回收</span></span><br><span class="line">env-&gt;DeleteLocalRef(jPcmByteArray);</span><br></pre></td></tr></table></figure></p><h1 id="2-解决杂音问题"><a href="#2-解决杂音问题" class="headerlink" title="2.解决杂音问题"></a>2.解决杂音问题</h1><p>分析  </p><ul><li>原因：是因为音频的的采样率和采用格式跟我们使用AudioTrack播放设置的会不一致。</li><li>解决：使用重采样</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --------------- 重采样 start --------------</span></span><br><span class="line">  <span class="comment">//输出的声道布局（立体声）</span></span><br><span class="line">  <span class="keyword">int64_t</span> out_ch_layout = AV_CH_LAYOUT_STEREO;</span><br><span class="line">  <span class="comment">//输出采样格式16bit PCM</span></span><br><span class="line">  <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AVSampleFormat::AV_SAMPLE_FMT_S16;</span><br><span class="line">  <span class="comment">//输出采样率</span></span><br><span class="line">  <span class="keyword">int</span> out_sample_rate = AUDIO_SAMPLE_RATE;</span><br><span class="line">  <span class="comment">//获取输入的声道布局</span></span><br><span class="line">  <span class="comment">//根据声道个数获取默认的声道布局（2个声道，默认立体声stereo）</span></span><br><span class="line">  <span class="keyword">int64_t</span> in_ch_layout = pCodecContext-&gt;channel_layout;</span><br><span class="line">  <span class="comment">//输入的采样格式</span></span><br><span class="line">  <span class="keyword">enum</span> AVSampleFormat in_sample_fmt = pCodecContext-&gt;sample_fmt;</span><br><span class="line">  <span class="comment">//输入采样率</span></span><br><span class="line">  <span class="keyword">int</span> in_sample_rate = pCodecContext-&gt;sample_rate;</span><br><span class="line">  swrContext = swr_alloc_set_opts(<span class="literal">NULL</span>, out_ch_layout, out_sample_fmt,</span><br><span class="line">                                              out_sample_rate, in_ch_layout, in_sample_fmt,</span><br><span class="line">                                              in_sample_rate, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (swrContext == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      LOGE(<span class="string">"swr alloc set opts error"</span>);</span><br><span class="line">      callPlayerJniError(SWR_ALLOC_SET_OPTS_ERROR_CODE, <span class="string">"swr alloc set opts error"</span>);</span><br><span class="line">      <span class="comment">// 提示错误</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> swrInitRes = swr_init(swrContext);</span><br><span class="line">  <span class="keyword">if</span> (swrInitRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      LOGE(<span class="string">"swr context swr init error"</span>);</span><br><span class="line">      callPlayerJniError(SWR_CONTEXT_INIT_ERROR_CODE, <span class="string">"swr context swr init error"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// size 是播放指定的大小，是最终输出的大小</span></span><br><span class="line">  <span class="keyword">int</span> outChannels = av_get_channel_layout_nb_channels(out_ch_layout);</span><br><span class="line">  <span class="keyword">int</span> dataSize = av_samples_get_buffer_size(<span class="literal">NULL</span>, outChannels, pCodecParameters-&gt;frame_size,</span><br><span class="line">                                            out_sample_fmt, <span class="number">0</span>);</span><br><span class="line">  resampleOutBuffer = (<span class="keyword">uint8_t</span> *) <span class="built_in">malloc</span>(dataSize);</span><br><span class="line">  <span class="comment">// --------------- 重采样 end --------------</span></span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (av_read_frame(pFormatContext, pPacket) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pPacket-&gt;stream_index == audioStreamIndex) &#123;</span><br><span class="line">          <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">          <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext, pPacket);</span><br><span class="line">          <span class="keyword">if</span> (codecSendPacketRes == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext, pFrame);</span><br><span class="line">              <span class="keyword">if</span> (codecReceiveFrameRes == <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                  index++;</span><br><span class="line">                  LOGE(<span class="string">"解码第 %d 帧"</span>, index);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">// 调用重采样的方法</span></span><br><span class="line">                  swr_convert(swrContext, &amp;resampleOutBuffer, pFrame-&gt;nb_samples,</span><br><span class="line">                              (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data, pFrame-&gt;nb_samples);</span><br><span class="line">                  </span><br><span class="line">                  ....</span><br><span class="line"></span><br><span class="line">                  <span class="built_in">memcpy</span>(jPcmData, resampleOutBuffer, dataSize);</span><br><span class="line">                  <span class="comment">// 1 把 c 的数组的数据同步到 jbyteArray,然后不释放native数组</span></span><br><span class="line">                  env-&gt;ReleaseByteArrayElements(jPcmByteArray, jPcmData, JNI_COMMIT);</span><br><span class="line">                  pJniCall-&gt;callAudioTrackWrite(jPcmByteArray, <span class="number">0</span>, dataSize);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 解引用</span></span><br><span class="line">      av_packet_unref(pPacket);</span><br><span class="line">      av_frame_unref(pFrame);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="3-添加错误回调到-Java"><a href="#3-添加错误回调到-Java" class="headerlink" title="3. 添加错误回调到 Java"></a>3. 添加错误回调到 Java</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> jPlayerErrorMid = jniEnv-&gt;GetMethodID(jPlayerClass, <span class="string">"onError"</span>, <span class="string">"(ILjava/lang/String;)V"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JNICall::callPlayerError</span><span class="params">(<span class="keyword">int</span> code, <span class="keyword">char</span> *msg)</span> </span>&#123;</span><br><span class="line">    jstring jMsg = jniEnv-&gt;NewStringUTF(msg);</span><br><span class="line">    jniEnv-&gt;CallVoidMethod(jPlayerObj, jPlayerErrorMid, code, jMsg);</span><br><span class="line">    jniEnv-&gt;DeleteLocalRef(jMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-多线程解码播放"><a href="#4-多线程解码播放" class="headerlink" title="4.多线程解码播放"></a>4.多线程解码播放</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">threadPlay</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    FFmpeg *pFFmpeg = (FFmpeg *) arg;</span><br><span class="line">    pFFmpeg-&gt;<span class="built_in">prepare</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFmpeg::play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个线程去播放，多线程边解码边播放</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,threadPlay,<span class="keyword">this</span>);</span><br><span class="line">    pthread_detach(tid); <span class="comment">// 回收线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-ffmpeg的一些常用指令"><a href="#5-ffmpeg的一些常用指令" class="headerlink" title="5.ffmpeg的一些常用指令"></a>5.ffmpeg的一些常用指令</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg 命令</span><br><span class="line">转格式</span><br><span class="line">ffmpeg -i input.mp4 -vcodec copy -acodec copy out.flv</span><br><span class="line">抽取视频</span><br><span class="line">ffmpeg -i input.mp4 -an -vcodec copy out.h264</span><br><span class="line">抽取音频</span><br><span class="line">ffmpeg -i input.mp4 -vn -acodec copy out.aac</span><br><span class="line">提取 YUV </span><br><span class="line">ffmpeg -i input.mp4 -an -c:v rawvideo -pix_fmt yuv420p out.yuv</span><br><span class="line">提取 PCM</span><br><span class="line">ffmpeg -i input.mp4 -vn -ar <span class="number">44100</span> -ac2 -f s16le out.pcm</span><br><span class="line">视频裁剪</span><br><span class="line">ffmpeg -i input.mp4 -vf corp=in_w<span class="number">-200</span>:in_h<span class="number">-200</span> -c:v libx264 -c:a copy out.mp4</span><br><span class="line">视频裁剪</span><br><span class="line">ffmpeg -i input.mp4 -ss <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> -t <span class="number">10</span> out.mp4</span><br><span class="line">视频转图片</span><br><span class="line">ffmpeg -i input.mp4 -r <span class="number">1</span> -f image2 <span class="built_in">image</span>-%<span class="number">3</span>d.jpeg</span><br><span class="line">图片转视频</span><br><span class="line">ffmpeg -i <span class="built_in">image</span>-%<span class="number">3</span>d.jpeg out.mp4</span><br><span class="line">直播推流</span><br><span class="line">ffmpeg -re -i output.mp4 -c copy -f flv rtmp:<span class="comment">//server/live/streamName</span></span><br><span class="line">直播拉流</span><br><span class="line">ffmpeg -i rtmp:<span class="comment">//server/live/streamName -c copy dump.flv</span></span><br></pre></td></tr></table></figure><p>问题：<font color="red">子线程中返回 java 错误会有问题</font></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的ffmpeg83
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：12.FFmpeg-音乐播放器1</title>
    <link href="http://eastup.github.io/83.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A81/"/>
    <id>http://eastup.github.io/83.FFmpeg-%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A81/</id>
    <published>2020-08-12T00:12:43.000Z</published>
    <updated>2020-11-12T07:21:56.327Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83" target="_blank" rel="noopener">NDKPractice项目的ffmpeg83</a></strong></p><p>先来看下流程图：</p><p><img src="/images/83.音乐播放器流程图.png" alt></p><h1 id="1-获取音频-Meta-信息"><a href="#1-获取音频-Meta-信息" class="headerlink" title="1.获取音频 Meta 信息"></a>1.获取音频 Meta 信息</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT <span class="keyword">void</span> JNICALL</span><br><span class="line">Java_com_east_ffmpeg83_media_JaminPlayer_nPlay(JNIEnv *env, jobject instance,</span><br><span class="line">                                                       jstring url_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *url = env-&gt;GetStringUTFChars(url_,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 1.初始化所有组件，只有调用了该函数，才能使用复用器和编解码器（源码）</span></span><br><span class="line">    av_register_all();</span><br><span class="line">    <span class="comment">// 2.初始化网络</span></span><br><span class="line">    avformat_network_init();</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> formatOpenInputRes = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> formatFindStreamInfoRes = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> audioStreamIndex = <span class="number">-1</span>;</span><br><span class="line">    AVStream *audio_stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.打开输入</span></span><br><span class="line">    formatOpenInputRes = avformat_open_input(&amp;pFormatContext,url,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(formatOpenInputRes !=<span class="number">0</span> )&#123;</span><br><span class="line">        <span class="comment">// 第一件事，需要回调给 Java层</span></span><br><span class="line">        <span class="comment">// 第二件 事，需要释放资源</span></span><br><span class="line">        LOGE(<span class="string">"format open input error：%s"</span>,av_err2str(formatOpenInputRes));</span><br><span class="line">        <span class="comment">// 一般不推荐这么写，但是的确很方便。</span></span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.找出输入流的信息</span></span><br><span class="line">    formatFindStreamInfoRes = avformat_find_stream_info(pFormatContext,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(formatFindStreamInfoRes &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"format find stream info error: %s"</span>,av_err2str(formatFindStreamInfoRes));</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.查找音频流的 index</span></span><br><span class="line">    audioStreamIndex = av_find_best_stream(pFormatContext,AVMediaType::AVMEDIA_TYPE_AUDIO,<span class="number">-1</span>,<span class="number">-1</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(audioStreamIndex &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"format audio stream error"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取采样率和通道</span></span><br><span class="line">    audio_stream = pFormatContext-&gt;streams[audioStreamIndex];</span><br><span class="line">    LOGE(<span class="string">"采样率：%d, 通道数: %d"</span>, audio_stream-&gt;codecpar-&gt;sample_rate, audio_stream-&gt;codecpar-&gt;channels);</span><br><span class="line"></span><br><span class="line">    __av_resources_destroy:</span><br><span class="line">    <span class="keyword">if</span>(pFormatContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        avformat_close_input(&amp;pFormatContext);</span><br><span class="line">        avformat_free_context(pFormatContext);</span><br><span class="line">        pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_network_deinit();</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(url_,url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-解码音频数据"><a href="#2-解码音频数据" class="headerlink" title="2.解码音频数据"></a>2.解码音频数据</h1><p>关于解码函数 avcodec_decode_audio4 已经过时了，取而代之的是 avcodec_send_packet 和 avcodec_receive_frame 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6.查找解码</span></span><br><span class="line">    pCodecParameters = pFormatContext-&gt;streams[audioStreamIndex]-&gt;codecpar;</span><br><span class="line">    pCodec = avcodec_find_decoder(pCodecParameters-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span>(pCodec == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"codec find audio decoder error"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7.创建一个解码器的上下文</span></span><br><span class="line">    pCodecContext = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span>(pCodecContext == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        LOGE(<span class="string">"codec alloc context error"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8.根据参数值填充Codec上下文参数</span></span><br><span class="line">    codecParametersToContextRes = avcodec_parameters_to_context(pCodecContext,pCodecParameters);</span><br><span class="line">    <span class="keyword">if</span> (codecParametersToContextRes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"codec parameters to context error: %s"</span>, av_err2str(codecParametersToContextRes));</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 9.打开解码器</span></span><br><span class="line">    codecOpenRes = avcodec_open2(pCodecContext,pCodec,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (codecOpenRes != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"codec audio open error: %s"</span>, av_err2str(codecOpenRes));</span><br><span class="line">        <span class="keyword">goto</span> __av_resources_destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pPacket = av_packet_alloc();</span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line">    <span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line">    <span class="keyword">while</span>(av_read_frame(pFormatContext,pPacket) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pPacket-&gt;stream_index == audioStreamIndex)&#123;</span><br><span class="line">            <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">            <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext,pPacket);</span><br><span class="line">            <span class="keyword">if</span>(codecSendPacketRes == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext,pFrame);</span><br><span class="line">                <span class="keyword">if</span>(codecReceiveFrameRes == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                    index++;</span><br><span class="line">                    LOGE(<span class="string">"解码第 %d 帧"</span>,index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解引用</span></span><br><span class="line">        av_packet_unref(pPacket);</span><br><span class="line">        av_frame_unref(pFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">    av_packet_free(&amp;pPacket);</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line"></span><br><span class="line">    __av_resources_destroy:</span><br><span class="line">    <span class="keyword">if</span>(pCodecContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        avcodec_close(pCodecContext);</span><br><span class="line">        avcodec_free_context(&amp;pCodecContext);</span><br><span class="line">        pCodecContext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pFormatContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        avformat_close_input(&amp;pFormatContext);</span><br><span class="line">        avformat_free_context(pFormatContext);</span><br><span class="line">        pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_network_deinit();</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseStringUTFChars(url_,url);</span><br></pre></td></tr></table></figure><h1 id="3-播放音频"><a href="#3-播放音频" class="headerlink" title="3.播放音频"></a>3.播放音频</h1><p>播放 pcm 数据目前比较流行的有两种方式，一种是通过 Android 的 AudioTrack 来播放，另一种是采用跨平台的 OpenSLES(直接用的底层操作驱动播放) 来播放，<br>个人比较倾向于用更加高效的 <a href="https://github.com/googlesamples/android-ndk/tree/master/native-audio" target="_blank" rel="noopener">OpenSLES</a> 来播放音频，大家可以先看看 Google 官方的 native-audio 事例，这里我们先采用 AudioTrack 来播放</p><p>AudioTrack 来播：  </p><ol><li>创建 AudioTack 对象 </li><li>启动循环，设置为播放状态 (play)</li><li>把数据推到指定数组中 (write)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">jobject <span class="title">createAudioTrack</span><span class="params">(JNIEnv *env)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*AudioTrack(int streamType, int sampleRateInHz, int channelConfig, int audioFormat,</span></span><br><span class="line"><span class="comment">        int bufferSizeInBytes, int mode)*/</span></span><br><span class="line">    jclass jAudioTrackClass = env-&gt;FindClass(<span class="string">"android/media/AudioTrack"</span>);</span><br><span class="line">    jmethodID  jAudioTackCMid = env-&gt;GetMethodID(jAudioTrackClass,<span class="string">"&lt;init&gt;"</span>,<span class="string">"(IIIIII)V"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> streamType = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> sampleRateInHz = AUDIO_SAMPLE_RATE;</span><br><span class="line">    <span class="keyword">int</span> channelConfig = (<span class="number">0x4</span> | <span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">int</span> audioFormat = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> mode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat)</span></span><br><span class="line">    jmethodID  getMinBufferSizeMID = env-&gt;GetStaticMethodID(jAudioTrackClass,<span class="string">"getMinBufferSize"</span>,<span class="string">"(III)I"</span>);</span><br><span class="line">    <span class="keyword">int</span> bufferSizeInBytes = env-&gt;CallStaticIntMethod(jAudioTrackClass,getMinBufferSizeMID,sampleRateInHz,</span><br><span class="line">            channelConfig,audioFormat);</span><br><span class="line">    LOGE(<span class="string">"bufferSizeInBytes = %d"</span>,bufferSizeInBytes);</span><br><span class="line"></span><br><span class="line">    jobject jAudioTrackObj = env-&gt;NewObject(jAudioTrackClass,jAudioTackCMid,streamType,sampleRateInHz,channelConfig,</span><br><span class="line">            audioFormat,bufferSizeInBytes,mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// play</span></span><br><span class="line">    jmethodID playMid = env-&gt;GetMethodID(jAudioTrackClass,<span class="string">"play"</span>,<span class="string">"()V"</span>);</span><br><span class="line">    env-&gt;CallVoidMethod(jAudioTrackObj,playMid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jAudioTrackObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 10.使用AudioTrack播放</span></span><br><span class="line">        jAudioTrackClass = env-&gt;FindClass(<span class="string">"android/media/AudioTrack"</span>);</span><br><span class="line">        <span class="comment">//  public int write(@NonNull byte[] audioData, int offsetInBytes, int sizeInBytes)</span></span><br><span class="line">        jWriteMid = env-&gt;GetMethodID(jAudioTrackClass,<span class="string">"write"</span>,<span class="string">"([BII)I"</span>);</span><br><span class="line">        jAudioTrackObj = createAudioTrack(env);</span><br><span class="line">    </span><br><span class="line">        pPacket = av_packet_alloc();</span><br><span class="line">        pFrame = av_frame_alloc();</span><br><span class="line">        <span class="comment">// 循环从上下文中读取帧到包中</span></span><br><span class="line">        <span class="keyword">while</span>(av_read_frame(pFormatContext,pPacket) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pPacket-&gt;stream_index == audioStreamIndex)&#123;</span><br><span class="line">                <span class="comment">// Packet 包，压缩的数据，解码成 pcm 数据</span></span><br><span class="line">                <span class="keyword">int</span> codecSendPacketRes = avcodec_send_packet(pCodecContext,pPacket);</span><br><span class="line">                <span class="keyword">if</span>(codecSendPacketRes == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> codecReceiveFrameRes = avcodec_receive_frame(pCodecContext,pFrame);</span><br><span class="line">                    <span class="keyword">if</span>(codecReceiveFrameRes == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">// AVPacket -&gt; AVFrame</span></span><br><span class="line">                        index++;</span><br><span class="line">                        LOGE(<span class="string">"解码第 %d 帧"</span>,index);</span><br><span class="line">    </span><br><span class="line">                        <span class="comment">// write 写到缓冲区 pFrame.data -&gt; javabyte</span></span><br><span class="line">                        <span class="comment">// size 是多大，装 pcm 的数据</span></span><br><span class="line">                        <span class="comment">// 1s 44100 点，2通道， 2字节 44100*2*2</span></span><br><span class="line">                        <span class="comment">// 1帧不是一秒，pFrame-&gt;nb_samples点</span></span><br><span class="line">                        <span class="keyword">int</span> dataSize = av_samples_get_buffer_size(<span class="literal">NULL</span>,pFrame-&gt;channels,</span><br><span class="line">                                                                  pFrame-&gt;nb_samples,pCodecContext-&gt;sample_fmt,<span class="number">0</span>);</span><br><span class="line">                        jbyteArray jPcmByteArray = env-&gt;NewByteArray(dataSize);</span><br><span class="line">                        <span class="comment">// native 创建 c 数组</span></span><br><span class="line">                        jbyte *jPcmData= env-&gt;GetByteArrayElements(jPcmByteArray,<span class="literal">NULL</span>);</span><br><span class="line">                        <span class="built_in">memcpy</span>(jPcmData,pFrame-&gt;data,dataSize);</span><br><span class="line">                        <span class="comment">// 0 把 c 的数组的数据同步到 jbyteArray,然后释放native数组</span></span><br><span class="line">                        env-&gt;ReleaseByteArrayElements(jPcmByteArray,jPcmData,<span class="number">0</span>);</span><br><span class="line">                        env-&gt;CallIntMethod(jAudioTrackObj,jWriteMid,jPcmByteArray,<span class="number">0</span>,dataSize);</span><br><span class="line">                        <span class="comment">// 解除 jPcmDataArray 的持有，让 javaGC 回收</span></span><br><span class="line">                        env-&gt;DeleteLocalRef(jPcmByteArray);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 解引用</span></span><br><span class="line">            av_packet_unref(pPacket);</span><br><span class="line">            av_frame_unref(pFrame);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 1.解引用数据 data, 2.销魂 pPacket 结构体内存， 3.pPacket = NULL;</span></span><br><span class="line">        av_packet_free(&amp;pPacket);</span><br><span class="line">        av_frame_free(&amp;pFrame);</span><br><span class="line">        env-&gt;DeleteLocalRef(jAudioTrackObj);</span><br><span class="line">    </span><br><span class="line">        __av_resources_destroy:</span><br><span class="line">        <span class="keyword">if</span>(pCodecContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            avcodec_close(pCodecContext);</span><br><span class="line">            avcodec_free_context(&amp;pCodecContext);</span><br><span class="line">            pCodecContext = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(pFormatContext != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            avformat_close_input(&amp;pFormatContext);</span><br><span class="line">            avformat_free_context(pFormatContext);</span><br><span class="line">            pFormatContext = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        avformat_network_deinit();</span><br><span class="line">    </span><br><span class="line">        env-&gt;ReleaseStringUTFChars(url_,url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这块播放还是有杂音，而且内存持续上涨，下节我们通过多线程播放来解决</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/ffmpeg83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的ffmpeg83
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：11.Shell脚本-动手编译FFmpeg</title>
    <link href="http://eastup.github.io/82.Shell%E8%84%9A%E6%9C%AC-%E5%8A%A8%E6%89%8B%E7%BC%96%E8%AF%91FFmpeg/"/>
    <id>http://eastup.github.io/82.Shell%E8%84%9A%E6%9C%AC-%E5%8A%A8%E6%89%8B%E7%BC%96%E8%AF%91FFmpeg/</id>
    <published>2020-08-11T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:54.166Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/fe54d70a260e" target="_blank" rel="noopener">避坑指南</a></p><h1 id="1-Cmake交叉编译Android动态库"><a href="#1-Cmake交叉编译Android动态库" class="headerlink" title="1.Cmake交叉编译Android动态库"></a>1.Cmake交叉编译Android动态库</h1><p>交叉编译：Linux上编译Android的so</p><p>ndk 16的以上版本自带交叉编译工具链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake -DANDROID_NDK&#x3D;$&#123;NDK_PATH&#125; \ # ndk的安装目录（空格 \回车，相当于所有命令弄到同一行）</span><br><span class="line">        -DCMAKE_TOOLCHAIN_FILE&#x3D;$&#123;NDK_PATH&#125;&#x2F;build&#x2F;cmake&#x2F;android.toolchain.cmake \ # cmake 交叉编译工具链</span><br><span class="line">        -DANDROID_ABI&#x3D;&quot;armeabi-v7a&quot; \ # 指定CPU</span><br><span class="line">        -DANDROID_NATIVE_API_LEVEL&#x3D;19 \    # 指定最低版本</span><br><span class="line">        ..</span><br></pre></td></tr></table></figure><h1 id="2-配置NDK环境"><a href="#2-配置NDK环境" class="headerlink" title="2.配置NDK环境"></a>2.配置NDK环境</h1><p>在NDKr17以后，NDK 不再支持32位和64位 MIPS 和ARM v5(armeabi)</p><p>所以现在NDK中只支持armeabi-v7a，armeabi-v8a，x86,x86_64四类</p><p>注意如果是虚拟机的linux系统 <code>需要把要拷贝的文件放到桌面，然后通过ctrl+c复制，最后在虚拟机上 ctrl+v复制</code></p><ol><li>下载<a href="https://www.jianshu.com/p/528eeb266f83" target="_blank" rel="noopener">NDK</a></li><li>将下载好的linux系统的ndk,<code>拷贝</code>到linux系统的 <code>/lib</code>目录下<code>新建的ndk目录</code>并<code>解压</code>,需要root权限</li><li>配置环境变量   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">配置环境变量:</span><br><span class="line"></span><br><span class="line">配置环境变量 vim &#x2F;etc&#x2F;profile</span><br><span class="line">文件最后面输入：</span><br><span class="line">export NDK_PATH&#x3D;&#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b</span><br><span class="line">export PATH&#x3D;$NDK_PATH:$PATH</span><br><span class="line">使环境变量生效 source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-1-NDK中交叉编译工具的变化"><a href="#2-1-NDK中交叉编译工具的变化" class="headerlink" title="2.1 NDK中交叉编译工具的变化"></a>2.1 NDK中交叉编译工具的变化</h2><p>在ndkr17c 以后默认使用的变成了<code>clang</code>，<code>而不是gcc</code></p><h3 id="2-1-1-交叉编译工具位置的变化"><a href="#2-1-1-交叉编译工具位置的变化" class="headerlink" title="2.1.1. 交叉编译工具位置的变化:"></a>2.1.1. 交叉编译工具位置的变化:</h3><p>在 NDK r19以前的 ndk 内置了一个可以自动生成交叉编译工具(toolchain) 的.py文件，放在</p><p>ndk路径下面的build/tool/make_standalone_toolchain.py</p><p>要生成toolchain，使用下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$NDK_HOME&#x2F;build&#x2F;tools&#x2F;make_standalone_toolchain.py --arch arm --api 21 --install-dir &#x2F;Users&#x2F;fczhao&#x2F;Desktop</span><br><span class="line"></span><br><span class="line">后面的几个都是必要的</span><br><span class="line"></span><br><span class="line">--arch 指定了生成的toolchain要在哪个CPU框架中使用</span><br><span class="line"></span><br><span class="line">--api 指定了生成的toolchain要在哪个Android API 中使用</span><br><span class="line"></span><br><span class="line">--install-dir 生成的toolchain的路径</span><br></pre></td></tr></table></figure><p>但是NDK r19以后的NDK已经内置了这些文件，如果运行上面的命令，会出现这样的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WARNING:__main__:make_standalone_toolchain.py is no longer necessary. The</span><br><span class="line"></span><br><span class="line">#$NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin 这个路径已经有了我们要生成的文件</span><br><span class="line">$NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin directory contains target-specific scripts that perform</span><br><span class="line">the same task. For example, instead of:</span><br><span class="line"></span><br><span class="line">    $ python $NDK&#x2F;build&#x2F;tools&#x2F;make_standalone_toolchain.py \</span><br><span class="line">        --arch arm --api 21 --install-dir toolchain</span><br><span class="line">    $ toolchain&#x2F;bin&#x2F;clang++ src.cpp</span><br><span class="line"></span><br><span class="line">Instead use:</span><br><span class="line"></span><br><span class="line">    $ $NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin&#x2F;armv7a-linux-androideabi21-clang++ src.cpp</span><br><span class="line"></span><br><span class="line">Installation directory already exists. Use --force.</span><br></pre></td></tr></table></figure><h1 id="3-手写FFmpeg编译脚本"><a href="#3-手写FFmpeg编译脚本" class="headerlink" title="3.手写FFmpeg编译脚本"></a>3.手写FFmpeg编译脚本</h1><p>关于版本问题：学习尽量使用最新的版本（api过时，api改进），开发尽量使用大众的版本（方便查询解决问题）版本<code>3.3.9</code></p><font color="red">第三方库编译的通用思想：</font><ol><li>首先先看下<code>README.md</code>文件</li><li>编译项目（动静态库）需要 Makefile 管理，如果<code>已经有写好的Makefile可以尝试着用make命令去编译</code>，如果没有需要自己写<code>Makefile</code>或者采用 <code>cmake</code> 构建</li><li>如果Makefile报错需要解决，一般情况下都是Makefile的一些配置文件没生成，所以一般需要先运行<code>configure</code>文件</li><li>生成配置文件之后，再次运行make,但是编译后的文件（elf,so,a）只能在当前类型系统上运行。如果需要跑到android或ios那么需要<code>交叉编译</code>。<code>因此我们一般都需要往configure文件里面传一些交叉编译参数</code></li></ol><ul><li><code>./configure --help &gt; help.txt</code>:将configure 的帮助说明写到<code>help.txt</code>中去</li></ul><p><code>NDKr16以上的版本NDKr19</code>以下需要我们自己去生成android版本的交叉编译链 ,NDKr19以上不需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 创建目录 &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b&#x2F;android-toolchains&#x2F;android-19&#x2F;arch-arm</span><br><span class="line">2. 进入 &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b&#x2F;build&#x2F;tools 目录下</span><br><span class="line">3. 执行命令：</span><br><span class="line">    sudo .&#x2F;make_standalone_toolchain.py --arch arm --api 19 --install-dir &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r16b&#x2F;android-toolchains&#x2F;android-19&#x2F;arch-arm</span><br><span class="line"></span><br><span class="line">如果出现 Installation directory already exists. Use --force.</span><br><span class="line"></span><br><span class="line">在上条命令最后面加上 --force就行</span><br></pre></td></tr></table></figure><p><code>ndk-r16b和ffmpeg3.3.9</code>的脚本文件请查看<a href="../makefile、cmake、shell/82.Shell脚本-动手编译FFmpeg/ffmpeg_build_r16b.sh">ffmpeg_build_r16b.sh</a>,还需要注意修改configure里生成文件名的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">按 esc 键输入 &#x2F;build setting 查找</span><br><span class="line"></span><br><span class="line"># SLIBNAME_WITH_MAJOR&#x3D;&#39;$(SLIBNAME).$(LIBMAJOR)&#39;</span><br><span class="line"># LIB_INSTALL_EXTRA_CMD&#x3D;&#39;$$(RANLIB) &quot;$(LIBDIR)&#x2F;$(LIBNAME)&quot;&#39;</span><br><span class="line"># SLIB_INSTALL_NAME&#x3D;&#39;$(SLIBNAME_WITH_VERSION)&#39;</span><br><span class="line"># SLIB_INSTALL_LINKS&#x3D;&#39;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&#39;</span><br><span class="line"># 替换成如下</span><br><span class="line">SLIBNAME_WITH_MAJOR&#x3D;&#39;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&#39;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD&#x3D;&#39;$$(RANLIB)&quot;$(LIBDIR)&#x2F;$(LIBNAME)&quot;&#39;</span><br><span class="line">SLIB_INSTALL_NAME&#x3D;&#39;$(SLIBNAME_WITH_MAJOR)&#39;</span><br><span class="line">SLIB_INSTALL_LINKS&#x3D;&#39;$(SLIBNAME)&#39;</span><br></pre></td></tr></table></figure><p><code>ndk-r16b和ffmpeg3.3.9</code>的脚本文件请查看<a href="../makefile、cmake、shell/82.Shell脚本-动手编译FFmpeg/ffmpeg_build_r21b.sh">ffmpeg_build_r21b.sh</a></p><h1 id="4-编译遇到的问题"><a href="#4-编译遇到的问题" class="headerlink" title="4.编译遇到的问题"></a>4.编译遇到的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clang is unable to create an executable file. C compiler test failed.</span><br><span class="line">C compiler test failed.</span><br><span class="line"></span><br><span class="line">If you think configure made a mistake, make sure you are using the latest</span><br><span class="line">version from Git. If the latest version fails, report the problem to the</span><br><span class="line">ffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net.</span><br><span class="line">Include the log file &quot;config.log&quot; produced by configure as this will help</span><br><span class="line">solving the problem.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当遇到这个问题的时候</span><br><span class="line"></span><br><span class="line">大部分是NDK支持平台错了</span><br><span class="line"></span><br><span class="line">sudo uname --m</span><br><span class="line"></span><br><span class="line">如果显示i686,你安装的是32位操作系统</span><br><span class="line">如果显示 x86_64，你安装的是64位操作系统</span><br><span class="line"></span><br><span class="line">下载的时候按下面</span><br><span class="line"></span><br><span class="line">android-ndk64-r10b-linux-x86.tar</span><br><span class="line">支持的是32位操作系统</span><br><span class="line">android-ndk64-r10b-linux-x86_64.tar.bz2 </span><br><span class="line">支持的是64位操作系统</span><br></pre></td></tr></table></figure><h1 id="5-如何适配so框架"><a href="#5-如何适配so框架" class="headerlink" title="5.如何适配so框架"></a>5.如何适配so框架</h1><p>目前支持有不同的 7 中 cpu 的架构，<code>ARMv5</code>,<code>ARMv7(2010年)</code>,<code>ARMv8</code>,<code>x86(2011年)</code>,<code>mips(2012年)</code>,<code>mip64</code>,<code>x86_64</code>。  </p><p>每一种架构都关联着一种<code>ABI</code>。  现在一般只需要arm架构就行</p><p>armv5,armv7（32位）,armv8（64位）：高版本会兼容低版本的，因此只需要放一个低版本的就可以了，armeabi或者armeabi-v7a(现在一般都是v7a，AS上只支持v7以上的，AS4.1提示后面上架到google play 的应用都需要支持64位的)  </p><p>armeabi：v5因为比较旧，因此早期缺少浮点计算的硬件支持，在需要大量计算是有一定的性能影响。</p><h1 id="6-编译参数传递"><a href="#6-编译参数传递" class="headerlink" title="6.编译参数传递"></a>6.编译参数传递</h1><h1 id="7-运行调试音频解码"><a href="#7-运行调试音频解码" class="headerlink" title="7.运行调试音频解码"></a>7.运行调试音频解码</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fe54d70a260e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;避坑指南&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Cmake交叉编译Android动态库&quot;&gt;&lt;a href=&quot;#1-C
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：10.Shell脚本-详解Shell脚本基础语法</title>
    <link href="http://eastup.github.io/81.Shell%E8%84%9A%E6%9C%AC-%E8%AF%A6%E8%A7%A3Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://eastup.github.io/81.Shell%E8%84%9A%E6%9C%AC-%E8%AF%A6%E8%A7%A3Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-10T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:50.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-shell-脚本创建与执行-01-sh"><a href="#1-shell-脚本创建与执行-01-sh" class="headerlink" title="1.shell 脚本创建与执行(01.sh)"></a>1.shell 脚本创建与执行(01.sh)</h1><p>一般都是<code>**.sh</code>文件</p><ul><li><code>#!</code>：需要用谁来解析执行该 shell 脚本</li><li><code>echo</code>：打印输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 需要用谁来解析执行该 shell 脚本</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># echo 打印输出</span><br><span class="line">echo &quot;Hello Shell!&quot;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"># 2.自定义变量与环境变量(02.sh)</span><br><span class="line"></span><br><span class="line">变量设计规则：</span><br><span class="line"></span><br><span class="line">1. 命名跟Java规范一样</span><br><span class="line">2. shell 中&#96;默认都是字符串类&#96;，如果需要用到其他类型，需要额外处理</span><br><span class="line">3. 变量用等号连接，千万注意&#96;不能有空格&#96;</span><br><span class="line">4. 变量的值如果有空格，需要用&#96;单引号&#96;或者&#96;双引号&#96;包括</span><br><span class="line"></span><br><span class="line">- &#96;$&#96;：取变量的值</span><br><span class="line">- &#96;echo &quot;CMAKE_PATH &#x3D; $&#123;CMAKE_PATH&#125;&quot;&#96;：输出环境变量CMAKE_PATH的值</span><br><span class="line">- soPath&#x3D;&#96;pwd&#96;：记得带上&#96;&#96;代表执行命令并返回</span><br></pre></td></tr></table></figure><h1 id="指定一个命令的执行结果返回给变量"><a href="#指定一个命令的执行结果返回给变量" class="headerlink" title="指定一个命令的执行结果返回给变量"></a>指定一个命令的执行结果返回给变量</h1><h1 id="soPath-pwd"><a href="#soPath-pwd" class="headerlink" title="soPath=$(pwd)"></a>soPath=$(pwd)</h1><p>soPath=<code>pwd</code><br>echo “soPath = ${soPath}”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>str1=”str1”  // str1<br>str2=str2    // str2<br>str3=3       // 3<br>str4=”Hello Shell” // Hello Shell</p><h1 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h1><p>str4=str4 // str4</p><h1 id="取变量的值"><a href="#取变量的值" class="headerlink" title="$取变量的值"></a>$取变量的值</h1><p>echo “str1 = $str1” // str1 = str1<br>echo “str2 = $str2” // str2 = str2<br>echo “str3 = $str3” // str3 = 3<br>echo “str4 = $str4” // str4 = str4</p><h1 id="输出环境变量"><a href="#输出环境变量" class="headerlink" title="输出环境变量"></a>输出环境变量</h1><p>echo “CMAKE_PATH = ${CMAKE_PATH}”</p><h1 id="指定一个命令的执行结果返回给变量-1"><a href="#指定一个命令的执行结果返回给变量-1" class="headerlink" title="指定一个命令的执行结果返回给变量"></a>指定一个命令的执行结果返回给变量</h1><h1 id="soPath-pwd-1"><a href="#soPath-pwd-1" class="headerlink" title="soPath=$(pwd)"></a>soPath=$(pwd)</h1><p>soPath=<code>pwd</code>  // soPath = 当前路径<br>echo “soPath = ${soPath}”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 3.位置参数变量与预定义变量</span><br><span class="line"></span><br><span class="line">## 3.1.获取位置参数（03.sh）</span><br><span class="line"></span><br><span class="line">- &#96;$n&#96; 来获取参数,$0 代表程序本身，&#96;$1-$9&#96;代表第一个参数到第九个参数，十以上的参数要用大括号 &#96;$&#123;10&#125;&#96;</span><br><span class="line">- &#96;$*&#96; 代表的是命令中的所有参数，&#96;加上引号才会把参数看成一个整体&#96; &quot;$0,$1,$2,$3,$4...$n&quot;，否则区别对待</span><br><span class="line">- &#96;$@&#96; 代表命令中的所有参数，但是会把参数区分对待 &quot;$0&quot;,&quot;$1&quot;,&quot;$2&quot;...&quot;$n&quot;</span><br><span class="line">- &#96;$#&#96; 代表参数中的个数</span><br></pre></td></tr></table></figure><br>echo “$0=$0”<br>echo “\$1=$1”<br>echo “\$2=”$2</p><p>echo “\$<em>=”$</em><br>echo “\$@=”$@<br>echo “\$#=”$#</p><h1 id="每次逻动（删除）第一个参数"><a href="#每次逻动（删除）第一个参数" class="headerlink" title="每次逻动（删除）第一个参数"></a>每次逻动（删除）第一个参数</h1><p>shift</p><p>echo “\$1=$1”<br>echo “\$@=”$@</p><p>echo “========================================”<br>for i in $*<br>do<br>echo $i<br>done</p><p>echo “========================================”<br>for i in $@<br>do<br>echo $i<br>done</p><p>echo “========================================”<br>for i in “$@”<br>do<br>echo $i<br>done</p><p>echo “========================================”<br>for i in “$*”  // 加上引号才会看成一个整体<br>do<br>echo $i<br>done<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.2.预定义变量</span><br><span class="line"></span><br><span class="line">定义：是 bash 中已经定义好的，我们可以直接拿过来用，变量的作用都是固定</span><br><span class="line"></span><br><span class="line">- &#96;$?&#96;:返回的是上一个执行命令的返回值，执行成功返回 0 ，执行失败返回非0</span><br><span class="line">- &#96;$$&#96;:获取当前脚本的进程号</span><br><span class="line">- &#96;$!&#96;:获取最后一个后台执行的进程号</span><br><span class="line"></span><br><span class="line">## 3.3.获取输入的变量(04.sh)</span><br><span class="line"></span><br><span class="line">- &#96;read -p &quot;提示&quot; name&#96;：name 代表接受的变量名</span><br><span class="line">- &#96;read -sp &quot;提示&quot; pwd&#96;：&#96;-sp 看不到输入的密码&#96;，pwd 代表接受的变量名</span><br><span class="line">- &#96;read -t 5 -n 1 -p &quot;please input [y|n]&quot; input&#96;：-t 5代表5秒没响应就退出，-n 1 代表只能输入1个字符</span><br></pre></td></tr></table></figure></p><h1 id="获取用户及时输入的参数"><a href="#获取用户及时输入的参数" class="headerlink" title="获取用户及时输入的参数"></a>获取用户及时输入的参数</h1><h1 id="read-p-“please-input-your-name-”-name"><a href="#read-p-“please-input-your-name-”-name" class="headerlink" title="read -p “please input your name!” name"></a>read -p “please input your name!” name</h1><h1 id="echo-“name-name”"><a href="#echo-“name-name”" class="headerlink" title="echo “name = $name”"></a>echo “name = $name”</h1><h1 id="输入年龄"><a href="#输入年龄" class="headerlink" title="输入年龄"></a>输入年龄</h1><h1 id="read-sp-“please-input-your-password”-pwd"><a href="#read-sp-“please-input-your-password”-pwd" class="headerlink" title="read -sp “please input your password” pwd"></a>read -sp “please input your password” pwd</h1><h1 id="echo-“password-pwd”"><a href="#echo-“password-pwd”" class="headerlink" title="echo “password=$pwd”"></a>echo “password=$pwd”</h1><p>read -t 5 -n 1 -p “please input [y|n]” input<br>echo “input = $input”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 4.条件判断(测试指令)（05.sh）</span><br><span class="line">条件判断 &#96;test 表达式&#96; 或者 &#96;[]&#96;</span><br><span class="line"></span><br><span class="line">数字计算:</span><br><span class="line">- &#96;num3&#x3D;$(($num1+$num2))&#96;</span><br><span class="line">- num3&#x3D;&#96;expr $num1 + $num2&#96; &#x2F;&#x2F; 执行 expr命令，一定要有空格 传的三个参数</span><br><span class="line">- &#96;test $str1 &#x3D;&#x3D; $str2&#96; &#x2F;&#x2F; &#96;&#x3D;&#x3D;之间一定更要空格&#96;</span><br><span class="line"></span><br><span class="line">字符串空判断：</span><br><span class="line"></span><br><span class="line">- &#96;[ str ]&#96;: 测试字符串是否不为空，&lt;font color&#x3D;red&gt;[]中间必须带空格&lt;&#x2F;font&gt;</span><br><span class="line">- &#96;test -n str&#96;: 测试字符串是否不为空</span><br><span class="line">- &#96;test -z str&#96;: 测试字符串是否为空</span><br><span class="line">- &#96;[ str1 &#x3D; str2 ]&#96;: 是否相等，&lt;font color&#x3D;red&gt;[]中间必须带空格&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">数字：</span><br><span class="line"></span><br><span class="line">- &#96;[ num1 -eq num2 ]&#96;： 测试是否相等</span><br><span class="line">- &#96;[ num1 -ne num2 ]&#96;： 不等</span><br><span class="line">- &#96;[ num1 -ge num2 ]&#96;： &gt;&#x3D;</span><br><span class="line">- &#96;[ num1 -gt num2 ]&#96;： &gt;</span><br><span class="line">- &#96;[ num1 -le num2 ]&#96;： &lt;&#x3D;</span><br><span class="line">- &#96;[ num1 -lt num2 ]&#96;： &lt;</span><br><span class="line"></span><br><span class="line">文件：</span><br><span class="line"></span><br><span class="line">- &#96;test -d file&#96;：是否是目录</span><br><span class="line">- &#96;test -f file&#96;：是否是普通文件</span><br><span class="line">- &#96;test -e file&#96;：文件是否存在</span><br><span class="line">- &#96;test -L file&#96;：是否是链接</span><br><span class="line">- &#96;test -r file&#96;：是否可读</span><br><span class="line">- &#96;test -w file&#96;：是否可写</span><br><span class="line">- &#96;test -x file&#96;：是否可执行</span><br><span class="line"></span><br><span class="line"># 5.流程语句 if （06.sh）</span><br><span class="line"></span><br><span class="line">有两种方式:</span><br></pre></td></tr></table></figure><br>if [ 表达式 ]; then</p><p>if [ 表达式 ]<br>then<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="判断有没有输入"><a href="#判断有没有输入" class="headerlink" title="判断有没有输入"></a>判断有没有输入</h1><p>if [ -z $1 ]<br>then</p><pre><code># echo &quot;usage：./build_ogre.sh [build_type]&quot;    # echo &quot;build_type: Release or Debug (must have)&quot;# exiterror</code></pre><p>fi</p><h1 id="需要用户去指定编译-Debug-还是-Release"><a href="#需要用户去指定编译-Debug-还是-Release" class="headerlink" title="需要用户去指定编译 Debug 还是 Release"></a>需要用户去指定编译 Debug 还是 Release</h1><p>CMAKE_BUILD_TYPE=””<br>if [ “Debug” = $1 ]; then<br>    CMAKE_BUILD_TYPE=”Debug”<br>elif [ “Release” = $1 ]; then<br>    CMAKE_BUILD_TYPE=”Release”<br>else<br>    error arm<br>fi<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 6.自定义函数(06.sh)</span><br><span class="line"></span><br><span class="line">- 函数需要先定义再使用,&#96;function和()必须有其一&#96;</span><br><span class="line">- 可以直接采用方法名调用,不用加()</span><br><span class="line">- $1 参数不是代表的脚本参数，而是方法传递过来的参数</span><br></pre></td></tr></table></figure><br>// function和()可以只有一个<br>function error(){<br>    echo “usage：./build_ogre.sh [build_type]”<br>        echo “build_type: Release or Debug (must have)”</p><pre><code># 函数需要穿参数 arm $1 参数不是代表的脚本参数，而是方法传递过来的参数 echo &quot;\$1 = $1&quot;    exit</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 7.流程语句 for、while、case （06.sh）</span><br><span class="line"></span><br><span class="line">for:</span><br></pre></td></tr></table></figure><br>for((i=0;i<10;i++)) do echo $i done <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while:</span><br></pre></td></tr></table><br>sum=0<br>i=1<br>while(($i&lt;=100))<br>do<br>    sum=$(($sum+$i))<br>    i=$(($i+1))<br>done<br>echo “sum = $sum”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">case:</span><br></pre></td></tr></table></figure><br>case $2 in<br>start)<br>    echo “start service”<br>    ;;<br>stop)<br>    echo “stop service”<br>    ;;<br>*)<br>    echo “invalid command”<br>    echo “Usage:{start|stop}”<br>esac<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 8.输出重定向(07.sh)</span><br><span class="line"></span><br><span class="line">&#96;0:&#96; 标准输入,&#96;1&#96;：标准输出 &#96;2&#96;：标准错误输出</span><br><span class="line"></span><br><span class="line">- &#96;echo &quot;Hello Shell!&quot; &gt; log.txt&#96; &#x2F;&#x2F; 输出日志到 log.txt 中，&#96;&gt;&#96; 代表重新生成</span><br><span class="line">- &#96;echo &quot;Hello Shell!&quot; &gt;&gt; log.txt&#96; &#x2F;&#x2F; 输出日志到 log.txt 中，&#96;&gt;&gt;&#96; 代表追加</span><br><span class="line">- &#96;exec 1&gt;log.txt&#96;：标准的所有输出，&#96;重新生成&#96;全部添加到log.txt中</span><br><span class="line">- &#96;exec 2&gt;&gt;log.txt&#96;：标准的错误输出，全部&#96;追加&#96;到log.txt中</span><br></pre></td></tr></table></figure></10;i++))></p><h1 id="永久重定向-echo-标准输入：0-标准输出：1-标准错误：2"><a href="#永久重定向-echo-标准输入：0-标准输出：1-标准错误：2" class="headerlink" title="永久重定向  echo 标准输入：0 标准输出：1 标准错误：2"></a>永久重定向  echo 标准输入：0 标准输出：1 标准错误：2</h1><p>exec 1&gt;log.txt<br>exec 2&gt;&gt;log.txt</p><h1 id="gt-gt-代表追加，-gt-代表重新生成"><a href="#gt-gt-代表追加，-gt-代表重新生成" class="headerlink" title="&gt;&gt; 代表追加，&gt; 代表重新生成"></a>&gt;&gt; 代表追加，&gt; 代表重新生成</h1><h1 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h1><h1 id="echo-“Hello-Shell-”-gt-log-txt"><a href="#echo-“Hello-Shell-”-gt-log-txt" class="headerlink" title="echo “Hello Shell!” &gt; log.txt"></a>echo “Hello Shell!” &gt; log.txt</h1><h1 id="echo-“Hello-Shell-”-gt-gt-log-txt"><a href="#echo-“Hello-Shell-”-gt-gt-log-txt" class="headerlink" title="echo “Hello Shell!” &gt;&gt; log.txt"></a>echo “Hello Shell!” &gt;&gt; log.txt</h1><p>echo “Hello Shell”<br>echo “Hello Shell”<br>echo “Hello Shell”<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-shell-脚本创建与执行-01-sh&quot;&gt;&lt;a href=&quot;#1-shell-脚本创建与执行-01-sh&quot; class=&quot;headerlink&quot; title=&quot;1.shell 脚本创建与执行(01.sh)&quot;&gt;&lt;/a&gt;1.shell 脚本创建与执行(01.sh)
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：09.Cmake语法-详解CmakeLists.txt</title>
    <link href="http://eastup.github.io/80.Cmake%E8%AF%AD%E6%B3%95-%E8%AF%A6%E8%A7%A3CmakeLists.txt/"/>
    <id>http://eastup.github.io/80.Cmake%E8%AF%AD%E6%B3%95-%E8%AF%A6%E8%A7%A3CmakeLists.txt/</id>
    <published>2020-08-09T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:48.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-初试-CMake-的-HelloWorld"><a href="#1-初试-CMake-的-HelloWorld" class="headerlink" title="1.初试 CMake 的 HelloWorld"></a>1.初试 CMake 的 HelloWorld</h1><p>注意：<code>PROJECT、这些不区分大小写</code>，但是<code>${HELLO_BINARY_DIR}这些，必须大写</code></p><ul><li><code>PROJECT(HELLO)</code>：给工程取一个名字</li><li><code>SET(SRC_LIST hello.cpp)</code>：定义一个变量</li><li><code>MESSAGE(STATUS &quot;this is BINARY dir &quot;${HELLO_BINARY_DIR})</code>：打印</li><li><code>ADD_EXECUTABLE(hello.out ${SRC_LIST})</code>：生成可执行文件</li></ul><ol><li><p>新建<code>CMakeLists.txt</code>文件，编写以下内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 给工程取一个名字</span><br><span class="line">PROJECT(HELLO)</span><br><span class="line"></span><br><span class="line"># 定义一个变量</span><br><span class="line">SET(SRC_LIST hello.cpp)</span><br><span class="line"></span><br><span class="line"># 打印</span><br><span class="line">MESSAGE(STATUS &quot;this is BINARY dir &quot;$&#123;HELLO_BINARY_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1&#x2F;build</span><br><span class="line">MESSAGE(STATUS &quot;this is SOURCE dir &quot;$&#123;HELLO_SOURCE_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1</span><br><span class="line">MESSAGE(STATUS &quot;this is PROJECT_SOURCE dir &quot;$&#123;PROJECT_SOURCE_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">ADD_EXECUTABLE(hello.out $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在同目录下创建 build 文件夹,进入执行 <code>cmake ..</code> ..代表CMakeLists.txt在上一级目录</p></li><li>最后在build目录中，执行 <code>make</code></li></ol><h1 id="2-构建生成-so-动态库"><a href="#2-构建生成-so-动态库" class="headerlink" title="2.构建生成 .so 动态库"></a>2.构建生成 .so 动态库</h1><p>目的：把src里的源文件，生成<code>libmath.so</code>动态库，动态库的存储路径在lib目录下</p><ul><li><code>CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</code>:指定 CMake 的最低编译版本</li><li><code>AUX_SOURCE_DIRECTORY(${PROJECT_SOURCE_DIR}/src SRC_LIST)</code>：搜集 src 目录下的所有源文件，并赋值为SRC_LIST</li><li><code>FILE(GLOB SRC_LIST &quot;${PROJECT_SOURCE_DIR}/src/*&quot;)</code>：搜集 src 目录下的所有源文件，并赋值为SRC_LIST</li><li><code>INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/include)</code>：指定头文件在哪个目录</li><li><code>SET (LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)</code>：指定 so 的生成目录 lib</li><li><code>ADD_LIBRARY (math SHARED ${SRC_LIST_CPP} ${SRC_LIST_C})</code>：指定生成动态库 .so， <code>math</code> 生成的so名字为 <code>libmath.so</code> 如果默认生成的是静态库.a，加入SHARED才会生成动态库.so</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 指定 CMake 的最低编译版本</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</span><br><span class="line"></span><br><span class="line"># 给工程取名字</span><br><span class="line">PROJECT(MATH)</span><br><span class="line"></span><br><span class="line"># 搜集 src 目录下的所有源文件，有AUX_SOURCE_DIRECTORY和FILE 两种方式</span><br><span class="line"># AUX_SOURCE_DIRECTORY($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src SRC_LIST)</span><br><span class="line"># FILE(GLOB SRC_LIST &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.cpp&quot; &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.c&quot;)</span><br><span class="line">FILE(GLOB SRC_LIST_CPP &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.cpp&quot;)</span><br><span class="line">FILE(GLOB SRC_LIST_C &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.c&quot;)</span><br><span class="line"></span><br><span class="line"># MESSAGE (STATUS &quot;src_list : &quot;$&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 指定头文件在哪个目录</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)</span><br><span class="line"></span><br><span class="line"># 指定 so 的生成目录 lib</span><br><span class="line">SET (LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)</span><br><span class="line"></span><br><span class="line"># 指定生成动态库 .so math -&gt; libmath.so 如果默认生成的是静态库.a，加入SHARED才会生成动态库.so</span><br><span class="line">ADD_LIBRARY (math SHARED $&#123;SRC_LIST_CPP&#125; $&#123;SRC_LIST_C&#125;)</span><br></pre></td></tr></table></figure><h1 id="3-链接外部动态库与头文件"><a href="#3-链接外部动态库与头文件" class="headerlink" title="3.链接外部动态库与头文件"></a>3.链接外部动态库与头文件</h1><ul><li><code>LINK_DIRECTORIES (${PROJECT_SOURCE_DIR}/lib)</code>：<font color="red">官方不推荐使用，有时候会找不到引用。经过尝试，so库放在jniLibs下的时候可以编译成功</font>链接 lib 目录下的 libmath.so,指定 so 在哪个目录下，</li><li><code>TARGET_LINK_LIBRARIES (hello math)</code>：为 hello 添加编译链接库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 指定 CMake 的最低编译版本</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line">PROJECT (HELLO)</span><br><span class="line"></span><br><span class="line"># 指定头文件在哪个目录</span><br><span class="line">INCLUDE_DIRECTORIES ($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)</span><br><span class="line"></span><br><span class="line"># 编译是需要链接 lib 目录下的 libmath.so</span><br><span class="line"># 指定 so 在哪个目录下，so库放在jniLibs下的时候才可以编译成功</span><br><span class="line">LINK_DIRECTORIES ($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">ADD_EXECUTABLE (hello hello.cpp)</span><br><span class="line"></span><br><span class="line"># 为 hello 添加编译链接库</span><br><span class="line">TARGET_LINK_LIBRARIES (hello math)</span><br></pre></td></tr></table></figure><h1 id="4-根据不同的源文件夹生成不同的-so-文件"><a href="#4-根据不同的源文件夹生成不同的-so-文件" class="headerlink" title="4. 根据不同的源文件夹生成不同的 .so 文件"></a>4. 根据不同的源文件夹生成不同的 .so 文件</h1><p>1.则需要在顶层目录下创建CMakeLists.txt，内容如下</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure></code></pre><ol><li>然后在 src 中再创建一个CMakeLists.txt，内容就是上边生成.so文件的内容  </li><li>在顶层目录下创建 build 文件夹，执行<code>cmake ..</code> ,<code>make</code> 的指令  </li><li>如果不指定生成的so位置，最后生成的.so文件默认在<code>build/‘源文件的目录’</code>中   </li></ol><h1 id="5-修改以前-ffmpeg-开发项目中的-CMakeLists-txt"><a href="#5-修改以前-ffmpeg-开发项目中的-CMakeLists-txt" class="headerlink" title="5.修改以前 ffmpeg 开发项目中的 CMakeLists.txt"></a>5.修改以前 ffmpeg 开发项目中的 CMakeLists.txt</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 指定最低版本名称</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"># 指定引入头文件目录</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;include)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;other)</span><br><span class="line"></span><br><span class="line"># 指定共享库的库目录，so库放在jniLibs下的时候才可以编译成功</span><br><span class="line">LINK_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;armeabi)</span><br><span class="line"></span><br><span class="line"># 指定源文件的目录</span><br><span class="line">AUX_SOURCE_DIRECTORY($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;cpp SRC_LIST)</span><br><span class="line"></span><br><span class="line"># 生成 native-lib</span><br><span class="line">ADD_LIBRARY(native-lib SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 为 native-lib 添加 ffmpeg 编译链接库</span><br><span class="line">TARGET_LINK_LIBRARIES(native-lib  </span><br><span class="line">avcodec-56 </span><br><span class="line">avdevice-56 </span><br><span class="line">avfilter-5 </span><br><span class="line">avformat-56 </span><br><span class="line">avutil-54 </span><br><span class="line">postproc-53 </span><br><span class="line">swresample-1 </span><br><span class="line">swscale-3 </span><br><span class="line">-landroid </span><br><span class="line">-llog)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-初试-CMake-的-HelloWorld&quot;&gt;&lt;a href=&quot;#1-初试-CMake-的-HelloWorld&quot; class=&quot;headerlink&quot; title=&quot;1.初试 CMake 的 HelloWorld&quot;&gt;&lt;/a&gt;1.初试 CMake 的 Hell
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：08.Cmake语法-makefile、cmake、shell 自动编译和链接</title>
    <link href="http://eastup.github.io/79.Cmake%E8%AF%AD%E6%B3%95-makefile%E3%80%81cmake%E3%80%81shell%20%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    <id>http://eastup.github.io/79.Cmake%E8%AF%AD%E6%B3%95-makefile%E3%80%81cmake%E3%80%81shell%20%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</id>
    <published>2020-08-08T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:42.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-makefile、cmake-与-shell-之间的联系"><a href="#1-makefile、cmake-与-shell-之间的联系" class="headerlink" title="1.makefile、cmake 与 shell 之间的联系"></a>1.makefile、cmake 与 shell 之间的联系</h1><ul><li><p>makefile ： 帮助我们管理编译项目   </p></li><li><p>cmake：是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的 Makefile 或者 project 文件，CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Makefile 或 projects）。</p></li><li><p>shell 脚本：一系列命令和语法</p></li></ul><h1 id="2-makefile-自动编译和链接"><a href="#2-makefile-自动编译和链接" class="headerlink" title="2.makefile 自动编译和链接"></a>2.makefile 自动编译和链接</h1><h2 id="2-1-gcc-如何编译相互依赖，却没直接引入的文件"><a href="#2-1-gcc-如何编译相互依赖，却没直接引入的文件" class="headerlink" title="2.1 gcc 如何编译相互依赖，却没直接引入的文件"></a>2.1 gcc 如何编译相互依赖，却没直接引入的文件</h2><p>Android.mk  Application.mk </p><p><code>gcc hello.cpp div.cpp sub.cpp add.cpp -o hello</code>// hello.cpp 中并没引入 div.cpp等文件，但是这样编译会自动找寻到依赖的文件</p><p>gcc 四步骤：生成 .o 文件比较耗时（<code>汇编阶段</code>）</p><p>上面的编译步骤其实就是省略了编译四步骤，假设现在我改了一个文件，需要重新编译，那么每次都会重新生成 .o 文件，因此需要把上面的步骤进行拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c sub.cpp -o sub.o</span><br><span class="line">gcc -c add.cpp -o add.o</span><br><span class="line">gcc -c div.cpp -o div.o</span><br><span class="line">gcc -c hello.cpp -o hello.o</span><br><span class="line">gcc add.o sub.o div.o hello.o -o hello</span><br></pre></td></tr></table></figure><p>这样如何只修改了 sub.cpp ，就只需要重新生成 sub.o 文件，然后重新生成最终的可执行文件</p><h2 id="2-2-如何编写Makefile文件"><a href="#2-2-如何编写Makefile文件" class="headerlink" title="2.2 如何编写Makefile文件"></a><font color="red">2.2 如何编写Makefile文件</font></h2><p>执行 Makefile 文件，只需要在Makefile 的目录下 执行<code>make</code>指令就行</p><h3 id="2-2-1-一个规则（观看makefile、cmake、shell目录下的m1）"><a href="#2-2-1-一个规则（观看makefile、cmake、shell目录下的m1）" class="headerlink" title="2.2.1. 一个规则（观看makefile、cmake、shell目录下的m1）"></a>2.2.1. 一个规则（观看makefile、cmake、shell目录下的m1）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目标：依赖条件</span><br><span class="line">（一个tab缩进） 命令</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">hello.out:hello.o sub.o add.o div.o</span><br><span class="line">gcc hello.o sub.o add.o div.o -o hello.out</span><br><span class="line">div.o:div.cpp</span><br><span class="line">gcc -c div.cpp -o div.o</span><br></pre></td></tr></table></figure><p><code>默认情况下只会执行 MakeFile 中的第一个命令。</code></p><ol><li><p>但若想生成目标文件，则会检查命令中的依赖是否存在，如果不存在就会往下查找是否有生成该依赖条件的命令，如有就会执行生成依赖再生成目标文件。</p></li><li><p>会检测规则中的目标是否需要更新，必须先检测它的依赖性（通过更新时间判断），只需要重新生成依赖中被修改的依赖，然后再更新目标文件</p></li></ol><h3 id="2-2-2-两个函数（观看makefile、cmake、shell目录下的m2）"><a href="#2-2-2-两个函数（观看makefile、cmake、shell目录下的m2）" class="headerlink" title="2.2.2. 两个函数（观看makefile、cmake、shell目录下的m2）"></a>2.2.2. 两个函数（观看makefile、cmake、shell目录下的m2）</h3><ol><li><code>src = $(wildcard *.cpp)</code>　// 找到当前目录下所有后缀为.cpp的文件，然后赋值给src <code>$(src) 取变量src的值</code></li><li><code>obj = $(patsubst %cpp,%o,$(src))</code>　//把src变量中所有后缀为.cpp的文件替换成.o文件 <code>$(obj) 取变量obj的值</code></li></ol><p>make clean -n 注意加上 -n 预执行</p><p>make clean 执行 clean 命令</p><p>如果目录下有 clean 文件夹，则会有冲突，这时只需要生成伪目标就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">src &#x3D; $(wildcard *.cpp)</span><br><span class="line">obj &#x3D; $(patsubst %cpp,%o,$(src))</span><br><span class="line"></span><br><span class="line"># 默认情况下只会执行第一个</span><br><span class="line">hello.out:$(obj)</span><br><span class="line">gcc $(obj) -o hello.out</span><br><span class="line"></span><br><span class="line">div.o:div.cpp</span><br><span class="line">gcc -c div.cpp -o div.o</span><br><span class="line"></span><br><span class="line">add.o:add.cpp</span><br><span class="line">gcc -c add.cpp -o add.o</span><br><span class="line"></span><br><span class="line">sub.o:sub.cpp</span><br><span class="line">gcc -c sub.cpp -o sub.o</span><br><span class="line"></span><br><span class="line">hello.o:hello.cpp</span><br><span class="line">gcc -c hello.cpp -o hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># $(xxx) 取变量的值</span><br><span class="line">clean:</span><br><span class="line">rm -rf $(obj) hello.out</span><br><span class="line"></span><br><span class="line"># 生成伪目标</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure><h3 id="2-2-3-三个自动变量（观看makefile、cmake、shell目录下的m3）"><a href="#2-2-3-三个自动变量（观看makefile、cmake、shell目录下的m3）" class="headerlink" title="2.2.3. 三个自动变量（观看makefile、cmake、shell目录下的m3）"></a>2.2.3. 三个自动变量（观看makefile、cmake、shell目录下的m3）</h3><p>多行注释 <code>:&#39;</code></p><ul><li>$@：表示规则中的目标</li><li>$^：表示规则中所有的依赖条件,组成一个列表，以空格隔开，如果这个列表有重复项则消除重复项</li><li>$&lt;：表示规则中的第一个依赖条件，如果运行在模式套用中，相当于取出依赖条件套用在该模式中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">src &#x3D; $(wildcard *.cpp)</span><br><span class="line">obj &#x3D; $(patsubst %cpp,%o,$(src))</span><br><span class="line"></span><br><span class="line"># 默认情况下只会执行第一个</span><br><span class="line">hello.out:$(obj)</span><br><span class="line">gcc $^ -o $@ </span><br><span class="line"></span><br><span class="line">:&#39;</span><br><span class="line">div.o:div.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">add.o:add.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">sub.o:sub.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">hello.o:hello.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line">:&#39;</span><br><span class="line"># 模式规则</span><br><span class="line"># gcc -c $(src) -o $(obj)</span><br><span class="line">%o:%cpp</span><br><span class="line">gcc -c $&lt; -o $@ </span><br><span class="line"></span><br><span class="line"># $(xxx) 取变量的值</span><br><span class="line">clean:</span><br><span class="line">rm -rf $(obj) hello.out</span><br><span class="line"></span><br><span class="line"># 生成伪目标</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure><h1 id="3-cmake简介和安装"><a href="#3-cmake简介和安装" class="headerlink" title="3.cmake简介和安装"></a>3.<a href="https://www.jianshu.com/p/528eeb266f83" target="_blank" rel="noopener">cmake简介和安装</a></h1><p>写 CMakeLists.txt 里面用 CMake 语法写，会帮我们生成 Makefile 用于编译管理项目</p><p><a href="https://blog.csdn.net/qq_27525611/article/details/104651517" target="_blank" rel="noopener">安装：</a></p><ol><li>去<a href="https://cmake.org/download/" target="_blank" rel="noopener">官网</a> 下载cmake的最新linux版本，这里下载的是<code>cmake-3.18.3.tar.gz</code></li><li><code>拷贝</code>到linux系统的 <code>/lib</code>目录下<code>新建的cmake目录</code>并<code>解压</code>,需要root权限</li><li>cd到解压后的cmake目录中运行<code>sudo ./bootstrap</code>命令进行安装</li><li>安装完成执行<code>sudo make</code></li><li>最后执行<code>sudo make install</code></li><li>可以在任一位置 使用<code>cmake --version</code> 查看安装的版本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果不能在任一位置 使用&#96;cmake --version&#96; 查看安装的版本,则配置环境变量</span><br><span class="line"></span><br><span class="line">配置环境变量 vim &#x2F;etc&#x2F;profile</span><br><span class="line">文件最后面输入：</span><br><span class="line">export CMAKE_PATH&#x3D;&#x2F;lib&#x2F;cmake&#x2F;cmake-3.18.3&#x2F;bin</span><br><span class="line">export PATH&#x3D;$CMAKE_PATH:$PATH</span><br><span class="line">使环境变量生效 source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>安装问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有的会出现没安装 make的情况,使用以下命令</span><br><span class="line">sudo apt-get install make</span><br><span class="line"></span><br><span class="line">Could not find OpenSSL.  Install an OpenSSL development package or</span><br><span class="line">  configure CMake with -DCMAKE_USE_OPENSSL&#x3D;OFF to build without OpenSSL.</span><br><span class="line"></span><br><span class="line">解决：sudo apt-get install libssl-dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error when bootstrapping CMake:</span><br><span class="line">Cannot find a C++ compiler that supports both C++11 and the specified C++ flags.</span><br><span class="line"></span><br><span class="line">1.没有装gcc 和 g++。使用 sudo apt-get install g++ 安装</span><br><span class="line"></span><br><span class="line">2. gcc 或者 g++ 版本过低，需要安装高版本的。升级风险较大，可以采用新的编译环境安装新版本的 gcc和g++ 。</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jiangjiang_jian/article/details/80694799" target="_blank" rel="noopener">gcc升级</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r&#x2F;test</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-7 g++-7</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/uestc-mm/p/7511063.html" target="_blank" rel="noopener">升级后切换 gcc 和 g++ 版本</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">你在安装完之后可以采用下面的指令来查看当前系统中安装的所有的gcc和g++的版本：</span><br><span class="line">ls &#x2F;usr&#x2F;bin&#x2F;gcc*</span><br><span class="line">ls &#x2F;usr&#x2F;bin&#x2F;g++*</span><br><span class="line"></span><br><span class="line">将gcc-6加入gcc候选中，最后的数字是优先级，我自己是直接设为100（测试没有问题）</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-6 100</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-6 100</span><br><span class="line"></span><br><span class="line">完成上面的操作之后，我们就可以通过下面的指令来选择不同的gcc和g++的版本了</span><br><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br><span class="line"></span><br><span class="line">注意一个问题：</span><br><span class="line">  当切换使用了其他版本的gcc时，请务必保持g++的版本和gcc版本的一致性，否则用cmake配置出来的项目遇到c++代码还是会用之前版本的gcc。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-makefile、cmake-与-shell-之间的联系&quot;&gt;&lt;a href=&quot;#1-makefile、cmake-与-shell-之间的联系&quot; class=&quot;headerlink&quot; title=&quot;1.makefile、cmake 与 shell 之间的联系&quot;&gt;
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：07.linux系统-线程和多线程同步</title>
    <link href="http://eastup.github.io/78.linux%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://eastup.github.io/78.linux%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2020-08-07T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:40.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线程的本质"><a href="#1-线程的本质" class="headerlink" title="1.线程的本质"></a>1.线程的本质</h1><p>线程与进程的区别：线程大家可以简单理解为一个轻量级的进程，线程共享了栈和堆（变量），没有复制 0-3 G 的进程空间，<br>但线程会有自己的工作空间，会有自己的 pcb 块。跟 Java 是类似的。</p><ol><li>linux线程执行和windows不同，pthread有两种状态<code>joinable</code>状态和<code>unjoinable</code>状态，<br>如果线程是<code>joinable</code>状态，当<code>线程函数自己返回退出时或pthread_exit</code>时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了<code>pthread_join</code>之后这些资源才会被释放。<br>若是<code>unjoinable</code>状态的线程，这些资源在<code>线程函数退出时或pthread_exit时</code>自动会被释放。</li><li><code>unjoinable</code>属性可以在<code>pthread_create时指定</code>，或在线程创建后在线程中pthread_detach自己, 如：<code>pthread_detach(pthread_self())，将状态改为unjoinable状态</code>，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join.</li><li>其实简单的说就是在线程函数头加上 pthread_detach(pthread_self())的话，线程状态改变，在函数尾部直接 pthread_exit线程就会自动退出。省去了给线程擦屁股的麻烦。</li></ol><h1 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2.创建线程"></a>2.创建线程</h1><p><code>pthread_create(&amp;tid,NULL,thread_run,NULL);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am a thread\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="3-退出线程"><a href="#3-退出线程" class="headerlink" title="3.退出线程"></a>3.退出线程</h1><p><code>pthread_exit(-1);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="4-回收线程"><a href="#4-回收线程" class="headerlink" title="4.回收线程"></a>4.回收线程</h1><p><code>pthread_join(tid,&amp;retval); // retval = 0代表回收成功，-1 代表线程已经退出了</code></p><p>pthread_join()即是子线程合入主线程，<code>主线程阻塞等待子线程结束</code>，然后回收子线程资源。</p><p>pthread_join()函数，<code>以阻塞的方式</code>等待thread指定的线程结束。当函数返回时，<code>被等待线程的资源被收回</code>。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p><p>一般情况下需要回收线程，retval 用来接收线程的返回值，tid 是线程的id，该方法会阻塞等待<br>什么情况下不需要回收呢？除非调用了分离线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    pthread_join(tid,&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="5-杀死（取消）线程"><a href="#5-杀死（取消）线程" class="headerlink" title="5.杀死（取消）线程"></a>5.杀死（取消）线程</h1><p><code>pthread_cancel(tid);</code> // 取消线程需要有函数进入内核，也就是说需要调用系统函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 循环里面是空的，则会卡死，线程不会取消，原因是取消线程需要有函数进入内核</span></span><br><span class="line">            <span class="comment">// printf("i am a thread，no = %d\n",no);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 实在没什么写的，又想线程能够取消，可以调下面这个方法</span></span><br><span class="line">            pthread_testcancel();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;retval);<span class="comment">// 返回值是 -1 ,表示被干掉或者退出的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="6-分离线程"><a href="#6-分离线程" class="headerlink" title="6.分离线程"></a>6.分离线程</h1><p><code>pthread_detach(tid);使线程ID为tid的线程处于分离状态，一旦线程处于分离状态，该线程终止时底 层资源立即被回收</code></p><p>分离线程之后是当线程执行完毕或者<code>pthread_exit</code>后，残留在线程中的资源会自动回收，也就是说线程需要回收，有两种方式一种是 join 一种是 detach 分离。</p><p><code>该函数不会阻塞父线程。pthread_detach(tid);函数用于只是应用程序在线程tid终止时回收其存储空间。如果tid尚未终止，pthread_detach()不会终止该线程。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对线程进行分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    pthread_join(tid,&amp;retval);<span class="comment">// 返回值是 -1 ,表示被干掉或者退出的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="7-线程同步"><a href="#7-线程同步" class="headerlink" title="7.线程同步"></a>7.线程同步</h1><ul><li><code>pthread_mutex_t mutex</code></li><li>加锁：<code>pthread_mutex_lock(&amp;mutex);</code></li><li>解锁：<code>pthread_mutex_unlock(&amp;mutex);</code></li><li>销毁锁：<code>pthread_mutex_destroy(&amp;mutex);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 加一个锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 加一个条件</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> product_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt;<span class="number">200000000</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现加锁的出错的情况，应该是没有计算完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成者与消费者（java要能手写）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                <span class="comment">// 1. 阻塞等待唤醒</span></span><br><span class="line">                <span class="comment">// 2. 释放锁</span></span><br><span class="line">                <span class="comment">// 3. 被唤醒，解除阻塞，需要重新竞争锁</span></span><br><span class="line">                <span class="comment">// 是一个 while 循环，等待有两种方式会被唤醒，一种是条件发信号，一种是系统（不正常）惊群效应</span></span><br><span class="line">                <span class="keyword">while</span>(number &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"等待生产者生成产品"</span>);</span><br><span class="line">                        pthread_cond_wait(&amp;product_cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"消费者消费产品: %ld\n"</span>,number);</span><br><span class="line">                number--;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"生成者生产产品: %ld\n"</span>,number);</span><br><span class="line">                <span class="comment">// 通知消费者消费</span></span><br><span class="line">                pthread_cond_signal(&amp;product_cond);</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;product_cond,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="keyword">int</span> *retval;</span><br><span class="line">        <span class="comment">//for(int i=0; i&lt;4;i++)&#123;</span></span><br><span class="line">                <span class="comment">// 传的是同一个 id ，tid 没有赋值的，tid 是当做一个传出参数 0</span></span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">pthread_detach(tid);</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(5);</span></span><br><span class="line">        <span class="comment">// 销毁锁</span></span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">        pthread_cond_destroy(&amp;product_cond);</span><br><span class="line">        <span class="comment">// 销毁条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"number = %ld\n"</span>, number);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-线程的本质&quot;&gt;&lt;a href=&quot;#1-线程的本质&quot; class=&quot;headerlink&quot; title=&quot;1.线程的本质&quot;&gt;&lt;/a&gt;1.线程的本质&lt;/h1&gt;&lt;p&gt;线程与进程的区别：线程大家可以简单理解为一个轻量级的进程，线程共享了栈和堆（变量），没有复制 0-3
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：06.linux系统-IPC进程间通信</title>
    <link href="http://eastup.github.io/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://eastup.github.io/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2020-08-06T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:14.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-进程间通信的方式"><a href="#1-进程间通信的方式" class="headerlink" title="1.进程间通信的方式"></a>1.进程间通信的方式</h1><p>文件，管道，信号、信号量，共享映射区（共享内存），消息队列，管道，套接字（socket）</p><p>着重讲下：</p><ul><li>管道（使用简单）</li><li>信号（开销比较小）</li><li><font color="red">共享映射区</font></li><li>套接字（低速稳定）</li></ul><p>一般都是通过内核共享空间进行通信</p><p><img src="/images/77.进程间通信.png" alt></p><h1 id="2-管道-pipe"><a href="#2-管道-pipe" class="headerlink" title="2.管道(pipe)"></a>2.管道(pipe)</h1><p><img src="/images/77.管道.png" alt><br><img src="/images/77.管道的通信机制.png" alt></p><ol><li>无名管道，<font color="red">半双工的通信方式(数据流向固定：只能 a 的数据写给 b ，或者 b 的数据写给 a )</font></li><li>管道大家可以简单的理解为一种特殊的文件形式，我们可以用文件的读写方法，不是一种简单的文件，只会占用内存。</li><li>管道只能是有血缘关系的进程间通信</li><li>数据不能自己写自己读</li><li>数据一旦读走，不能再次读</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pipe error!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="comment">// 等等在读</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 没有其它读写操作了可以关闭 fd[0]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe read : %s"</span>,buf);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello pipe\n"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 没有其它读写操作了可以关闭 fd[1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非法操作：</p><ol><li><p>读管道：<br> 1.1 管道中有数据，read 返回实际读到的数据</p><p> 1.2 管道中无数据：    </p><pre><code> 1.2.1 管道写端被关闭，read 返回 0 1.2.2 管道写端如果没有被关闭，会阻塞等待</code></pre></li><li><p>写管道：<br> 2.1 读端被关闭，异常终止（信号导致）</p><p> 2.2 读端未关闭：</p><pre><code> 2.2.1 管道数据已满，阻塞等待写入数据（其他人读走） 2.2.2 管道未满，直接将数据写入</code></pre></li></ol><h1 id="3-共享映射区"><a href="#3-共享映射区" class="headerlink" title="3.共享映射区"></a><font color="red">3.共享映射区</font></h1><p><img src="/images/77.mmap的实现原理.png" alt></p><p>binder 驱动，腾讯 MMKV，xlog （日志库）中都会有 <code>mmap</code>函数</p><p>以下是binder驱动的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、注册建立ServiceManager表。</span><br><span class="line">2、Service1、Service2通过Binder驱动申请注册到ServiceManager中。</span><br><span class="line">3、Client需要与Service2进行通信,跨进程无法直接通信，需要先通过ServiceManger中查询到Service2。借助Binder驱动</span><br><span class="line">返回一个Service2的代理对象。Client直接跟Service2代理对象进行操作，通过Binder驱动映射操作Service2真实对象，从而完成通信。</span><br><span class="line"></span><br><span class="line">- Binder是一种通信机制；</span><br><span class="line">- 对于Service来说Binder指的是Binder本地对象，对于Client来说Binder指的是Binder的代理对象；</span><br><span class="line">- 对于传输过程而言，Binder是可以跨进程传递的对象。</span><br><span class="line"></span><br><span class="line">为什么要使用Binder？</span><br><span class="line">性能方面</span><br><span class="line"></span><br><span class="line">在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，</span><br><span class="line">更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</span><br><span class="line"></span><br><span class="line">安全方面</span><br><span class="line"></span><br><span class="line">传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协</span><br><span class="line">议本身就支持对通信双方做身份校检，因而大大提升了安全性。</span><br></pre></td></tr></table></figure><p>mmap 注意事项  </p><ol><li>指定映射区的大小，必须要小于文件大小</li><li>映射区大小必须要大于 0 ，否则会异常</li><li>创建映射区需要 read 权限，mmap 的读写权限应该 &lt;= 文件的权限</li><li>文件可以先关闭</li><li>偏移量必须是 4k 的整数倍</li><li>MAP_PRIVATE 只会对内存进行修改，不会反应到磁盘上</li></ol><p>mmap 万能调用方法：<br>open(O_RDWR);<br>mmap(NULL, 有效大小，PROT_READ|PROT_WRITE,MAP_SHARED,fd,0)  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * msg)</span></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line"><span class="comment">              int fd, off_t offset);</span></span><br><span class="line"><span class="comment">   int munmap(void *addr, size_t length);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  addr：地址，一般可以不传（NULL），传入传出参数</span></span><br><span class="line"><span class="comment">     *  length：内存大小</span></span><br><span class="line"><span class="comment">     *  prot：</span></span><br><span class="line"><span class="comment">     *       PROT_EXEC 内容可以被执行</span></span><br><span class="line"><span class="comment">     *       PROT_READ 内容可以被读取</span></span><br><span class="line"><span class="comment">     *       PROT_WRITE 内容可以被写</span></span><br><span class="line"><span class="comment">     *       PROT_NONE 内容不可访问</span></span><br><span class="line"><span class="comment">     *  flags:</span></span><br><span class="line"><span class="comment">     *       MAP_SHARED 共享</span></span><br><span class="line"><span class="comment">     *       MAP_PRIVATE 私有f</span></span><br><span class="line"><span class="comment">     *       MAP_ANONYMOUS 匿名映射（不基于文件）,fd 参数就传 -1</span></span><br><span class="line"><span class="comment">     *  fd: 文件句柄</span></span><br><span class="line"><span class="comment">     *  offset：偏移大小，必须是 4K 的整数倍，一个物理页映射是 4K。     </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建打开一个文件</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test_map"</span>,O_ROWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">"open file error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件变大（不增大的话，映射的是 0）</span></span><br><span class="line">    ftruncate(fd,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>,<span class="number">20</span>, PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭了文件，那么后面通过操作 mmap 的空间，能不能写入文件? 能</span></span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">// 关闭的是系统函数到文件的操作，而 mmap 映射不受影响</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"hello mmap\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---&gt;%s"</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放 mmap</span></span><br><span class="line">    munmap(p,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有示例请可以看<a href="https://github.com/EastUp/CPractice/tree/master/linux/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">这儿</a></p><h1 id="4-信号"><a href="#4-信号" class="headerlink" title="4.信号"></a>4.信号</h1><p>进程间通信的机制，内核自带的，信号不能携带大量的数据，一般就是一个数字，只有在特定场景下才调用。</p><p>怎样才会产生信号：</p><ol><li>按键产生: ctrl + c, ctrl+z</li><li>系统调用 kill ， raise， abort</li><li>软件条件产生， alarm</li><li>硬件异常产生，非法访问内存，除 0 ，内存对齐等等</li><li>命令产生</li></ol><p>信号的处理方式：</p><ol><li>忽略此信号</li><li>执行系统默认动作</li><li>捕捉用户希望动作</li></ol><p>信号处理的原理：  </p><ul><li>信号屏蔽字: 用于屏蔽x信号，内部实现就是一个集合，当 x 信号屏蔽后，再收到该信号，信号处理将推后</li><li>未决信号集: 信号抵达 x 信号位反转为 1 ， 当信号被处理后重新置为 0 </li></ul><p><code>man 7 signal</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">       Signal     Value     Action   Comment</span><br><span class="line">       ──────────────────────────────────────────────────────────────────────</span><br><span class="line">       SIGHUP        1       Term    Hangup detected on controlling terminal</span><br><span class="line">                                     or death of controlling process</span><br><span class="line">       SIGINT        2       Term    Interrupt from keyboard</span><br><span class="line">       SIGQUIT       3       Core    Quit from keyboard</span><br><span class="line">       SIGILL        4       Core    Illegal Instruction</span><br><span class="line">       SIGABRT       6       Core    Abort signal from abort(3)</span><br><span class="line">       SIGFPE        8       Core    Floating point exception</span><br><span class="line">       SIGKILL       9       Term    Kill signal</span><br><span class="line">       SIGSEGV      11       Core    Invalid memory reference</span><br><span class="line">       SIGPIPE      13       Term    Broken pipe: write to pipe with no</span><br><span class="line">                                     readers</span><br><span class="line">       SIGALRM      14       Term    Timer signal from alarm(2)</span><br><span class="line">       SIGTERM      15       Term    Termination signal</span><br><span class="line">       SIGUSR1   30,10,16    Term    User-defined signal 1</span><br><span class="line">       SIGUSR2   31,12,17    Term    User-defined signal 2</span><br><span class="line">       SIGCHLD   20,17,18    Ign     Child stopped or terminated</span><br><span class="line">       SIGCONT   19,18,25    Cont    Continue if stopped</span><br><span class="line">       SIGSTOP   17,19,23    Stop    Stop process</span><br><span class="line">       SIGTSTP   18,20,24    Stop    Stop typed at tty</span><br><span class="line">       SIGTTIN   21,21,26    Stop    tty input for background process</span><br><span class="line">       SIGTTOU   22,22,27    Stop    tty output for background process</span><br><span class="line"></span><br><span class="line">       Signal       Value     Action   Comment</span><br><span class="line">       ────────────────────────────────────────────────────────────────────</span><br><span class="line">       SIGBUS      10,7,10     Core    Bus error (bad memory access)</span><br><span class="line">       SIGPOLL                 Term    Pollable event (Sys V).</span><br><span class="line">                                       Synonym for SIGIO</span><br><span class="line">       SIGPROF     27,27,29    Term    Profiling timer expired</span><br><span class="line">       SIGSYS      12,31,12    Core    Bad argument to routine (SVr4)</span><br><span class="line">       SIGTRAP        5        Core    Trace&#x2F;breakpoint trap</span><br><span class="line">       SIGURG      16,23,21    Ign     Urgent condition on socket (4.2BSD)</span><br><span class="line">       SIGVTALRM   26,26,28    Term    Virtual alarm clock (4.2BSD)</span><br><span class="line">       SIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2BSD)</span><br><span class="line">       SIGXFSZ     25,25,31    Core    File size limit exceeded (4.2BSD)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Signal     Value     Action   Comment</span><br><span class="line">名称        编号       事件      默认执行动作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Term ： 终止进程</span><br><span class="line">Ign ： 忽略</span><br><span class="line">Core：终止进程，生成 Core 文件（可以帮助开发者检测）</span><br><span class="line">Stop：停止进程</span><br><span class="line">Cont：继续运行</span><br></pre></td></tr></table></figure><p>Process.killProcess(Process.myPid());</p><p><code>kill pid （发送信号）</code> : 第一个参数，，&lt; 0 往 |pid| 发个信息，0 杀死进程组，不要传 -1 </p><ul><li>pid &gt; 0 往 pid 进程发个信号</li><li>pid &lt; 0 往 |pid| 发个信息</li><li>pid = 0 杀死进程组</li><li>不要传 -1 ,会杀死所有能杀死的进程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-进程间通信的方式&quot;&gt;&lt;a href=&quot;#1-进程间通信的方式&quot; class=&quot;headerlink&quot; title=&quot;1.进程间通信的方式&quot;&gt;&lt;/a&gt;1.进程间通信的方式&lt;/h1&gt;&lt;p&gt;文件，管道，信号、信号量，共享映射区（共享内存），消息队列，管道，套接字（s
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="面试" scheme="http://eastup.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：05.linux系统-进程创建和进程管理</title>
    <link href="http://eastup.github.io/76.linux%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://eastup.github.io/76.linux%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-05T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:01.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-pcb-process-control-block-进程控制块"><a href="#1-pcb-process-control-block-进程控制块" class="headerlink" title="1.pcb(process control block)进程控制块"></a>1.pcb(process control block)进程控制块</h1><p>结构体的路径：<code>~/usr/src/linux-headers-3.5.0-23/include/linux/sched.h</code></p><p>结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">        &#x2F;&#x2F; ......</span><br><span class="line"></span><br><span class="line">        进程 id</span><br><span class="line"></span><br><span class="line">        文件描述符</span><br><span class="line"></span><br><span class="line">        进程的状态：初始态，就绪态，运行态，挂起态，终止态</span><br><span class="line"></span><br><span class="line">        进程工作目录</span><br><span class="line"></span><br><span class="line">        信号相关信息资源</span><br><span class="line"></span><br><span class="line">        用户id组id</span><br><span class="line"></span><br><span class="line">        进程工作目录</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-内存映射（重点）"><a href="#2-内存映射（重点）" class="headerlink" title="2.内存映射（重点）"></a><strong><font color="red">2.内存映射（重点）</font></strong></h1><p>由于应用程序不能直接操作设备硬件地址，所以操作系统提供了这样的一种机制——内存映射，把设备地址映射到进程虚拟地址，<code>mmap</code>就是实现内存映射的接口。</p><p><code>mmap</code>的好处是，mmap<code>把设备内存映射到虚拟内存，则用户操作虚拟内存相当于直接操作设备了，省去了用户空间到内核空间的复制过程，相对IO操作来说，增加了数据的吞吐量</code>。</p><p>用户空间映射时，会映射到不同的区域，内核空间映射时，会映射到同一区域的不同地方（共享！！）</p><p>每个进程都有4G的虚拟地址空间，其中3G用户空间，1G内核空间（linux），每个进程共享内核空间，独立的用户空间</p><p><img src="/images/76.内存映射.png" alt></p><h1 id="3-fork-创建子进程（重点）"><a href="#3-fork-创建子进程（重点）" class="headerlink" title="3.fork 创建子进程（重点）"></a><strong><font color="red">3.fork 创建子进程（重点）</font></strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc.<span class="keyword">const</span>  <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process!,pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent,cpid = %d,pid = %d,ppid = %d"</span> ,pid,getpid(),getppid());</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/76.fork函数.png" alt></p><h1 id="4-父子进程共享（重点）"><a href="#4-父子进程共享（重点）" class="headerlink" title="4.父子进程共享（重点）"></a><strong><font color="red">4.父子进程共享（重点）</font></strong></h1><h2 id="4-1-父子进程相同："><a href="#4-1-父子进程相同：" class="headerlink" title="4.1 父子进程相同："></a>4.1 父子进程相同：</h2><p>刚 fork 后，data 段，text 段，堆，栈，环境变量，全局变量，进程工作目录，信号处理方式。（0-3G 部分是共享的）</p><h2 id="4-2-父子进程不同的："><a href="#4-2-父子进程不同的：" class="headerlink" title="4.2 父子进程不同的："></a>4.2 父子进程不同的：</h2><p>进程 id ，返回值，各自的父进程，进程创建时间，闹钟，未决信号集 </p><h2 id="4-3-父子进程共享："><a href="#4-3-父子进程共享：" class="headerlink" title="4.3 父子进程共享："></a>4.3 父子进程共享：</h2><p>map 映射区，读时共享，写时复制。</p><h1 id="5-进程回收"><a href="#5-进程回收" class="headerlink" title="5. 进程回收"></a>5. 进程回收</h1><p>回收的就是残留在内核中的 3-4G 的数据（pcb 进程控制块）</p><ul><li>孤儿进程：父进程先于子进程结束，则子进程会成为孤儿进程，子进程的父进程成为 init 进程，有 init 进程（进程孤儿院）来回收进程。</li><li>僵尸进程：子进程结束，父进程尚未回收，该子进程会变成僵尸进程</li></ul><p>wait, waitpid<br>wait功能：</p><ol><li>阻塞等待子线程退出</li><li>回收子进程残留的资源</li><li>获取子进程退出的状态（怎么死掉的）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state;</span><br><span class="line">wait(&amp;state);</span><br></pre></td></tr></table></figure><h1 id="6-监听-APP-应用被卸载"><a href="#6-监听-APP-应用被卸载" class="headerlink" title="6.监听 APP 应用被卸载"></a>6.监听 APP 应用被卸载</h1><ol><li>fork 一个子进程</li><li>监听文件是否被删除了，data/data/xxx包名</li><li>execl 函数族去执行某些命令（打开浏览器收集用户反馈）  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以执行自己写好的程序，path 是路径，arg 是可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行系统的命令程序，file 是命令的名称，arg 是可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br></pre></td></tr></table></figure> <font color="red">execl 不会走 fork 之后的 text 代码段，而是会去执行 exec 函数族的命令或者程序</font> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc.<span class="keyword">const</span>  <span class="keyword">char</span>* argv[])</span></span>&#123; <span class="comment">// 获取 参数 -l ，[1]才是，[0]是程序本身</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process!,pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">        execl(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>); <span class="comment">// NULL 代表可变参数的结尾</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent,cpid = %d,pid = %d,ppid = %d"</span> ,pid,getpid(),getppid());</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-pcb-process-control-block-进程控制块&quot;&gt;&lt;a href=&quot;#1-pcb-process-control-block-进程控制块&quot; class=&quot;headerlink&quot; title=&quot;1.pcb(process control bloc
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：04.linux系统-内核编程，文件IO与文件描述符</title>
    <link href="http://eastup.github.io/75.linux%E7%B3%BB%E7%BB%9F-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%87%E4%BB%B6IO%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://eastup.github.io/75.linux%E7%B3%BB%E7%BB%9F-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%87%E4%BB%B6IO%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</id>
    <published>2020-08-04T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:54.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-系统内核调用"><a href="#1-系统内核调用" class="headerlink" title="1. 系统内核调用"></a>1. 系统内核调用</h1><p>3-4G 是系统的空间（<code>内核空间</code>），这部分是由操作系统来管理，那么如果我们要操作这部分数据，只能借助系统提供的一些函数（系统函数），用户调用这些函数就称之为系统调用。</p><p><img src="/images/75.系统调用.png" alt></p><h1 id="2-普通函数与内核函数"><a href="#2-普通函数与内核函数" class="headerlink" title="2.普通函数与内核函数"></a>2.普通函数与内核函数</h1><p>系统函数：<code>open , close , write , read</code></p><p><code>man 2 ‘系统函数’</code>：查看系统函数<br><code>man 3 ‘普通函数’</code>：查看系统函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; open</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">pathname : 文件的路径  </span><br><span class="line">flags : O_APPEND 追加，O_CREAT 没有的时候会创建，O_TRUNC 会截断（清空文件）  </span><br><span class="line">mode：就是创建时的文件权限 ， 只是当前用户可读可写，S_IRUSR|S_IWUSR  </span><br><span class="line">返回的是一个文件句柄 fd , 我们直接通过 fd 去做操作  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int close(int fd); 关闭文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  read</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">fd：文件句柄</span><br><span class="line">void *buf：读入的缓冲区</span><br><span class="line">count：每次读多少字节数</span><br><span class="line">ssize_t ：返回的是读到真实个数</span><br><span class="line"></span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">fd：文件句柄</span><br><span class="line">void *buf：写入的缓冲区</span><br><span class="line">count：每次写入的字节数</span><br><span class="line">ssize_t ：返回的是写入真实个数</span><br></pre></td></tr></table></figure><p>文件操作的错误怎么提示？会有一个宏定义 errno  , 通过 strerror(errno) 获取错误信息，需要打印错误快捷的方式 perror<br>void perror(const char *s); s 代表的是错误信息的描述 s: strerror(errno)</p><p>普通函数：<code>fopen，fclose ， fread/fputc ，fwrite/fgetc</code></p><h1 id="3-普通函数和系统函数拷贝文件的区别"><a href="#3-普通函数和系统函数拷贝文件的区别" class="headerlink" title="3.普通函数和系统函数拷贝文件的区别"></a>3.普通函数和系统函数拷贝文件的区别</h1><p>fputc 和 fgetc 内部是封装了 read , wirte , 如果拷贝文件，速度区别如下：</p><ul><li>系统函数每次只读取一个 Byte，速度很慢</li><li>普通函数每次读取 4096 个 byte，所以很快</li></ul><p>Java write 数据，需要 flush 的原理一样，数据还在缓冲区(数据不会自动发送出去)，需要flush一起给到内核空间，在内核空间中调用 write.</p><p><img src="/images/75.系统函数与普通函数.png" alt></p><h1 id="4-文件描述符（文件句柄）"><a href="#4-文件描述符（文件句柄）" class="headerlink" title="4.文件描述符（文件句柄）"></a>4.文件描述符（文件句柄）</h1><p><img src="/images/75.文件描述符.png" alt></p><h1 id="5-lseek-与-fseek"><a href="#5-lseek-与-fseek" class="headerlink" title="5.lseek 与 fseek"></a>5.lseek 与 fseek</h1><p>用来获取偏移量 SEEK_SET , SEEK_END, SEEK_CUR<br>lseek 他的偏移量，读和写是同一个</p><h1 id="6-stat-和-lstat"><a href="#6-stat-和-lstat" class="headerlink" title="6.stat 和 lstat"></a>6.stat 和 lstat</h1><p>Inode: 370887 ， 文件的权限，盘符的位置。<br>硬链接计数就充分的利用了 inode<br>硬链接：文件快捷键<br>软链接：类似于文件的快捷键，但是你操作任何一个都会被改变  </p><p>软连接和硬链接的特点：</p><p>软链接：</p><ul><li>软链接是存放另一个文件的路径的形式存在。</li><li>软链接可以 跨文件系统 ，硬链接不可以。</li><li>软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。</li><li>软链接可以对目录进行链接。</li></ul><p>硬链接：</p><ul><li>硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>不允许给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li><li>删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul><p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int stat(const char *pathname, struct stat *buf);</span><br><span class="line">pathname：文件路径</span><br><span class="line"></span><br><span class="line">struct stat *buf：stat 结构体指针</span><br><span class="line"></span><br><span class="line">作业：stat 获取文件的属性，获取文件的大小就可以</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stat 和 lstat 有什么区别？stat 是会穿透的，lstat 不会穿透，穿透软连接</span><br><span class="line"></span><br><span class="line">ln -s f_read_write f_read_write.soft ： 创建软连接</span><br></pre></td></tr></table></figure><h1 id="7-目录操作"><a href="#7-目录操作" class="headerlink" title="7.目录操作"></a>7.目录操作</h1><p>递归操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName)</span></span>&#123;</span><br><span class="line">    <span class="comment">// int stat(const char *pathname,struct stat *buf);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>* <span class="title">buf</span>;</span> <span class="comment">// 作为传入参数</span></span><br><span class="line">    stat(fileName,&amp;buf);</span><br><span class="line">    <span class="keyword">mode_t</span> st_mode = buf.st_mode;</span><br><span class="line">    <span class="keyword">return</span> S_ISDIR(st_mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR *dir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open dir fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct dirent *readdir(DIR *dirp);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    <span class="keyword">while</span>((dirp = readdir(dir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// printf("%s\t",dirp-&gt;d_name);</span></span><br><span class="line">        <span class="comment">// 一个递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-系统内核调用&quot;&gt;&lt;a href=&quot;#1-系统内核调用&quot; class=&quot;headerlink&quot; title=&quot;1. 系统内核调用&quot;&gt;&lt;/a&gt;1. 系统内核调用&lt;/h1&gt;&lt;p&gt;3-4G 是系统的空间（&lt;code&gt;内核空间&lt;/code&gt;），这部分是由操作系统来管理，
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：03.linux系统-文档编辑、应用编译运行</title>
    <link href="http://eastup.github.io/74.linux%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E3%80%81%E5%BA%94%E7%94%A8%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/"/>
    <id>http://eastup.github.io/74.linux%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E3%80%81%E5%BA%94%E7%94%A8%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</id>
    <published>2020-08-03T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:47.203Z</updated>
    
    <content type="html"><![CDATA[<p>注意：<code>未做说明以下都是在命令模式下进行</code></p><p>编辑过程中遇到的问题：</p><p>误按了：<code>ctrl + z</code> ： 可以将一个正在前台执行的命令放到后台，并且暂停</p><p>再次打开就变成了以下这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">E325: 注意</span><br><span class="line">发现交换文件 &quot;.t.txt.swp&quot;</span><br><span class="line">            所有者: root    日期: Sun Aug 25 23:27:33 2019</span><br><span class="line">            文件名: ~root&#x2F;test&#x2F;t.txt</span><br><span class="line">            修改过: 否</span><br><span class="line">            用户名: root      主机名: master</span><br><span class="line">           进程 ID: 4803 (仍在运行)</span><br><span class="line">正在打开文件 &quot;t.txt&quot;</span><br><span class="line">              日期: Sun Aug 25 22:17:30 2019</span><br><span class="line"></span><br><span class="line">(1) Another program may be editing the same file.  If this is the case,</span><br><span class="line">    be careful not to end up with two different instances of the same</span><br><span class="line">    file when making changes.  Quit, or continue with caution.</span><br><span class="line">(2) An edit session for this file crashed.</span><br><span class="line">    如果是这样，请用 &quot;:recover&quot; 或 &quot;vim -r t.txt&quot;</span><br><span class="line">    恢复修改的内容 (请见 &quot;:help recovery&quot;)。</span><br><span class="line">    如果你已经进行了恢复，请删除交换文件 &quot;.t.txt.swp&quot;</span><br><span class="line">    以避免再看到此消息。</span><br><span class="line"></span><br><span class="line">交换文件 &quot;.t.txt.swp&quot; 已存在！</span><br><span class="line">以只读方式打开([O]), 直接编辑((E)), 恢复((R)), 退出((Q)), 中止((A)):</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>使用 <code>fg</code> :将后台中的命令调至前台继续运行</p><h1 id="1-vim-工作模式"><a href="#1-vim-工作模式" class="headerlink" title="1. vim 工作模式"></a>1. vim 工作模式</h1><p><img src="/images/74.vim三种工作模式.png" alt></p><ul><li><code>gcc hello.c -o a</code>：编译成可执行文件 <code>a</code></li><li><code>./a</code>：运行可执行文件 a</li></ul><h1 id="2-vim-命令模式进入输入模式的快捷键"><a href="#2-vim-命令模式进入输入模式的快捷键" class="headerlink" title="2 vim 命令模式进入输入模式的快捷键"></a>2 vim 命令模式进入输入模式的快捷键</h1><ul><li><code>i</code>: 输入,光标前面</li><li><code>I</code>: 输入,光标前面</li><li><code>a</code>: 输入,光标会逻动一个位置</li><li><code>A</code>:输入,光标会逻动到最后</li><li><code>o</code>:输入,光标会逻动到下一行</li><li><code>O</code>:输入,光标会逻动到上一行</li><li><code>s</code>:输入,会删除光标所在字符</li><li><p><code>S</code>: 输入,会删除光标所在行</p></li><li><p><code>h</code>: 向左移动光标</p></li><li><code>l</code>: 向右移动光标</li><li><code>j</code>: 向下移动光标</li><li><code>k</code>: 向上移动光标</li></ul><h2 id="2-1-跳转和删除"><a href="#2-1-跳转和删除" class="headerlink" title="2.1.跳转和删除"></a>2.1.跳转和删除</h2><ul><li><code>5G</code>：跳转到第 5 行</li><li><code>5回车</code>或者<code>G</code>：跳转到末行行首</li><li><code>gg</code>: 跳转到首行行首</li><li><code>$</code>: 跳转到当行行尾</li><li><code>0</code>: 跳转到当行行首</li><li><p><code>gg=G</code>: 格式化代码</p></li><li><p><code>dw</code>：删除单词从光标到单词结束的地方</p></li><li><code>x</code>: 删除某个字母</li><li><code>d0</code>: 删除光标至行首</li><li><code>v+h/j/k/l+d</code> 或者 <code>v+上/下/左/右+d</code>：删除选中区域</li><li><code>dd</code>: 剪切整行，可以当删除</li><li><code>3dd</code>: 从当前行剪切 3 行，可以当删除</li></ul><h2 id="2-2-复制、粘贴"><a href="#2-2-复制、粘贴" class="headerlink" title="2.2. 复制、粘贴"></a>2.2. 复制、粘贴</h2><ul><li><code>yy</code>: 复制当前行</li><li><code>3yy</code>: 从当前行复制 3 行</li><li><code>p</code>: 粘贴到当前行的<code>下一行</code></li><li><code>P</code>: 粘贴到当前行的<code>上一行</code></li><li><code>dd</code>: 剪切整行</li><li><code>3dd</code>: 从当前行剪切 3 行</li></ul><h2 id="2-3-查找替换"><a href="#2-3-查找替换" class="headerlink" title="2.3 查找替换"></a>2.3 查找替换</h2><ul><li><code>/ + &#39;要查找的内容&#39; +回车</code>:  查找 , ‘*’或‘n’ 跳转到下一个， ‘N’ 是查看上一个</li><li><code>r + &#39;要替换的字符&#39;</code>：把当前光标字符替换成 ‘要替换的字符’</li><li><code>:s /printf/println</code> : 将当前光标所在行中的<code>第一个</code>printf替换成println</li><li><code>:%s /printf/println</code> : 将每一行中的<code>第一个</code>printf替换成println</li><li><code>:s /printf/println/g</code> ：将这一行的所有printf替换成println</li><li><code>:%s /printf/println/g</code> : 将所有地方的printf替换成println</li><li><code>:1,3s /printf/println/g</code>: 将1-3行的所有printf替换成println</li></ul><h2 id="2-4-其它命令"><a href="#2-4-其它命令" class="headerlink" title="2.4.其它命令"></a>2.4.其它命令</h2><ul><li><code>u</code>: 撤销</li><li><code>ctrl+r</code>: 反撤销</li><li><code>:sp</code>: 上下分屏</li><li><code>:vsp</code>: 左右分屏</li><li><code>ctrl + ww</code> : 切换分屏</li><li><code>wqall</code>: 保存退出所有</li><li><code>3+K或2+K</code>: 跳转到光标所指向的函数声明</li></ul><h1 id="3-gcc-编译的四个步骤"><a href="#3-gcc-编译的四个步骤" class="headerlink" title="3. gcc 编译的四个步骤"></a>3. gcc 编译的四个步骤</h1><p>.c 文件 -&gt; 可执行文件，经历了四个步骤</p><h2 id="3-1-预处理阶段"><a href="#3-1-预处理阶段" class="headerlink" title="3.1 预处理阶段"></a>3.1 预处理阶段</h2><p><code>将所有的宏定义的替换，类似于 java 的 final</code>,展开include的文件 </p><p><code>gcc -E -o hello.i hello.c</code>: 将 hello.c 文件预处理成 hello.i 文件</p><h2 id="3-2-预编译阶段"><a href="#3-2-预编译阶段" class="headerlink" title="3.2 预编译阶段"></a>3.2 预编译阶段</h2><p>在这个阶段，GCC 才会去检测你代码的规范性，语法是否有错误，gcc 会把代码翻译成汇编</p><p><code>gcc -S -o hello.s hello.i</code>:将 hello.i 文件预编译成 hello.i 文件</p><h2 id="3-3-汇编阶段"><a href="#3-3-汇编阶段" class="headerlink" title="3.3 汇编阶段"></a>3.3 汇编阶段</h2><p>把 .s 文件翻译成二进制.o文件（机器的指令）,文本打开的是乱码</p><p><code>gcc -c -o hello.o hello.s</code>:将 hello.s 汇编成 hello.o 文件</p><h3 id="3-4-链接阶段"><a href="#3-4-链接阶段" class="headerlink" title="3.4 链接阶段"></a>3.4 链接阶段</h3><p>计算逻辑地址，合并数据段，有些函数是在另外一个 so 库文件中的。</p><p><code>gcc -o hello hello.o</code>：这个时候就可以执行<code>hello</code>了</p><h1 id="4-动态库和静态库"><a href="#4-动态库和静态库" class="headerlink" title="4.动态库和静态库"></a>4.动态库和静态库</h1><p><code>静态库</code>：其实是内容的拷贝(代码)，运行阶段<code>没有 .a 文件</code>了也是可以执行的。<br><code>动态库</code>：不会拷贝内容，运行阶段起的作用（加载），生成 so 的时候要生成与位置无关的代码，没有 so 不能运行。</p><h2 id="4-1-静态库的生成"><a href="#4-1-静态库的生成" class="headerlink" title="4.1 静态库的生成:"></a>4.1 静态库的生成:</h2><h3 id="4-1-1-将-c-生成-o"><a href="#4-1-1-将-c-生成-o" class="headerlink" title="4.1.1 将 c 生成 .o"></a>4.1.1 将 c 生成 .o</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o  <span class="comment">// 将 add.c 文件输出为 .o文件</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-使用-ar-工具制作静态库"><a href="#4-1-2-使用-ar-工具制作静态库" class="headerlink" title="4.1.2. 使用 ar 工具制作静态库"></a>4.1.2. 使用 ar 工具制作静态库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmath.a add.o xxx.o <span class="comment">// 将 add.o 和 xxx.o 文件制作到 libmath.a 中</span></span><br></pre></td></tr></table></figure><h3 id="4-1-3-编译静态库到可执行文件"><a href="#4-1-3-编译静态库到可执行文件" class="headerlink" title="4.1.3. 编译静态库到可执行文件"></a>4.1.3. 编译静态库到可执行文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c libmath.a -o hello <span class="comment">// 将 a.c 和 libmath.a 输出到可执行文件 hello 中</span></span><br></pre></td></tr></table></figure><h2 id="4-2-动态库生成"><a href="#4-2-动态库生成" class="headerlink" title="4.2 动态库生成"></a>4.2 动态库生成</h2><h3 id="4-2-1-将-c-生成-o-（要生成与位置无关的代码）"><a href="#4-2-1-将-c-生成-o-（要生成与位置无关的代码）" class="headerlink" title="4.2.1 将 c 生成 .o （要生成与位置无关的代码）"></a>4.2.1 将 c 生成 .o （要生成与位置无关的代码）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o -fPIC  <span class="comment">// // 将 add.c 文件输出为 .o文件 要加 -fPIC</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-使用-gcc-shared-制作动态库"><a href="#4-2-2-使用-gcc-shared-制作动态库" class="headerlink" title="4.2.2 使用 gcc -shared 制作动态库"></a>4.2.2 使用 gcc -shared 制作动态库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libmath.so add.o xxx.o <span class="comment">// // 将 add.o 和 xxx.o 文件制作到 libmath.so 中</span></span><br></pre></td></tr></table></figure><h3 id="4-2-3-编译动态库到可执行文件，需要指定动态库的名称-l-指定库路径-L"><a href="#4-2-3-编译动态库到可执行文件，需要指定动态库的名称-l-指定库路径-L" class="headerlink" title="4.2.3 编译动态库到可执行文件，需要指定动态库的名称 -l , 指定库路径 -L"></a>4.2.3 编译动态库到可执行文件，需要指定动态库的名称 -l , 指定库路径 -L</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -o a -lmath -L./   <span class="comment">// libmath.so 要写成math， ./ 代表当前文件夹</span></span><br></pre></td></tr></table></figure><h1 id="5-虚拟内存与物理内存"><a href="#5-虚拟内存与物理内存" class="headerlink" title="5.虚拟内存与物理内存"></a>5.虚拟内存与物理内存</h1><p><code>虚拟内存</code> 是为了缓解<code>物理内存</code>的压力而创建的，他们之间是通过<code>映射</code>来进行的联系</p><p>每个进程都有4G的虚拟地址空间，其中3G用户空间，1G内核空间（linux），每个进程共享内核空间，独立的用户空间：</p><p><img src="/images/74.虚拟内存布局图.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：&lt;code&gt;未做说明以下都是在命令模式下进行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编辑过程中遇到的问题：&lt;/p&gt;
&lt;p&gt;误按了：&lt;code&gt;ctrl + z&lt;/code&gt; ： 可以将一个正在前台执行的命令放到后台，并且暂停&lt;/p&gt;
&lt;p&gt;再次打开就变成了以下这样&lt;/p&gt;
&lt;f
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
</feed>
