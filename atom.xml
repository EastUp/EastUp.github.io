<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jamin</title>
  
  <subtitle>人生没有终点！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://eastup.github.io/"/>
  <updated>2020-11-11T07:11:54.166Z</updated>
  <id>http://eastup.github.io/</id>
  
  <author>
    <name>jamin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>音视频：11.Shell脚本-动手编译FFmpeg</title>
    <link href="http://eastup.github.io/82.Shell%E8%84%9A%E6%9C%AC-%E5%8A%A8%E6%89%8B%E7%BC%96%E8%AF%91FFmpeg/"/>
    <id>http://eastup.github.io/82.Shell%E8%84%9A%E6%9C%AC-%E5%8A%A8%E6%89%8B%E7%BC%96%E8%AF%91FFmpeg/</id>
    <published>2020-08-11T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:54.166Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/fe54d70a260e" target="_blank" rel="noopener">避坑指南</a></p><h1 id="1-Cmake交叉编译Android动态库"><a href="#1-Cmake交叉编译Android动态库" class="headerlink" title="1.Cmake交叉编译Android动态库"></a>1.Cmake交叉编译Android动态库</h1><p>交叉编译：Linux上编译Android的so</p><p>ndk 16的以上版本自带交叉编译工具链</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake -DANDROID_NDK&#x3D;$&#123;NDK_PATH&#125; \ # ndk的安装目录（空格 \回车，相当于所有命令弄到同一行）</span><br><span class="line">        -DCMAKE_TOOLCHAIN_FILE&#x3D;$&#123;NDK_PATH&#125;&#x2F;build&#x2F;cmake&#x2F;android.toolchain.cmake \ # cmake 交叉编译工具链</span><br><span class="line">        -DANDROID_ABI&#x3D;&quot;armeabi-v7a&quot; \ # 指定CPU</span><br><span class="line">        -DANDROID_NATIVE_API_LEVEL&#x3D;19 \    # 指定最低版本</span><br><span class="line">        ..</span><br></pre></td></tr></table></figure><h1 id="2-配置NDK环境"><a href="#2-配置NDK环境" class="headerlink" title="2.配置NDK环境"></a>2.配置NDK环境</h1><p>在NDKr17以后，NDK 不再支持32位和64位 MIPS 和ARM v5(armeabi)</p><p>所以现在NDK中只支持armeabi-v7a，armeabi-v8a，x86,x86_64四类</p><p>注意如果是虚拟机的linux系统 <code>需要把要拷贝的文件放到桌面，然后通过ctrl+c复制，最后在虚拟机上 ctrl+v复制</code></p><ol><li>下载<a href="https://www.jianshu.com/p/528eeb266f83" target="_blank" rel="noopener">NDK</a></li><li>将下载好的linux系统的ndk,<code>拷贝</code>到linux系统的 <code>/lib</code>目录下<code>新建的ndk目录</code>并<code>解压</code>,需要root权限</li><li>配置环境变量   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">配置环境变量:</span><br><span class="line"></span><br><span class="line">配置环境变量 vim &#x2F;etc&#x2F;profile</span><br><span class="line">文件最后面输入：</span><br><span class="line">export NDK_PATH&#x3D;&#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b</span><br><span class="line">export PATH&#x3D;$NDK_PATH:$PATH</span><br><span class="line">使环境变量生效 source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-1-NDK中交叉编译工具的变化"><a href="#2-1-NDK中交叉编译工具的变化" class="headerlink" title="2.1 NDK中交叉编译工具的变化"></a>2.1 NDK中交叉编译工具的变化</h2><p>在ndkr17c 以后默认使用的变成了<code>clang</code>，<code>而不是gcc</code></p><h3 id="2-1-1-交叉编译工具位置的变化"><a href="#2-1-1-交叉编译工具位置的变化" class="headerlink" title="2.1.1. 交叉编译工具位置的变化:"></a>2.1.1. 交叉编译工具位置的变化:</h3><p>在 NDK r19以前的 ndk 内置了一个可以自动生成交叉编译工具(toolchain) 的.py文件，放在</p><p>ndk路径下面的build/tool/make_standalone_toolchain.py</p><p>要生成toolchain，使用下面的命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$NDK_HOME&#x2F;build&#x2F;tools&#x2F;make_standalone_toolchain.py --arch arm --api 21 --install-dir &#x2F;Users&#x2F;fczhao&#x2F;Desktop</span><br><span class="line"></span><br><span class="line">后面的几个都是必要的</span><br><span class="line"></span><br><span class="line">--arch 指定了生成的toolchain要在哪个CPU框架中使用</span><br><span class="line"></span><br><span class="line">--api 指定了生成的toolchain要在哪个Android API 中使用</span><br><span class="line"></span><br><span class="line">--install-dir 生成的toolchain的路径</span><br></pre></td></tr></table></figure><p>但是NDK r19以后的NDK已经内置了这些文件，如果运行上面的命令，会出现这样的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">WARNING:__main__:make_standalone_toolchain.py is no longer necessary. The</span><br><span class="line"></span><br><span class="line">#$NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin 这个路径已经有了我们要生成的文件</span><br><span class="line">$NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin directory contains target-specific scripts that perform</span><br><span class="line">the same task. For example, instead of:</span><br><span class="line"></span><br><span class="line">    $ python $NDK&#x2F;build&#x2F;tools&#x2F;make_standalone_toolchain.py \</span><br><span class="line">        --arch arm --api 21 --install-dir toolchain</span><br><span class="line">    $ toolchain&#x2F;bin&#x2F;clang++ src.cpp</span><br><span class="line"></span><br><span class="line">Instead use:</span><br><span class="line"></span><br><span class="line">    $ $NDK&#x2F;toolchains&#x2F;llvm&#x2F;prebuilt&#x2F;darwin-x86_64&#x2F;bin&#x2F;armv7a-linux-androideabi21-clang++ src.cpp</span><br><span class="line"></span><br><span class="line">Installation directory already exists. Use --force.</span><br></pre></td></tr></table></figure><h1 id="3-手写FFmpeg编译脚本"><a href="#3-手写FFmpeg编译脚本" class="headerlink" title="3.手写FFmpeg编译脚本"></a>3.手写FFmpeg编译脚本</h1><p>关于版本问题：学习尽量使用最新的版本（api过时，api改进），开发尽量使用大众的版本（方便查询解决问题）版本<code>3.3.9</code></p><p><font color="red">第三方库编译的通用思想：</font></p><ol><li>首先先看下<code>README.md</code>文件</li><li>编译项目（动静态库）需要 Makefile 管理，如果<code>已经有写好的Makefile可以尝试着用make命令去编译</code>，如果没有需要自己写<code>Makefile</code>或者采用 <code>cmake</code> 构建</li><li>如果Makefile报错需要解决，一般情况下都是Makefile的一些配置文件没生成，所以一般需要先运行<code>configure</code>文件</li><li>生成配置文件之后，再次运行make,但是编译后的文件（elf,so,a）只能在当前类型系统上运行。如果需要跑到android或ios那么需要<code>交叉编译</code>。<code>因此我们一般都需要往configure文件里面传一些交叉编译参数</code></li></ol><ul><li><code>./configure --help &gt; help.txt</code>:将configure 的帮助说明写到<code>help.txt</code>中去</li></ul><p><code>NDKr16以上的版本NDKr19</code>以下需要我们自己去生成android版本的交叉编译链 ,NDKr19以上不需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 创建目录 &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b&#x2F;android-toolchains&#x2F;android-19&#x2F;arch-arm</span><br><span class="line">2. 进入 &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r21b&#x2F;build&#x2F;tools 目录下</span><br><span class="line">3. 执行命令：</span><br><span class="line">    sudo .&#x2F;make_standalone_toolchain.py --arch arm --api 19 --install-dir &#x2F;lib&#x2F;ndk&#x2F;android-ndk-r16b&#x2F;android-toolchains&#x2F;android-19&#x2F;arch-arm</span><br><span class="line"></span><br><span class="line">如果出现 Installation directory already exists. Use --force.</span><br><span class="line"></span><br><span class="line">在上条命令最后面加上 --force就行</span><br></pre></td></tr></table></figure><p><code>ndk-r16b和ffmpeg3.3.9</code>的脚本文件请查看<a href="../makefile、cmake、shell/82.Shell脚本-动手编译FFmpeg/ffmpeg_build_r16b.sh">ffmpeg_build_r16b.sh</a>,还需要注意修改configure里生成文件名的方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">按 esc 键输入 &#x2F;build setting 查找</span><br><span class="line"></span><br><span class="line"># SLIBNAME_WITH_MAJOR&#x3D;&#39;$(SLIBNAME).$(LIBMAJOR)&#39;</span><br><span class="line"># LIB_INSTALL_EXTRA_CMD&#x3D;&#39;$$(RANLIB) &quot;$(LIBDIR)&#x2F;$(LIBNAME)&quot;&#39;</span><br><span class="line"># SLIB_INSTALL_NAME&#x3D;&#39;$(SLIBNAME_WITH_VERSION)&#39;</span><br><span class="line"># SLIB_INSTALL_LINKS&#x3D;&#39;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&#39;</span><br><span class="line"># 替换成如下</span><br><span class="line">SLIBNAME_WITH_MAJOR&#x3D;&#39;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&#39;</span><br><span class="line">LIB_INSTALL_EXTRA_CMD&#x3D;&#39;$$(RANLIB)&quot;$(LIBDIR)&#x2F;$(LIBNAME)&quot;&#39;</span><br><span class="line">SLIB_INSTALL_NAME&#x3D;&#39;$(SLIBNAME_WITH_MAJOR)&#39;</span><br><span class="line">SLIB_INSTALL_LINKS&#x3D;&#39;$(SLIBNAME)&#39;</span><br></pre></td></tr></table></figure><p><code>ndk-r16b和ffmpeg3.3.9</code>的脚本文件请查看<a href="../makefile、cmake、shell/82.Shell脚本-动手编译FFmpeg/ffmpeg_build_r21b.sh">ffmpeg_build_r21b.sh</a></p><h1 id="4-编译遇到的问题"><a href="#4-编译遇到的问题" class="headerlink" title="4.编译遇到的问题"></a>4.编译遇到的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">clang is unable to create an executable file. C compiler test failed.</span><br><span class="line">C compiler test failed.</span><br><span class="line"></span><br><span class="line">If you think configure made a mistake, make sure you are using the latest</span><br><span class="line">version from Git. If the latest version fails, report the problem to the</span><br><span class="line">ffmpeg-user@ffmpeg.org mailing list or IRC #ffmpeg on irc.freenode.net.</span><br><span class="line">Include the log file &quot;config.log&quot; produced by configure as this will help</span><br><span class="line">solving the problem.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当遇到这个问题的时候</span><br><span class="line"></span><br><span class="line">大部分是NDK支持平台错了</span><br><span class="line"></span><br><span class="line">sudo uname --m</span><br><span class="line"></span><br><span class="line">如果显示i686,你安装的是32位操作系统</span><br><span class="line">如果显示 x86_64，你安装的是64位操作系统</span><br><span class="line"></span><br><span class="line">下载的时候按下面</span><br><span class="line"></span><br><span class="line">android-ndk64-r10b-linux-x86.tar</span><br><span class="line">支持的是32位操作系统</span><br><span class="line">android-ndk64-r10b-linux-x86_64.tar.bz2 </span><br><span class="line">支持的是64位操作系统</span><br></pre></td></tr></table></figure><h1 id="5-如何适配so框架"><a href="#5-如何适配so框架" class="headerlink" title="5.如何适配so框架"></a>5.如何适配so框架</h1><p>目前支持有不同的 7 中 cpu 的架构，<code>ARMv5</code>,<code>ARMv7(2010年)</code>,<code>ARMv8</code>,<code>x86(2011年)</code>,<code>mips(2012年)</code>,<code>mip64</code>,<code>x86_64</code>。  </p><p>每一种架构都关联着一种<code>ABI</code>。  现在一般只需要arm架构就行</p><p>armv5,armv7（32位）,armv8（64位）：高版本会兼容低版本的，因此只需要放一个低版本的就可以了，armeabi或者armeabi-v7a(现在一般都是v7a，AS上只支持v7以上的，AS4.1提示后面上架到google play 的应用都需要支持64位的)  </p><p>armeabi：v5因为比较旧，因此早期缺少浮点计算的硬件支持，在需要大量计算是有一定的性能影响。</p><h1 id="6-编译参数传递"><a href="#6-编译参数传递" class="headerlink" title="6.编译参数传递"></a>6.编译参数传递</h1><h1 id="7-运行调试音频解码"><a href="#7-运行调试音频解码" class="headerlink" title="7.运行调试音频解码"></a>7.运行调试音频解码</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/fe54d70a260e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;避坑指南&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-Cmake交叉编译Android动态库&quot;&gt;&lt;a href=&quot;#1-C
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：10.Shell脚本-详解Shell脚本基础语法</title>
    <link href="http://eastup.github.io/81.Shell%E8%84%9A%E6%9C%AC-%E8%AF%A6%E8%A7%A3Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://eastup.github.io/81.Shell%E8%84%9A%E6%9C%AC-%E8%AF%A6%E8%A7%A3Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-08-10T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:50.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-shell-脚本创建与执行-01-sh"><a href="#1-shell-脚本创建与执行-01-sh" class="headerlink" title="1.shell 脚本创建与执行(01.sh)"></a>1.shell 脚本创建与执行(01.sh)</h1><p>一般都是<code>**.sh</code>文件</p><ul><li><code>#!</code>：需要用谁来解析执行该 shell 脚本</li><li><code>echo</code>：打印输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 需要用谁来解析执行该 shell 脚本</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line"># echo 打印输出</span><br><span class="line">echo &quot;Hello Shell!&quot;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"># 2.自定义变量与环境变量(02.sh)</span><br><span class="line"></span><br><span class="line">变量设计规则：</span><br><span class="line"></span><br><span class="line">1. 命名跟Java规范一样</span><br><span class="line">2. shell 中&#96;默认都是字符串类&#96;，如果需要用到其他类型，需要额外处理</span><br><span class="line">3. 变量用等号连接，千万注意&#96;不能有空格&#96;</span><br><span class="line">4. 变量的值如果有空格，需要用&#96;单引号&#96;或者&#96;双引号&#96;包括</span><br><span class="line"></span><br><span class="line">- &#96;$&#96;：取变量的值</span><br><span class="line">- &#96;echo &quot;CMAKE_PATH &#x3D; $&#123;CMAKE_PATH&#125;&quot;&#96;：输出环境变量CMAKE_PATH的值</span><br><span class="line">- soPath&#x3D;&#96;pwd&#96;：记得带上&#96;&#96;代表执行命令并返回</span><br></pre></td></tr></table></figure><p>#指定一个命令的执行结果返回给变量<br>#soPath=$(pwd)<br>soPath=<code>pwd</code><br>echo “soPath = ${soPath}”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>str1=”str1”  // str1<br>str2=str2    // str2<br>str3=3       // 3<br>str4=”Hello Shell” // Hello Shell</p><h1 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h1><p>str4=str4 // str4</p><h1 id="取变量的值"><a href="#取变量的值" class="headerlink" title="$取变量的值"></a>$取变量的值</h1><p>echo “str1 = $str1” // str1 = str1<br>echo “str2 = $str2” // str2 = str2<br>echo “str3 = $str3” // str3 = 3<br>echo “str4 = $str4” // str4 = str4</p><p>#输出环境变量<br>echo “CMAKE_PATH = ${CMAKE_PATH}”</p><p>#指定一个命令的执行结果返回给变量<br>#soPath=$(pwd)<br>soPath=<code>pwd</code>  // soPath = 当前路径<br>echo “soPath = ${soPath}” </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 3.位置参数变量与预定义变量</span><br><span class="line"></span><br><span class="line">## 3.1.获取位置参数（03.sh）</span><br><span class="line"></span><br><span class="line">- &#96;$n&#96; 来获取参数,$0 代表程序本身，&#96;$1-$9&#96;代表第一个参数到第九个参数，十以上的参数要用大括号 &#96;$&#123;10&#125;&#96;</span><br><span class="line">- &#96;$*&#96; 代表的是命令中的所有参数，&#96;加上引号才会把参数看成一个整体&#96; &quot;$0,$1,$2,$3,$4...$n&quot;，否则区别对待</span><br><span class="line">- &#96;$@&#96; 代表命令中的所有参数，但是会把参数区分对待 &quot;$0&quot;,&quot;$1&quot;,&quot;$2&quot;...&quot;$n&quot;</span><br><span class="line">- &#96;$#&#96; 代表参数中的个数</span><br></pre></td></tr></table></figure><p>echo “$0=$0”<br>echo “$1=$1”<br>echo “$2=”$2</p><p>echo “$<em>=”$</em><br>echo “$@=”$@<br>echo “$#=”$#</p><p>#每次逻动（删除）第一个参数<br>shift</p><p>echo “$1=$1”<br>echo “$@=”$@</p><p>echo “========================================”<br>for i in $*<br>do<br>echo $i<br>done</p><p>echo “========================================”<br>for i in $@<br>do<br>echo $i<br>done</p><p>echo “========================================”<br>for i in “$@”<br>do<br>echo $i<br>done</p><p>echo “========================================”<br>for i in “$*”  // 加上引号才会看成一个整体<br>do<br>echo $i<br>done</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3.2.预定义变量</span><br><span class="line"></span><br><span class="line">定义：是 bash 中已经定义好的，我们可以直接拿过来用，变量的作用都是固定</span><br><span class="line"></span><br><span class="line">- &#96;$?&#96;:返回的是上一个执行命令的返回值，执行成功返回 0 ，执行失败返回非0</span><br><span class="line">- &#96;$$&#96;:获取当前脚本的进程号</span><br><span class="line">- &#96;$!&#96;:获取最后一个后台执行的进程号</span><br><span class="line"></span><br><span class="line">## 3.3.获取输入的变量(04.sh)</span><br><span class="line"></span><br><span class="line">- &#96;read -p &quot;提示&quot; name&#96;：name 代表接受的变量名</span><br><span class="line">- &#96;read -sp &quot;提示&quot; pwd&#96;：&#96;-sp 看不到输入的密码&#96;，pwd 代表接受的变量名</span><br><span class="line">- &#96;read -t 5 -n 1 -p &quot;please input [y|n]&quot; input&#96;：-t 5代表5秒没响应就退出，-n 1 代表只能输入1个字符</span><br></pre></td></tr></table></figure><h1 id="获取用户及时输入的参数"><a href="#获取用户及时输入的参数" class="headerlink" title="获取用户及时输入的参数"></a>获取用户及时输入的参数</h1><p>#read -p “please input your name!” name<br>#echo “name = $name”</p><p>#输入年龄</p><h1 id="read-sp-“please-input-your-password”-pwd"><a href="#read-sp-“please-input-your-password”-pwd" class="headerlink" title="read -sp “please input your password” pwd"></a>read -sp “please input your password” pwd</h1><h1 id="echo-“password-pwd”"><a href="#echo-“password-pwd”" class="headerlink" title="echo “password=$pwd”"></a>echo “password=$pwd”</h1><p>read -t 5 -n 1 -p “please input [y|n]” input<br>echo “input = $input” </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 4.条件判断(测试指令)（05.sh）</span><br><span class="line">条件判断 &#96;test 表达式&#96; 或者 &#96;[]&#96;</span><br><span class="line"></span><br><span class="line">数字计算:</span><br><span class="line">- &#96;num3&#x3D;$(($num1+$num2))&#96;</span><br><span class="line">- num3&#x3D;&#96;expr $num1 + $num2&#96; &#x2F;&#x2F; 执行 expr命令，一定要有空格 传的三个参数</span><br><span class="line">- &#96;test $str1 &#x3D;&#x3D; $str2&#96; &#x2F;&#x2F; &#96;&#x3D;&#x3D;之间一定更要空格&#96;</span><br><span class="line"></span><br><span class="line">字符串空判断：</span><br><span class="line"></span><br><span class="line">- &#96;[ str ]&#96;: 测试字符串是否不为空，&lt;font color&#x3D;red&gt;[]中间必须带空格&lt;&#x2F;font&gt;</span><br><span class="line">- &#96;test -n str&#96;: 测试字符串是否不为空</span><br><span class="line">- &#96;test -z str&#96;: 测试字符串是否为空</span><br><span class="line">- &#96;[ str1 &#x3D; str2 ]&#96;: 是否相等，&lt;font color&#x3D;red&gt;[]中间必须带空格&lt;&#x2F;font&gt;</span><br><span class="line"></span><br><span class="line">数字：</span><br><span class="line"></span><br><span class="line">- &#96;[ num1 -eq num2 ]&#96;： 测试是否相等</span><br><span class="line">- &#96;[ num1 -ne num2 ]&#96;： 不等</span><br><span class="line">- &#96;[ num1 -ge num2 ]&#96;： &gt;&#x3D;</span><br><span class="line">- &#96;[ num1 -gt num2 ]&#96;： &gt;</span><br><span class="line">- &#96;[ num1 -le num2 ]&#96;： &lt;&#x3D;</span><br><span class="line">- &#96;[ num1 -lt num2 ]&#96;： &lt;</span><br><span class="line"></span><br><span class="line">文件：</span><br><span class="line"></span><br><span class="line">- &#96;test -d file&#96;：是否是目录</span><br><span class="line">- &#96;test -f file&#96;：是否是普通文件</span><br><span class="line">- &#96;test -e file&#96;：文件是否存在</span><br><span class="line">- &#96;test -L file&#96;：是否是链接</span><br><span class="line">- &#96;test -r file&#96;：是否可读</span><br><span class="line">- &#96;test -w file&#96;：是否可写</span><br><span class="line">- &#96;test -x file&#96;：是否可执行</span><br><span class="line"></span><br><span class="line"># 5.流程语句 if （06.sh）</span><br><span class="line"></span><br><span class="line">有两种方式:</span><br></pre></td></tr></table></figure><p>if [ 表达式 ]; then</p><p>if [ 表达式 ]<br>then</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="判断有没有输入"><a href="#判断有没有输入" class="headerlink" title="判断有没有输入"></a>判断有没有输入</h1><p>if [ -z $1 ]<br>then<br>    # echo “usage：./build_ogre.sh [build_type]”<br>        # echo “build_type: Release or Debug (must have)”<br>    # exit<br>    error<br>fi</p><h1 id="需要用户去指定编译-Debug-还是-Release"><a href="#需要用户去指定编译-Debug-还是-Release" class="headerlink" title="需要用户去指定编译 Debug 还是 Release"></a>需要用户去指定编译 Debug 还是 Release</h1><p>CMAKE_BUILD_TYPE=””<br>if [ “Debug” = $1 ]; then<br>    CMAKE_BUILD_TYPE=”Debug”<br>elif [ “Release” = $1 ]; then<br>    CMAKE_BUILD_TYPE=”Release”<br>else<br>    error arm<br>fi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 6.自定义函数(06.sh)</span><br><span class="line"></span><br><span class="line">- 函数需要先定义再使用,&#96;function和()必须有其一&#96;</span><br><span class="line">- 可以直接采用方法名调用,不用加()</span><br><span class="line">- $1 参数不是代表的脚本参数，而是方法传递过来的参数</span><br></pre></td></tr></table></figure><p>// function和()可以只有一个<br>function error(){<br>    echo “usage：./build_ogre.sh [build_type]”<br>        echo “build_type: Release or Debug (must have)”<br>    # 函数需要穿参数 arm $1 参数不是代表的脚本参数，而是方法传递过来的参数<br>    echo “$1 = $1”<br>        exit<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 7.流程语句 for、while、case （06.sh）</span><br><span class="line"></span><br><span class="line">for:</span><br></pre></td></tr></table></figure><p>for((i=0;i&lt;10;i++))<br>do<br>echo $i<br>done</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">while:</span><br></pre></td></tr></table></figure><p>sum=0<br>i=1<br>while(($i&lt;=100))<br>do<br>    sum=$(($sum+$i))<br>    i=$(($i+1))<br>done<br>echo “sum = $sum”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">case:</span><br></pre></td></tr></table></figure><p>case $2 in<br>start)<br>    echo “start service”<br>    ;;<br>stop)<br>    echo “stop service”<br>    ;;<br>*)<br>    echo “invalid command”<br>    echo “Usage:{start|stop}”<br>esac</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 8.输出重定向(07.sh)</span><br><span class="line"></span><br><span class="line">&#96;0:&#96; 标准输入,&#96;1&#96;：标准输出 &#96;2&#96;：标准错误输出</span><br><span class="line"></span><br><span class="line">- &#96;echo &quot;Hello Shell!&quot; &gt; log.txt&#96; &#x2F;&#x2F; 输出日志到 log.txt 中，&#96;&gt;&#96; 代表重新生成</span><br><span class="line">- &#96;echo &quot;Hello Shell!&quot; &gt;&gt; log.txt&#96; &#x2F;&#x2F; 输出日志到 log.txt 中，&#96;&gt;&gt;&#96; 代表追加</span><br><span class="line">- &#96;exec 1&gt;log.txt&#96;：标准的所有输出，&#96;重新生成&#96;全部添加到log.txt中</span><br><span class="line">- &#96;exec 2&gt;&gt;log.txt&#96;：标准的错误输出，全部&#96;追加&#96;到log.txt中</span><br></pre></td></tr></table></figure><h1 id="永久重定向-echo-标准输入：0-标准输出：1-标准错误：2"><a href="#永久重定向-echo-标准输入：0-标准输出：1-标准错误：2" class="headerlink" title="永久重定向  echo 标准输入：0 标准输出：1 标准错误：2"></a>永久重定向  echo 标准输入：0 标准输出：1 标准错误：2</h1><p>exec 1&gt;log.txt<br>exec 2&gt;&gt;log.txt</p><h1 id="gt-gt-代表追加，-gt-代表重新生成"><a href="#gt-gt-代表追加，-gt-代表重新生成" class="headerlink" title="&gt;&gt; 代表追加，&gt; 代表重新生成"></a>&gt;&gt; 代表追加，&gt; 代表重新生成</h1><h1 id="临时重定向"><a href="#临时重定向" class="headerlink" title="临时重定向"></a>临时重定向</h1><h1 id="echo-“Hello-Shell-”-gt-log-txt"><a href="#echo-“Hello-Shell-”-gt-log-txt" class="headerlink" title="echo “Hello Shell!” &gt; log.txt"></a>echo “Hello Shell!” &gt; log.txt</h1><h1 id="echo-“Hello-Shell-”-gt-gt-log-txt"><a href="#echo-“Hello-Shell-”-gt-gt-log-txt" class="headerlink" title="echo “Hello Shell!” &gt;&gt; log.txt"></a>echo “Hello Shell!” &gt;&gt; log.txt</h1><p>echo “Hello Shell”<br>echo “Hello Shell”<br>echo “Hello Shell”</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-shell-脚本创建与执行-01-sh&quot;&gt;&lt;a href=&quot;#1-shell-脚本创建与执行-01-sh&quot; class=&quot;headerlink&quot; title=&quot;1.shell 脚本创建与执行(01.sh)&quot;&gt;&lt;/a&gt;1.shell 脚本创建与执行(01.sh)
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：09.Cmake语法-详解CmakeLists.txt</title>
    <link href="http://eastup.github.io/80.Cmake%E8%AF%AD%E6%B3%95-%E8%AF%A6%E8%A7%A3CmakeLists.txt/"/>
    <id>http://eastup.github.io/80.Cmake%E8%AF%AD%E6%B3%95-%E8%AF%A6%E8%A7%A3CmakeLists.txt/</id>
    <published>2020-08-09T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:48.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-初试-CMake-的-HelloWorld"><a href="#1-初试-CMake-的-HelloWorld" class="headerlink" title="1.初试 CMake 的 HelloWorld"></a>1.初试 CMake 的 HelloWorld</h1><p>注意：<code>PROJECT、这些不区分大小写</code>，但是<code>${HELLO_BINARY_DIR}这些，必须大写</code></p><ul><li><code>PROJECT(HELLO)</code>：给工程取一个名字</li><li><code>SET(SRC_LIST hello.cpp)</code>：定义一个变量</li><li><code>MESSAGE(STATUS &quot;this is BINARY dir &quot;${HELLO_BINARY_DIR})</code>：打印</li><li><code>ADD_EXECUTABLE(hello.out ${SRC_LIST})</code>：生成可执行文件</li></ul><ol><li><p>新建<code>CMakeLists.txt</code>文件，编写以下内容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 给工程取一个名字</span><br><span class="line">PROJECT(HELLO)</span><br><span class="line"></span><br><span class="line"># 定义一个变量</span><br><span class="line">SET(SRC_LIST hello.cpp)</span><br><span class="line"></span><br><span class="line"># 打印</span><br><span class="line">MESSAGE(STATUS &quot;this is BINARY dir &quot;$&#123;HELLO_BINARY_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1&#x2F;build</span><br><span class="line">MESSAGE(STATUS &quot;this is SOURCE dir &quot;$&#123;HELLO_SOURCE_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1</span><br><span class="line">MESSAGE(STATUS &quot;this is PROJECT_SOURCE dir &quot;$&#123;PROJECT_SOURCE_DIR&#125;) &#x2F;&#x2F; dir&#x2F;home&#x2F;keanu&#x2F;jamin&#x2F;NDK80&#x2F;t1</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">ADD_EXECUTABLE(hello.out $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在同目录下创建 build 文件夹,进入执行 <code>cmake ..</code> ..代表CMakeLists.txt在上一级目录</p></li><li><p>最后在build目录中，执行 <code>make</code></p></li></ol><h1 id="2-构建生成-so-动态库"><a href="#2-构建生成-so-动态库" class="headerlink" title="2.构建生成 .so 动态库"></a>2.构建生成 .so 动态库</h1><p>目的：把src里的源文件，生成<code>libmath.so</code>动态库，动态库的存储路径在lib目录下</p><ul><li><code>CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</code>:指定 CMake 的最低编译版本</li><li><code>AUX_SOURCE_DIRECTORY(${PROJECT_SOURCE_DIR}/src SRC_LIST)</code>：搜集 src 目录下的所有源文件，并赋值为SRC_LIST</li><li><code>FILE(GLOB SRC_LIST &quot;${PROJECT_SOURCE_DIR}/src/*&quot;)</code>：搜集 src 目录下的所有源文件，并赋值为SRC_LIST</li><li><code>INCLUDE_DIRECTORIES(${PROJECT_SOURCE_DIR}/include)</code>：指定头文件在哪个目录</li><li><code>SET (LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)</code>：指定 so 的生成目录 lib</li><li><code>ADD_LIBRARY (math SHARED ${SRC_LIST_CPP} ${SRC_LIST_C})</code>：指定生成动态库 .so， <code>math</code> 生成的so名字为 <code>libmath.so</code> 如果默认生成的是静态库.a，加入SHARED才会生成动态库.so</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 指定 CMake 的最低编译版本</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</span><br><span class="line"></span><br><span class="line"># 给工程取名字</span><br><span class="line">PROJECT(MATH)</span><br><span class="line"></span><br><span class="line"># 搜集 src 目录下的所有源文件，有AUX_SOURCE_DIRECTORY和FILE 两种方式</span><br><span class="line"># AUX_SOURCE_DIRECTORY($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src SRC_LIST)</span><br><span class="line"># FILE(GLOB SRC_LIST &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.cpp&quot; &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.c&quot;)</span><br><span class="line">FILE(GLOB SRC_LIST_CPP &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.cpp&quot;)</span><br><span class="line">FILE(GLOB SRC_LIST_C &quot;$&#123;PROJECT_SOURCE_DIR&#125;&#x2F;src&#x2F;*.c&quot;)</span><br><span class="line"></span><br><span class="line"># MESSAGE (STATUS &quot;src_list : &quot;$&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 指定头文件在哪个目录</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)</span><br><span class="line"></span><br><span class="line"># 指定 so 的生成目录 lib</span><br><span class="line">SET (LIBRARY_OUTPUT_PATH $&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)</span><br><span class="line"></span><br><span class="line"># 指定生成动态库 .so math -&gt; libmath.so 如果默认生成的是静态库.a，加入SHARED才会生成动态库.so</span><br><span class="line">ADD_LIBRARY (math SHARED $&#123;SRC_LIST_CPP&#125; $&#123;SRC_LIST_C&#125;)</span><br></pre></td></tr></table></figure><h1 id="3-链接外部动态库与头文件"><a href="#3-链接外部动态库与头文件" class="headerlink" title="3.链接外部动态库与头文件"></a>3.链接外部动态库与头文件</h1><ul><li><code>LINK_DIRECTORIES (${PROJECT_SOURCE_DIR}/lib)</code>：<font color="red">官方不推荐使用，有时候会找不到引用。经过尝试，so库放在jniLibs下的时候可以编译成功</font>链接 lib 目录下的 libmath.so,指定 so 在哪个目录下，</li><li><code>TARGET_LINK_LIBRARIES (hello math)</code>：为 hello 添加编译链接库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 指定 CMake 的最低编译版本</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.14)</span><br><span class="line"></span><br><span class="line"># ...</span><br><span class="line">PROJECT (HELLO)</span><br><span class="line"></span><br><span class="line"># 指定头文件在哪个目录</span><br><span class="line">INCLUDE_DIRECTORIES ($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;include)</span><br><span class="line"></span><br><span class="line"># 编译是需要链接 lib 目录下的 libmath.so</span><br><span class="line"># 指定 so 在哪个目录下，so库放在jniLibs下的时候才可以编译成功</span><br><span class="line">LINK_DIRECTORIES ($&#123;PROJECT_SOURCE_DIR&#125;&#x2F;lib)</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">ADD_EXECUTABLE (hello hello.cpp)</span><br><span class="line"></span><br><span class="line"># 为 hello 添加编译链接库</span><br><span class="line">TARGET_LINK_LIBRARIES (hello math)</span><br></pre></td></tr></table></figure><h1 id="4-根据不同的源文件夹生成不同的-so-文件"><a href="#4-根据不同的源文件夹生成不同的-so-文件" class="headerlink" title="4. 根据不同的源文件夹生成不同的 .so 文件"></a>4. 根据不同的源文件夹生成不同的 .so 文件</h1><p>1.则需要在顶层目录下创建CMakeLists.txt，内容如下</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_subdirectory(src)</span><br></pre></td></tr></table></figure></code></pre><ol start="2"><li>然后在 src 中再创建一个CMakeLists.txt，内容就是上边生成.so文件的内容  </li><li>在顶层目录下创建 build 文件夹，执行<code>cmake ..</code> ,<code>make</code> 的指令  </li><li>如果不指定生成的so位置，最后生成的.so文件默认在<code>build/‘源文件的目录’</code>中   </li></ol><h1 id="5-修改以前-ffmpeg-开发项目中的-CMakeLists-txt"><a href="#5-修改以前-ffmpeg-开发项目中的-CMakeLists-txt" class="headerlink" title="5.修改以前 ffmpeg 开发项目中的 CMakeLists.txt"></a>5.修改以前 ffmpeg 开发项目中的 CMakeLists.txt</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 指定最低版本名称</span><br><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"># 指定引入头文件目录</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;include)</span><br><span class="line">INCLUDE_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;other)</span><br><span class="line"></span><br><span class="line"># 指定共享库的库目录，so库放在jniLibs下的时候才可以编译成功</span><br><span class="line">LINK_DIRECTORIES($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jniLibs&#x2F;armeabi)</span><br><span class="line"></span><br><span class="line"># 指定源文件的目录</span><br><span class="line">AUX_SOURCE_DIRECTORY($&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;cpp SRC_LIST)</span><br><span class="line"></span><br><span class="line"># 生成 native-lib</span><br><span class="line">ADD_LIBRARY(native-lib SHARED $&#123;SRC_LIST&#125;)</span><br><span class="line"></span><br><span class="line"># 为 native-lib 添加 ffmpeg 编译链接库</span><br><span class="line">TARGET_LINK_LIBRARIES(native-lib  </span><br><span class="line">avcodec-56 </span><br><span class="line">avdevice-56 </span><br><span class="line">avfilter-5 </span><br><span class="line">avformat-56 </span><br><span class="line">avutil-54 </span><br><span class="line">postproc-53 </span><br><span class="line">swresample-1 </span><br><span class="line">swscale-3 </span><br><span class="line">-landroid </span><br><span class="line">-llog)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-初试-CMake-的-HelloWorld&quot;&gt;&lt;a href=&quot;#1-初试-CMake-的-HelloWorld&quot; class=&quot;headerlink&quot; title=&quot;1.初试 CMake 的 HelloWorld&quot;&gt;&lt;/a&gt;1.初试 CMake 的 Hell
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：08.Cmake语法-makefile、cmake、shell 自动编译和链接</title>
    <link href="http://eastup.github.io/79.Cmake%E8%AF%AD%E6%B3%95-makefile%E3%80%81cmake%E3%80%81shell%20%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    <id>http://eastup.github.io/79.Cmake%E8%AF%AD%E6%B3%95-makefile%E3%80%81cmake%E3%80%81shell%20%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</id>
    <published>2020-08-08T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:42.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-makefile、cmake-与-shell-之间的联系"><a href="#1-makefile、cmake-与-shell-之间的联系" class="headerlink" title="1.makefile、cmake 与 shell 之间的联系"></a>1.makefile、cmake 与 shell 之间的联系</h1><ul><li><p>makefile ： 帮助我们管理编译项目   </p></li><li><p>cmake：是一个跨平台的安装（编译）工具，可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的 Makefile 或者 project 文件，CMake 并不直接建构出最终的软件，而是产生标准的建构档（如 Makefile 或 projects）。</p></li><li><p>shell 脚本：一系列命令和语法</p></li></ul><h1 id="2-makefile-自动编译和链接"><a href="#2-makefile-自动编译和链接" class="headerlink" title="2.makefile 自动编译和链接"></a>2.makefile 自动编译和链接</h1><h2 id="2-1-gcc-如何编译相互依赖，却没直接引入的文件"><a href="#2-1-gcc-如何编译相互依赖，却没直接引入的文件" class="headerlink" title="2.1 gcc 如何编译相互依赖，却没直接引入的文件"></a>2.1 gcc 如何编译相互依赖，却没直接引入的文件</h2><p>Android.mk  Application.mk </p><p><code>gcc hello.cpp div.cpp sub.cpp add.cpp -o hello</code>// hello.cpp 中并没引入 div.cpp等文件，但是这样编译会自动找寻到依赖的文件</p><p>gcc 四步骤：生成 .o 文件比较耗时（<code>汇编阶段</code>）</p><p>上面的编译步骤其实就是省略了编译四步骤，假设现在我改了一个文件，需要重新编译，那么每次都会重新生成 .o 文件，因此需要把上面的步骤进行拆分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -c sub.cpp -o sub.o</span><br><span class="line">gcc -c add.cpp -o add.o</span><br><span class="line">gcc -c div.cpp -o div.o</span><br><span class="line">gcc -c hello.cpp -o hello.o</span><br><span class="line">gcc add.o sub.o div.o hello.o -o hello</span><br></pre></td></tr></table></figure><p>这样如何只修改了 sub.cpp ，就只需要重新生成 sub.o 文件，然后重新生成最终的可执行文件</p><h2 id="2-2-如何编写Makefile文件"><a href="#2-2-如何编写Makefile文件" class="headerlink" title="2.2 如何编写Makefile文件"></a><font color="red">2.2 如何编写Makefile文件</font></h2><p>执行 Makefile 文件，只需要在Makefile 的目录下 执行<code>make</code>指令就行</p><h3 id="2-2-1-一个规则（观看makefile、cmake、shell目录下的m1）"><a href="#2-2-1-一个规则（观看makefile、cmake、shell目录下的m1）" class="headerlink" title="2.2.1. 一个规则（观看makefile、cmake、shell目录下的m1）"></a>2.2.1. 一个规则（观看makefile、cmake、shell目录下的m1）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">目标：依赖条件</span><br><span class="line">（一个tab缩进） 命令</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">hello.out:hello.o sub.o add.o div.o</span><br><span class="line">gcc hello.o sub.o add.o div.o -o hello.out</span><br><span class="line">div.o:div.cpp</span><br><span class="line">gcc -c div.cpp -o div.o</span><br></pre></td></tr></table></figure><p><code>默认情况下只会执行 MakeFile 中的第一个命令。</code></p><ol><li><p>但若想生成目标文件，则会检查命令中的依赖是否存在，如果不存在就会往下查找是否有生成该依赖条件的命令，如有就会执行生成依赖再生成目标文件。</p></li><li><p>会检测规则中的目标是否需要更新，必须先检测它的依赖性（通过更新时间判断），只需要重新生成依赖中被修改的依赖，然后再更新目标文件</p></li></ol><h3 id="2-2-2-两个函数（观看makefile、cmake、shell目录下的m2）"><a href="#2-2-2-两个函数（观看makefile、cmake、shell目录下的m2）" class="headerlink" title="2.2.2. 两个函数（观看makefile、cmake、shell目录下的m2）"></a>2.2.2. 两个函数（观看makefile、cmake、shell目录下的m2）</h3><ol><li><code>src = $(wildcard *.cpp)</code>　// 找到当前目录下所有后缀为.cpp的文件，然后赋值给src <code>$(src) 取变量src的值</code></li><li><code>obj = $(patsubst %cpp,%o,$(src))</code>　//把src变量中所有后缀为.cpp的文件替换成.o文件 <code>$(obj) 取变量obj的值</code></li></ol><p>make clean -n 注意加上 -n 预执行</p><p>make clean 执行 clean 命令</p><p>如果目录下有 clean 文件夹，则会有冲突，这时只需要生成伪目标就行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">src &#x3D; $(wildcard *.cpp)</span><br><span class="line">obj &#x3D; $(patsubst %cpp,%o,$(src))</span><br><span class="line"></span><br><span class="line"># 默认情况下只会执行第一个</span><br><span class="line">hello.out:$(obj)</span><br><span class="line">gcc $(obj) -o hello.out</span><br><span class="line"></span><br><span class="line">div.o:div.cpp</span><br><span class="line">gcc -c div.cpp -o div.o</span><br><span class="line"></span><br><span class="line">add.o:add.cpp</span><br><span class="line">gcc -c add.cpp -o add.o</span><br><span class="line"></span><br><span class="line">sub.o:sub.cpp</span><br><span class="line">gcc -c sub.cpp -o sub.o</span><br><span class="line"></span><br><span class="line">hello.o:hello.cpp</span><br><span class="line">gcc -c hello.cpp -o hello.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># $(xxx) 取变量的值</span><br><span class="line">clean:</span><br><span class="line">rm -rf $(obj) hello.out</span><br><span class="line"></span><br><span class="line"># 生成伪目标</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure><h3 id="2-2-3-三个自动变量（观看makefile、cmake、shell目录下的m3）"><a href="#2-2-3-三个自动变量（观看makefile、cmake、shell目录下的m3）" class="headerlink" title="2.2.3. 三个自动变量（观看makefile、cmake、shell目录下的m3）"></a>2.2.3. 三个自动变量（观看makefile、cmake、shell目录下的m3）</h3><p>多行注释 <code>:&#39;</code></p><ul><li>$@：表示规则中的目标</li><li>$^：表示规则中所有的依赖条件,组成一个列表，以空格隔开，如果这个列表有重复项则消除重复项</li><li>$&lt;：表示规则中的第一个依赖条件，如果运行在模式套用中，相当于取出依赖条件套用在该模式中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">src &#x3D; $(wildcard *.cpp)</span><br><span class="line">obj &#x3D; $(patsubst %cpp,%o,$(src))</span><br><span class="line"></span><br><span class="line"># 默认情况下只会执行第一个</span><br><span class="line">hello.out:$(obj)</span><br><span class="line">gcc $^ -o $@ </span><br><span class="line"></span><br><span class="line">:&#39;</span><br><span class="line">div.o:div.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">add.o:add.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">sub.o:sub.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">hello.o:hello.cpp</span><br><span class="line">gcc -c $&lt; -o $@</span><br><span class="line">:&#39;</span><br><span class="line"># 模式规则</span><br><span class="line"># gcc -c $(src) -o $(obj)</span><br><span class="line">%o:%cpp</span><br><span class="line">gcc -c $&lt; -o $@ </span><br><span class="line"></span><br><span class="line"># $(xxx) 取变量的值</span><br><span class="line">clean:</span><br><span class="line">rm -rf $(obj) hello.out</span><br><span class="line"></span><br><span class="line"># 生成伪目标</span><br><span class="line">.PHONY: clean</span><br></pre></td></tr></table></figure><h1 id="3-cmake简介和安装"><a href="#3-cmake简介和安装" class="headerlink" title="3.cmake简介和安装"></a>3.<a href="https://www.jianshu.com/p/528eeb266f83" target="_blank" rel="noopener">cmake简介和安装</a></h1><p>写 CMakeLists.txt 里面用 CMake 语法写，会帮我们生成 Makefile 用于编译管理项目</p><p><a href="https://blog.csdn.net/qq_27525611/article/details/104651517" target="_blank" rel="noopener">安装：</a></p><ol><li>去<a href="https://cmake.org/download/" target="_blank" rel="noopener">官网</a> 下载cmake的最新linux版本，这里下载的是<code>cmake-3.18.3.tar.gz</code></li><li><code>拷贝</code>到linux系统的 <code>/lib</code>目录下<code>新建的cmake目录</code>并<code>解压</code>,需要root权限</li><li>cd到解压后的cmake目录中运行<code>sudo ./bootstrap</code>命令进行安装</li><li>安装完成执行<code>sudo make</code></li><li>最后执行<code>sudo make install</code></li><li>可以在任一位置 使用<code>cmake --version</code> 查看安装的版本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果不能在任一位置 使用&#96;cmake --version&#96; 查看安装的版本,则配置环境变量</span><br><span class="line"></span><br><span class="line">配置环境变量 vim &#x2F;etc&#x2F;profile</span><br><span class="line">文件最后面输入：</span><br><span class="line">export CMAKE_PATH&#x3D;&#x2F;lib&#x2F;cmake&#x2F;cmake-3.18.3&#x2F;bin</span><br><span class="line">export PATH&#x3D;$CMAKE_PATH:$PATH</span><br><span class="line">使环境变量生效 source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure><p>安装问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">有的会出现没安装 make的情况,使用以下命令</span><br><span class="line">sudo apt-get install make</span><br><span class="line"></span><br><span class="line">Could not find OpenSSL.  Install an OpenSSL development package or</span><br><span class="line">  configure CMake with -DCMAKE_USE_OPENSSL&#x3D;OFF to build without OpenSSL.</span><br><span class="line"></span><br><span class="line">解决：sudo apt-get install libssl-dev</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Error when bootstrapping CMake:</span><br><span class="line">Cannot find a C++ compiler that supports both C++11 and the specified C++ flags.</span><br><span class="line"></span><br><span class="line">1.没有装gcc 和 g++。使用 sudo apt-get install g++ 安装</span><br><span class="line"></span><br><span class="line">2. gcc 或者 g++ 版本过低，需要安装高版本的。升级风险较大，可以采用新的编译环境安装新版本的 gcc和g++ 。</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/jiangjiang_jian/article/details/80694799" target="_blank" rel="noopener">gcc升级</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ubuntu-toolchain-r&#x2F;test</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo apt-get install gcc-7 g++-7</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/uestc-mm/p/7511063.html" target="_blank" rel="noopener">升级后切换 gcc 和 g++ 版本</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">你在安装完之后可以采用下面的指令来查看当前系统中安装的所有的gcc和g++的版本：</span><br><span class="line">ls &#x2F;usr&#x2F;bin&#x2F;gcc*</span><br><span class="line">ls &#x2F;usr&#x2F;bin&#x2F;g++*</span><br><span class="line"></span><br><span class="line">将gcc-6加入gcc候选中，最后的数字是优先级，我自己是直接设为100（测试没有问题）</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;gcc gcc &#x2F;usr&#x2F;bin&#x2F;gcc-6 100</span><br><span class="line">sudo update-alternatives --install &#x2F;usr&#x2F;bin&#x2F;g++ g++ &#x2F;usr&#x2F;bin&#x2F;g++-6 100</span><br><span class="line"></span><br><span class="line">完成上面的操作之后，我们就可以通过下面的指令来选择不同的gcc和g++的版本了</span><br><span class="line">sudo update-alternatives --config gcc</span><br><span class="line">sudo update-alternatives --config g++</span><br><span class="line"></span><br><span class="line">注意一个问题：</span><br><span class="line">  当切换使用了其他版本的gcc时，请务必保持g++的版本和gcc版本的一致性，否则用cmake配置出来的项目遇到c++代码还是会用之前版本的gcc。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-makefile、cmake-与-shell-之间的联系&quot;&gt;&lt;a href=&quot;#1-makefile、cmake-与-shell-之间的联系&quot; class=&quot;headerlink&quot; title=&quot;1.makefile、cmake 与 shell 之间的联系&quot;&gt;
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：07.linux系统-线程和多线程同步</title>
    <link href="http://eastup.github.io/78.linux%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>http://eastup.github.io/78.linux%E7%B3%BB%E7%BB%9F-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2020-08-07T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:40.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-线程的本质"><a href="#1-线程的本质" class="headerlink" title="1.线程的本质"></a>1.线程的本质</h1><p>线程与进程的区别：线程大家可以简单理解为一个轻量级的进程，线程共享了栈和堆（变量），没有复制 0-3 G 的进程空间，<br>但线程会有自己的工作空间，会有自己的 pcb 块。跟 Java 是类似的。</p><ol><li>linux线程执行和windows不同，pthread有两种状态<code>joinable</code>状态和<code>unjoinable</code>状态，<br>如果线程是<code>joinable</code>状态，当<code>线程函数自己返回退出时或pthread_exit</code>时都不会释放线程所占用堆栈和线程描述符（总计8K多）。只有当你调用了<code>pthread_join</code>之后这些资源才会被释放。<br>若是<code>unjoinable</code>状态的线程，这些资源在<code>线程函数退出时或pthread_exit时</code>自动会被释放。</li><li><code>unjoinable</code>属性可以在<code>pthread_create时指定</code>，或在线程创建后在线程中pthread_detach自己, 如：<code>pthread_detach(pthread_self())，将状态改为unjoinable状态</code>，确保资源的释放。或者将线程置为 joinable,然后适时调用pthread_join.</li><li>其实简单的说就是在线程函数头加上 pthread_detach(pthread_self())的话，线程状态改变，在函数尾部直接 pthread_exit线程就会自动退出。省去了给线程擦屁股的麻烦。</li></ol><h1 id="2-创建线程"><a href="#2-创建线程" class="headerlink" title="2.创建线程"></a>2.创建线程</h1><p><code>pthread_create(&amp;tid,NULL,thread_run,NULL);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am a thread\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="3-退出线程"><a href="#3-退出线程" class="headerlink" title="3.退出线程"></a>3.退出线程</h1><p><code>pthread_exit(-1);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">        pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,(<span class="keyword">void</span>*)i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="4-回收线程"><a href="#4-回收线程" class="headerlink" title="4.回收线程"></a>4.回收线程</h1><p><code>pthread_join(tid,&amp;retval); // retval = 0代表回收成功，-1 代表线程已经退出了</code></p><p>pthread_join()即是子线程合入主线程，<code>主线程阻塞等待子线程结束</code>，然后回收子线程资源。</p><p>pthread_join()函数，<code>以阻塞的方式</code>等待thread指定的线程结束。当函数返回时，<code>被等待线程的资源被收回</code>。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。</p><p>一般情况下需要回收线程，retval 用来接收线程的返回值，tid 是线程的id，该方法会阻塞等待<br>什么情况下不需要回收呢？除非调用了分离线程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    pthread_join(tid,&amp;retval);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    <span class="comment">// sleep(1);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="5-杀死（取消）线程"><a href="#5-杀死（取消）线程" class="headerlink" title="5.杀死（取消）线程"></a>5.杀死（取消）线程</h1><p><code>pthread_cancel(tid);</code> // 取消线程需要有函数进入内核，也就是说需要调用系统函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 循环里面是空的，则会卡死，线程不会取消，原因是取消线程需要有函数进入内核</span></span><br><span class="line">            <span class="comment">// printf("i am a thread，no = %d\n",no);</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 实在没什么写的，又想线程能够取消，可以调下面这个方法</span></span><br><span class="line">            pthread_testcancel();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line">    pthread_join(tid,&amp;retval);<span class="comment">// 返回值是 -1 ,表示被干掉或者退出的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="6-分离线程"><a href="#6-分离线程" class="headerlink" title="6.分离线程"></a>6.分离线程</h1><p><code>pthread_detach(tid);使线程ID为tid的线程处于分离状态，一旦线程处于分离状态，该线程终止时底 层资源立即被回收</code></p><p>分离线程之后是当线程执行完毕或者<code>pthread_exit</code>后，残留在线程中的资源会自动回收，也就是说线程需要回收，有两种方式一种是 join 一种是 detach 分离。</p><p><code>该函数不会阻塞父线程。pthread_detach(tid);函数用于只是应用程序在线程tid终止时回收其存储空间。如果tid尚未终止，pthread_detach()不会终止该线程。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 碰到 2 不打印</span></span><br><span class="line">        <span class="keyword">if</span>(no == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 退出线程</span></span><br><span class="line">                pthread_exit(<span class="number">-1</span>);</span><br><span class="line">                <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am a thread，no = %d\n"</span>,no);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void* 是可以任意类型，指针、变量都可以</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> no = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="built_in">print</span>(no);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 线程创建</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*int pthread_create(pthread_t *thread, const pthread_attr_t *attr,</span></span><br><span class="line"><span class="comment">                              void *(*start_routine) (void *), void *arg);*/</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid,<span class="literal">NULL</span>,thread_run,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 对线程进行分离</span></span><br><span class="line">    pthread_detach(tid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i am  main thread\n"</span>);</span><br><span class="line">    <span class="comment">// linux 中需要回收线程,等待回收</span></span><br><span class="line">    <span class="comment">/*int pthread_join(pthread_t thread, void **retval);*/</span></span><br><span class="line">    <span class="keyword">int</span> *retval;</span><br><span class="line">    pthread_join(tid,&amp;retval);<span class="comment">// 返回值是 -1 ,表示被干掉或者退出的线程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval = %d\n"</span>,retval);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译时调用 gcc thread1.cpp -o thread1 -lpthread  // -l 链接 pthread 的库</span></span><br></pre></td></tr></table></figure><h1 id="7-线程同步"><a href="#7-线程同步" class="headerlink" title="7.线程同步"></a>7.线程同步</h1><ul><li><code>pthread_mutex_t mutex</code></li><li>加锁：<code>pthread_mutex_lock(&amp;mutex);</code></li><li>解锁：<code>pthread_mutex_unlock(&amp;mutex);</code></li><li>销毁锁：<code>pthread_mutex_destroy(&amp;mutex);</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 加一个锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 加一个条件</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> product_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thread_run</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i=<span class="number">0</span>; i&lt;<span class="number">200000000</span>;i++)&#123;</span><br><span class="line">                <span class="comment">// 加锁</span></span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现加锁的出错的情况，应该是没有计算完毕</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成者与消费者（java要能手写）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                <span class="comment">// 1. 阻塞等待唤醒</span></span><br><span class="line">                <span class="comment">// 2. 释放锁</span></span><br><span class="line">                <span class="comment">// 3. 被唤醒，解除阻塞，需要重新竞争锁</span></span><br><span class="line">                <span class="comment">// 是一个 while 循环，等待有两种方式会被唤醒，一种是条件发信号，一种是系统（不正常）惊群效应</span></span><br><span class="line">                <span class="keyword">while</span>(number &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"等待生产者生成产品"</span>);</span><br><span class="line">                        pthread_cond_wait(&amp;product_cond, &amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"消费者消费产品: %ld\n"</span>,number);</span><br><span class="line">                number--;</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">producer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                pthread_mutex_lock(&amp;mutex);</span><br><span class="line">                number++;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"生成者生产产品: %ld\n"</span>,number);</span><br><span class="line">                <span class="comment">// 通知消费者消费</span></span><br><span class="line">                pthread_cond_signal(&amp;product_cond);</span><br><span class="line">                <span class="comment">// 解锁</span></span><br><span class="line">                pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">void</span>*)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 初始化锁</span></span><br><span class="line">        pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">        pthread_cond_init(&amp;product_cond,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        <span class="keyword">int</span> *retval;</span><br><span class="line">        <span class="comment">//for(int i=0; i&lt;4;i++)&#123;</span></span><br><span class="line">                <span class="comment">// 传的是同一个 id ，tid 没有赋值的，tid 是当做一个传出参数 0</span></span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">pthread_detach(tid);</span><br><span class="line">                pthread_create(&amp;tid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sleep(5);</span></span><br><span class="line">        <span class="comment">// 销毁锁</span></span><br><span class="line">        pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">        pthread_cond_destroy(&amp;product_cond);</span><br><span class="line">        <span class="comment">// 销毁条件</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"number = %ld\n"</span>, number);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-线程的本质&quot;&gt;&lt;a href=&quot;#1-线程的本质&quot; class=&quot;headerlink&quot; title=&quot;1.线程的本质&quot;&gt;&lt;/a&gt;1.线程的本质&lt;/h1&gt;&lt;p&gt;线程与进程的区别：线程大家可以简单理解为一个轻量级的进程，线程共享了栈和堆（变量），没有复制 0-3
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：06.linux系统-IPC进程间通信</title>
    <link href="http://eastup.github.io/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://eastup.github.io/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</id>
    <published>2020-08-06T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:14.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-进程间通信的方式"><a href="#1-进程间通信的方式" class="headerlink" title="1.进程间通信的方式"></a>1.进程间通信的方式</h1><p>文件，管道，信号、信号量，共享映射区（共享内存），消息队列，管道，套接字（socket）</p><p>着重讲下：</p><ul><li>管道（使用简单）</li><li>信号（开销比较小）</li><li><font color="red">共享映射区</font></li><li>套接字（低速稳定）</li></ul><p>一般都是通过内核共享空间进行通信</p><p><img src="/images/77.%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png" alt></p><h1 id="2-管道-pipe"><a href="#2-管道-pipe" class="headerlink" title="2.管道(pipe)"></a>2.管道(pipe)</h1><p><img src="/images/77.%E7%AE%A1%E9%81%93.png" alt><br><img src="/images/77.%E7%AE%A1%E9%81%93%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.png" alt></p><ol><li>无名管道，<font color="red">半双工的通信方式(数据流向固定：只能 a 的数据写给 b ，或者 b 的数据写给 a )</font></li><li>管道大家可以简单的理解为一种特殊的文件形式，我们可以用文件的读写方法，不是一种简单的文件，只会占用内存。</li><li>管道只能是有血缘关系的进程间通信</li><li>数据不能自己写自己读</li><li>数据一旦读走，不能再次读</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">pid_t</span>  pid;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// 创建管道</span></span><br><span class="line">    <span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create pipe error!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="comment">// 等等在读</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">read</span>(fd[<span class="number">0</span>],buf,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 没有其它读写操作了可以关闭 fd[0]</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pipe read : %s"</span>,buf);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>],<span class="string">"hello pipe\n"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="comment">// 没有其它读写操作了可以关闭 fd[1]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非法操作：</p><ol><li><p>读管道：<br> 1.1 管道中有数据，read 返回实际读到的数据</p><p> 1.2 管道中无数据：    </p><pre><code>1.2.1 管道写端被关闭，read 返回 01.2.2 管道写端如果没有被关闭，会阻塞等待</code></pre></li><li><p>写管道：<br> 2.1 读端被关闭，异常终止（信号导致）</p><p> 2.2 读端未关闭：</p><pre><code>2.2.1 管道数据已满，阻塞等待写入数据（其他人读走）2.2.2 管道未满，直接将数据写入</code></pre></li></ol><h1 id="3-共享映射区"><a href="#3-共享映射区" class="headerlink" title="3.共享映射区"></a><font color="red">3.共享映射区</font></h1><p><img src="/images/77.mmap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt></p><p>binder 驱动，腾讯 MMKV，xlog （日志库）中都会有 <code>mmap</code>函数</p><p>以下是binder驱动的流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1、注册建立ServiceManager表。</span><br><span class="line">2、Service1、Service2通过Binder驱动申请注册到ServiceManager中。</span><br><span class="line">3、Client需要与Service2进行通信,跨进程无法直接通信，需要先通过ServiceManger中查询到Service2。借助Binder驱动</span><br><span class="line">返回一个Service2的代理对象。Client直接跟Service2代理对象进行操作，通过Binder驱动映射操作Service2真实对象，从而完成通信。</span><br><span class="line"></span><br><span class="line">- Binder是一种通信机制；</span><br><span class="line">- 对于Service来说Binder指的是Binder本地对象，对于Client来说Binder指的是Binder的代理对象；</span><br><span class="line">- 对于传输过程而言，Binder是可以跨进程传递的对象。</span><br><span class="line"></span><br><span class="line">为什么要使用Binder？</span><br><span class="line">性能方面</span><br><span class="line"></span><br><span class="line">在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，</span><br><span class="line">更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。</span><br><span class="line"></span><br><span class="line">安全方面</span><br><span class="line"></span><br><span class="line">传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协</span><br><span class="line">议本身就支持对通信双方做身份校检，因而大大提升了安全性。</span><br></pre></td></tr></table></figure><p>mmap 注意事项  </p><ol><li>指定映射区的大小，必须要小于文件大小</li><li>映射区大小必须要大于 0 ，否则会异常</li><li>创建映射区需要 read 权限，mmap 的读写权限应该 &lt;= 文件的权限</li><li>文件可以先关闭</li><li>偏移量必须是 4k 的整数倍</li><li>MAP_PRIVATE 只会对内存进行修改，不会反应到磁盘上</li></ol><p>mmap 万能调用方法：<br>open(O_RDWR);<br>mmap(NULL, 有效大小，PROT_READ|PROT_WRITE,MAP_SHARED,fd,0)  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * msg)</span></span>&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*void *mmap(void *addr, size_t length, int prot, int flags,</span></span><br><span class="line"><span class="comment">              int fd, off_t offset);</span></span><br><span class="line"><span class="comment">   int munmap(void *addr, size_t length);*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *  addr：地址，一般可以不传（NULL），传入传出参数</span></span><br><span class="line"><span class="comment">     *  length：内存大小</span></span><br><span class="line"><span class="comment">     *  prot：</span></span><br><span class="line"><span class="comment">     *       PROT_EXEC 内容可以被执行</span></span><br><span class="line"><span class="comment">     *       PROT_READ 内容可以被读取</span></span><br><span class="line"><span class="comment">     *       PROT_WRITE 内容可以被写</span></span><br><span class="line"><span class="comment">     *       PROT_NONE 内容不可访问</span></span><br><span class="line"><span class="comment">     *  flags:</span></span><br><span class="line"><span class="comment">     *       MAP_SHARED 共享</span></span><br><span class="line"><span class="comment">     *       MAP_PRIVATE 私有f</span></span><br><span class="line"><span class="comment">     *       MAP_ANONYMOUS 匿名映射（不基于文件）,fd 参数就传 -1</span></span><br><span class="line"><span class="comment">     *  fd: 文件句柄</span></span><br><span class="line"><span class="comment">     *  offset：偏移大小，必须是 4K 的整数倍，一个物理页映射是 4K。     </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 创建打开一个文件</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">"test_map"</span>,O_ROWR|O_CREAT|O_TRUNC,<span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)&#123;</span><br><span class="line">        sys_err(<span class="string">"open file error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件变大（不增大的话，映射的是 0）</span></span><br><span class="line">    ftruncate(fd,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    p = (<span class="keyword">char</span>*)mmap(<span class="literal">NULL</span>,<span class="number">20</span>, PROT_READ|PROT_WRITE,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭了文件，那么后面通过操作 mmap 的空间，能不能写入文件? 能</span></span><br><span class="line">    <span class="built_in">close</span>(fd);<span class="comment">// 关闭的是系统函数到文件的操作，而 mmap 映射不受影响</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p == MAP_FAILED)&#123;</span><br><span class="line">        sys_err(<span class="string">"mmap error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"hello mmap\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---&gt;%s"</span>,p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放 mmap</span></span><br><span class="line">    munmap(p,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有示例请可以看<a href="https://github.com/EastUp/CPractice/tree/master/linux/77.linux%E7%B3%BB%E7%BB%9F-IPC%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">这儿</a></p><h1 id="4-信号"><a href="#4-信号" class="headerlink" title="4.信号"></a>4.信号</h1><p>进程间通信的机制，内核自带的，信号不能携带大量的数据，一般就是一个数字，只有在特定场景下才调用。</p><p>怎样才会产生信号：</p><ol><li>按键产生: ctrl + c, ctrl+z</li><li>系统调用 kill ， raise， abort</li><li>软件条件产生， alarm</li><li>硬件异常产生，非法访问内存，除 0 ，内存对齐等等</li><li>命令产生</li></ol><p>信号的处理方式：</p><ol><li>忽略此信号</li><li>执行系统默认动作</li><li>捕捉用户希望动作</li></ol><p>信号处理的原理：  </p><ul><li>信号屏蔽字: 用于屏蔽x信号，内部实现就是一个集合，当 x 信号屏蔽后，再收到该信号，信号处理将推后</li><li>未决信号集: 信号抵达 x 信号位反转为 1 ， 当信号被处理后重新置为 0 </li></ul><p><code>man 7 signal</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">       Signal     Value     Action   Comment</span><br><span class="line">       ──────────────────────────────────────────────────────────────────────</span><br><span class="line">       SIGHUP        1       Term    Hangup detected on controlling terminal</span><br><span class="line">                                     or death of controlling process</span><br><span class="line">       SIGINT        2       Term    Interrupt from keyboard</span><br><span class="line">       SIGQUIT       3       Core    Quit from keyboard</span><br><span class="line">       SIGILL        4       Core    Illegal Instruction</span><br><span class="line">       SIGABRT       6       Core    Abort signal from abort(3)</span><br><span class="line">       SIGFPE        8       Core    Floating point exception</span><br><span class="line">       SIGKILL       9       Term    Kill signal</span><br><span class="line">       SIGSEGV      11       Core    Invalid memory reference</span><br><span class="line">       SIGPIPE      13       Term    Broken pipe: write to pipe with no</span><br><span class="line">                                     readers</span><br><span class="line">       SIGALRM      14       Term    Timer signal from alarm(2)</span><br><span class="line">       SIGTERM      15       Term    Termination signal</span><br><span class="line">       SIGUSR1   30,10,16    Term    User-defined signal 1</span><br><span class="line">       SIGUSR2   31,12,17    Term    User-defined signal 2</span><br><span class="line">       SIGCHLD   20,17,18    Ign     Child stopped or terminated</span><br><span class="line">       SIGCONT   19,18,25    Cont    Continue if stopped</span><br><span class="line">       SIGSTOP   17,19,23    Stop    Stop process</span><br><span class="line">       SIGTSTP   18,20,24    Stop    Stop typed at tty</span><br><span class="line">       SIGTTIN   21,21,26    Stop    tty input for background process</span><br><span class="line">       SIGTTOU   22,22,27    Stop    tty output for background process</span><br><span class="line"></span><br><span class="line">       Signal       Value     Action   Comment</span><br><span class="line">       ────────────────────────────────────────────────────────────────────</span><br><span class="line">       SIGBUS      10,7,10     Core    Bus error (bad memory access)</span><br><span class="line">       SIGPOLL                 Term    Pollable event (Sys V).</span><br><span class="line">                                       Synonym for SIGIO</span><br><span class="line">       SIGPROF     27,27,29    Term    Profiling timer expired</span><br><span class="line">       SIGSYS      12,31,12    Core    Bad argument to routine (SVr4)</span><br><span class="line">       SIGTRAP        5        Core    Trace&#x2F;breakpoint trap</span><br><span class="line">       SIGURG      16,23,21    Ign     Urgent condition on socket (4.2BSD)</span><br><span class="line">       SIGVTALRM   26,26,28    Term    Virtual alarm clock (4.2BSD)</span><br><span class="line">       SIGXCPU     24,24,30    Core    CPU time limit exceeded (4.2BSD)</span><br><span class="line">       SIGXFSZ     25,25,31    Core    File size limit exceeded (4.2BSD)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Signal     Value     Action   Comment</span><br><span class="line">名称        编号       事件      默认执行动作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Term ： 终止进程</span><br><span class="line">Ign ： 忽略</span><br><span class="line">Core：终止进程，生成 Core 文件（可以帮助开发者检测）</span><br><span class="line">Stop：停止进程</span><br><span class="line">Cont：继续运行</span><br></pre></td></tr></table></figure><p>Process.killProcess(Process.myPid());</p><p><code>kill pid （发送信号）</code> : 第一个参数，，&lt; 0 往 |pid| 发个信息，0 杀死进程组，不要传 -1 </p><ul><li>pid &gt; 0 往 pid 进程发个信号</li><li>pid &lt; 0 往 |pid| 发个信息</li><li>pid = 0 杀死进程组</li><li>不要传 -1 ,会杀死所有能杀死的进程</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-进程间通信的方式&quot;&gt;&lt;a href=&quot;#1-进程间通信的方式&quot; class=&quot;headerlink&quot; title=&quot;1.进程间通信的方式&quot;&gt;&lt;/a&gt;1.进程间通信的方式&lt;/h1&gt;&lt;p&gt;文件，管道，信号、信号量，共享映射区（共享内存），消息队列，管道，套接字（s
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="面试" scheme="http://eastup.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：05.linux系统-进程创建和进程管理</title>
    <link href="http://eastup.github.io/76.linux%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://eastup.github.io/76.linux%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2020-08-05T00:12:43.000Z</published>
    <updated>2020-11-11T07:11:01.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-pcb-process-control-block-进程控制块"><a href="#1-pcb-process-control-block-进程控制块" class="headerlink" title="1.pcb(process control block)进程控制块"></a>1.pcb(process control block)进程控制块</h1><p>结构体的路径：<code>~/usr/src/linux-headers-3.5.0-23/include/linux/sched.h</code></p><p>结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">        &#x2F;&#x2F; ......</span><br><span class="line"></span><br><span class="line">        进程 id</span><br><span class="line"></span><br><span class="line">        文件描述符</span><br><span class="line"></span><br><span class="line">        进程的状态：初始态，就绪态，运行态，挂起态，终止态</span><br><span class="line"></span><br><span class="line">        进程工作目录</span><br><span class="line"></span><br><span class="line">        信号相关信息资源</span><br><span class="line"></span><br><span class="line">        用户id组id</span><br><span class="line"></span><br><span class="line">        进程工作目录</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-内存映射（重点）"><a href="#2-内存映射（重点）" class="headerlink" title="2.内存映射（重点）"></a><strong><font color="red">2.内存映射（重点）</font></strong></h1><p>由于应用程序不能直接操作设备硬件地址，所以操作系统提供了这样的一种机制——内存映射，把设备地址映射到进程虚拟地址，<code>mmap</code>就是实现内存映射的接口。</p><p><code>mmap</code>的好处是，mmap<code>把设备内存映射到虚拟内存，则用户操作虚拟内存相当于直接操作设备了，省去了用户空间到内核空间的复制过程，相对IO操作来说，增加了数据的吞吐量</code>。</p><p>用户空间映射时，会映射到不同的区域，内核空间映射时，会映射到同一区域的不同地方（共享！！）</p><p>每个进程都有4G的虚拟地址空间，其中3G用户空间，1G内核空间（linux），每个进程共享内核空间，独立的用户空间</p><p><img src="/images/76.%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84.png" alt></p><h1 id="3-fork-创建子进程（重点）"><a href="#3-fork-创建子进程（重点）" class="headerlink" title="3.fork 创建子进程（重点）"></a><strong><font color="red">3.fork 创建子进程（重点）</font></strong></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc.<span class="keyword">const</span>  <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process!,pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent,cpid = %d,pid = %d,ppid = %d"</span> ,pid,getpid(),getppid());</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/76.fork%E5%87%BD%E6%95%B0.png" alt></p><h1 id="4-父子进程共享（重点）"><a href="#4-父子进程共享（重点）" class="headerlink" title="4.父子进程共享（重点）"></a><strong><font color="red">4.父子进程共享（重点）</font></strong></h1><h2 id="4-1-父子进程相同："><a href="#4-1-父子进程相同：" class="headerlink" title="4.1 父子进程相同："></a>4.1 父子进程相同：</h2><p>刚 fork 后，data 段，text 段，堆，栈，环境变量，全局变量，进程工作目录，信号处理方式。（0-3G 部分是共享的）</p><h2 id="4-2-父子进程不同的："><a href="#4-2-父子进程不同的：" class="headerlink" title="4.2 父子进程不同的："></a>4.2 父子进程不同的：</h2><p>进程 id ，返回值，各自的父进程，进程创建时间，闹钟，未决信号集 </p><h2 id="4-3-父子进程共享："><a href="#4-3-父子进程共享：" class="headerlink" title="4.3 父子进程共享："></a>4.3 父子进程共享：</h2><p>map 映射区，读时共享，写时复制。</p><h1 id="5-进程回收"><a href="#5-进程回收" class="headerlink" title="5. 进程回收"></a>5. 进程回收</h1><p>回收的就是残留在内核中的 3-4G 的数据（pcb 进程控制块）</p><ul><li>孤儿进程：父进程先于子进程结束，则子进程会成为孤儿进程，子进程的父进程成为 init 进程，有 init 进程（进程孤儿院）来回收进程。</li><li>僵尸进程：子进程结束，父进程尚未回收，该子进程会变成僵尸进程</li></ul><p>wait, waitpid<br>wait功能：</p><ol><li>阻塞等待子线程退出</li><li>回收子进程残留的资源</li><li>获取子进程退出的状态（怎么死掉的）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> state;</span><br><span class="line">wait(&amp;state);</span><br></pre></td></tr></table></figure><h1 id="6-监听-APP-应用被卸载"><a href="#6-监听-APP-应用被卸载" class="headerlink" title="6.监听 APP 应用被卸载"></a>6.监听 APP 应用被卸载</h1><ol><li>fork 一个子进程</li><li>监听文件是否被删除了，data/data/xxx包名</li><li>execl 函数族去执行某些命令（打开浏览器收集用户反馈）  </li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以执行自己写好的程序，path 是路径，arg 是可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以执行系统的命令程序，file 是命令的名称，arg 是可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> <font color="red">execl 不会走 fork 之后的 text 代码段，而是会去执行 exec 函数族的命令或者程序</font></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc.<span class="keyword">const</span>  <span class="keyword">char</span>* argv[])</span></span>&#123; <span class="comment">// 获取 参数 -l ，[1]才是，[0]是程序本身</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork before\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"fork error!\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"i am child process!,pid = %d,ppid = %d\n"</span>,getpid(),getppid());</span><br><span class="line">        execl(<span class="string">"ls"</span>,<span class="string">"ls"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>); <span class="comment">// NULL 代表可变参数的结尾</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am parent,cpid = %d,pid = %d,ppid = %d"</span> ,pid,getpid(),getppid());</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork after\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-pcb-process-control-block-进程控制块&quot;&gt;&lt;a href=&quot;#1-pcb-process-control-block-进程控制块&quot; class=&quot;headerlink&quot; title=&quot;1.pcb(process control bloc
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：04.linux系统-内核编程，文件IO与文件描述符</title>
    <link href="http://eastup.github.io/75.linux%E7%B3%BB%E7%BB%9F-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%87%E4%BB%B6IO%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/"/>
    <id>http://eastup.github.io/75.linux%E7%B3%BB%E7%BB%9F-%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%96%87%E4%BB%B6IO%E4%B8%8E%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</id>
    <published>2020-08-04T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:54.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-系统内核调用"><a href="#1-系统内核调用" class="headerlink" title="1. 系统内核调用"></a>1. 系统内核调用</h1><p>3-4G 是系统的空间（<code>内核空间</code>），这部分是由操作系统来管理，那么如果我们要操作这部分数据，只能借助系统提供的一些函数（系统函数），用户调用这些函数就称之为系统调用。</p><p><img src="/images/75.%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.png" alt></p><h1 id="2-普通函数与内核函数"><a href="#2-普通函数与内核函数" class="headerlink" title="2.普通函数与内核函数"></a>2.普通函数与内核函数</h1><p>系统函数：<code>open , close , write , read</code></p><p><code>man 2 ‘系统函数’</code>：查看系统函数<br><code>man 3 ‘普通函数’</code>：查看系统函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; open</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line">pathname : 文件的路径  </span><br><span class="line">flags : O_APPEND 追加，O_CREAT 没有的时候会创建，O_TRUNC 会截断（清空文件）  </span><br><span class="line">mode：就是创建时的文件权限 ， 只是当前用户可读可写，S_IRUSR|S_IWUSR  </span><br><span class="line">返回的是一个文件句柄 fd , 我们直接通过 fd 去做操作  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int close(int fd); 关闭文件</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  read</span><br><span class="line">ssize_t read(int fd, void *buf, size_t count);</span><br><span class="line">fd：文件句柄</span><br><span class="line">void *buf：读入的缓冲区</span><br><span class="line">count：每次读多少字节数</span><br><span class="line">ssize_t ：返回的是读到真实个数</span><br><span class="line"></span><br><span class="line">ssize_t write(int fd, const void *buf, size_t count);</span><br><span class="line">fd：文件句柄</span><br><span class="line">void *buf：写入的缓冲区</span><br><span class="line">count：每次写入的字节数</span><br><span class="line">ssize_t ：返回的是写入真实个数</span><br></pre></td></tr></table></figure><p>文件操作的错误怎么提示？会有一个宏定义 errno  , 通过 strerror(errno) 获取错误信息，需要打印错误快捷的方式 perror<br>void perror(const char *s); s 代表的是错误信息的描述 s: strerror(errno)</p><p>普通函数：<code>fopen，fclose ， fread/fputc ，fwrite/fgetc</code></p><h1 id="3-普通函数和系统函数拷贝文件的区别"><a href="#3-普通函数和系统函数拷贝文件的区别" class="headerlink" title="3.普通函数和系统函数拷贝文件的区别"></a>3.普通函数和系统函数拷贝文件的区别</h1><p>fputc 和 fgetc 内部是封装了 read , wirte , 如果拷贝文件，速度区别如下：</p><ul><li>系统函数每次只读取一个 Byte，速度很慢</li><li>普通函数每次读取 4096 个 byte，所以很快</li></ul><p>Java write 数据，需要 flush 的原理一样，数据还在缓冲区(数据不会自动发送出去)，需要flush一起给到内核空间，在内核空间中调用 write.</p><p><img src="/images/75.%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0.png" alt></p><h1 id="4-文件描述符（文件句柄）"><a href="#4-文件描述符（文件句柄）" class="headerlink" title="4.文件描述符（文件句柄）"></a>4.文件描述符（文件句柄）</h1><p><img src="/images/75.%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt></p><h1 id="5-lseek-与-fseek"><a href="#5-lseek-与-fseek" class="headerlink" title="5.lseek 与 fseek"></a>5.lseek 与 fseek</h1><p>用来获取偏移量 SEEK_SET , SEEK_END, SEEK_CUR<br>lseek 他的偏移量，读和写是同一个</p><h1 id="6-stat-和-lstat"><a href="#6-stat-和-lstat" class="headerlink" title="6.stat 和 lstat"></a>6.stat 和 lstat</h1><p>Inode: 370887 ， 文件的权限，盘符的位置。<br>硬链接计数就充分的利用了 inode<br>硬链接：文件快捷键<br>软链接：类似于文件的快捷键，但是你操作任何一个都会被改变  </p><p>软连接和硬链接的特点：</p><p>软链接：</p><ul><li>软链接是存放另一个文件的路径的形式存在。</li><li>软链接可以 跨文件系统 ，硬链接不可以。</li><li>软链接可以对一个不存在的文件名进行链接，硬链接必须要有源文件。</li><li>软链接可以对目录进行链接。</li></ul><p>硬链接：</p><ul><li>硬链接，以文件副本的形式存在。但不占用实际空间。</li><li>不允许给目录创建硬链接。</li><li>硬链接只有在同一个文件系统中才能创建。</li><li>删除其中一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul><p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int stat(const char *pathname, struct stat *buf);</span><br><span class="line">pathname：文件路径</span><br><span class="line"></span><br><span class="line">struct stat *buf：stat 结构体指针</span><br><span class="line"></span><br><span class="line">作业：stat 获取文件的属性，获取文件的大小就可以</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stat 和 lstat 有什么区别？stat 是会穿透的，lstat 不会穿透，穿透软连接</span><br><span class="line"></span><br><span class="line">ln -s f_read_write f_read_write.soft ： 创建软连接</span><br></pre></td></tr></table></figure><h1 id="7-目录操作"><a href="#7-目录操作" class="headerlink" title="7.目录操作"></a>7.目录操作</h1><p>递归操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* fileName)</span></span>&#123;</span><br><span class="line">    <span class="comment">// int stat(const char *pathname,struct stat *buf);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>* <span class="title">buf</span>;</span> <span class="comment">// 作为传入参数</span></span><br><span class="line">    stat(fileName,&amp;buf);</span><br><span class="line">    <span class="keyword">mode_t</span> st_mode = buf.st_mode;</span><br><span class="line">    <span class="keyword">return</span> S_ISDIR(st_mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// 打开目录</span></span><br><span class="line">    DIR *dir = opendir(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(dir == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open dir fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct dirent *readdir(DIR *dirp);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    <span class="keyword">while</span>((dirp = readdir(dir)) != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">// printf("%s\t",dirp-&gt;d_name);</span></span><br><span class="line">        <span class="comment">// 一个递归</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-系统内核调用&quot;&gt;&lt;a href=&quot;#1-系统内核调用&quot; class=&quot;headerlink&quot; title=&quot;1. 系统内核调用&quot;&gt;&lt;/a&gt;1. 系统内核调用&lt;/h1&gt;&lt;p&gt;3-4G 是系统的空间（&lt;code&gt;内核空间&lt;/code&gt;），这部分是由操作系统来管理，
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：03.linux系统-文档编辑、应用编译运行</title>
    <link href="http://eastup.github.io/74.linux%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E3%80%81%E5%BA%94%E7%94%A8%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/"/>
    <id>http://eastup.github.io/74.linux%E7%B3%BB%E7%BB%9F-%E6%96%87%E6%A1%A3%E7%BC%96%E8%BE%91%E3%80%81%E5%BA%94%E7%94%A8%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C/</id>
    <published>2020-08-03T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:47.203Z</updated>
    
    <content type="html"><![CDATA[<p>注意：<code>未做说明以下都是在命令模式下进行</code></p><p>编辑过程中遇到的问题：</p><p>误按了：<code>ctrl + z</code> ： 可以将一个正在前台执行的命令放到后台，并且暂停</p><p>再次打开就变成了以下这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">E325: 注意</span><br><span class="line">发现交换文件 &quot;.t.txt.swp&quot;</span><br><span class="line">            所有者: root    日期: Sun Aug 25 23:27:33 2019</span><br><span class="line">            文件名: ~root&#x2F;test&#x2F;t.txt</span><br><span class="line">            修改过: 否</span><br><span class="line">            用户名: root      主机名: master</span><br><span class="line">           进程 ID: 4803 (仍在运行)</span><br><span class="line">正在打开文件 &quot;t.txt&quot;</span><br><span class="line">              日期: Sun Aug 25 22:17:30 2019</span><br><span class="line"></span><br><span class="line">(1) Another program may be editing the same file.  If this is the case,</span><br><span class="line">    be careful not to end up with two different instances of the same</span><br><span class="line">    file when making changes.  Quit, or continue with caution.</span><br><span class="line">(2) An edit session for this file crashed.</span><br><span class="line">    如果是这样，请用 &quot;:recover&quot; 或 &quot;vim -r t.txt&quot;</span><br><span class="line">    恢复修改的内容 (请见 &quot;:help recovery&quot;)。</span><br><span class="line">    如果你已经进行了恢复，请删除交换文件 &quot;.t.txt.swp&quot;</span><br><span class="line">    以避免再看到此消息。</span><br><span class="line"></span><br><span class="line">交换文件 &quot;.t.txt.swp&quot; 已存在！</span><br><span class="line">以只读方式打开([O]), 直接编辑((E)), 恢复((R)), 退出((Q)), 中止((A)):</span><br></pre></td></tr></table></figure><p>解决办法：</p><p>使用 <code>fg</code> :将后台中的命令调至前台继续运行</p><h1 id="1-vim-工作模式"><a href="#1-vim-工作模式" class="headerlink" title="1. vim 工作模式"></a>1. vim 工作模式</h1><p><img src="/images/74.vim%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F.png" alt></p><ul><li><code>gcc hello.c -o a</code>：编译成可执行文件 <code>a</code></li><li><code>./a</code>：运行可执行文件 a</li></ul><h1 id="2-vim-命令模式进入输入模式的快捷键"><a href="#2-vim-命令模式进入输入模式的快捷键" class="headerlink" title="2 vim 命令模式进入输入模式的快捷键"></a>2 vim 命令模式进入输入模式的快捷键</h1><ul><li><p><code>i</code>: 输入,光标前面</p></li><li><p><code>I</code>: 输入,光标前面</p></li><li><p><code>a</code>: 输入,光标会逻动一个位置</p></li><li><p><code>A</code>:输入,光标会逻动到最后</p></li><li><p><code>o</code>:输入,光标会逻动到下一行</p></li><li><p><code>O</code>:输入,光标会逻动到上一行</p></li><li><p><code>s</code>:输入,会删除光标所在字符</p></li><li><p><code>S</code>: 输入,会删除光标所在行</p></li><li><p><code>h</code>: 向左移动光标</p></li><li><p><code>l</code>: 向右移动光标</p></li><li><p><code>j</code>: 向下移动光标</p></li><li><p><code>k</code>: 向上移动光标</p></li></ul><h2 id="2-1-跳转和删除"><a href="#2-1-跳转和删除" class="headerlink" title="2.1.跳转和删除"></a>2.1.跳转和删除</h2><ul><li><p><code>5G</code>：跳转到第 5 行</p></li><li><p><code>5回车</code>或者<code>G</code>：跳转到末行行首</p></li><li><p><code>gg</code>: 跳转到首行行首</p></li><li><p><code>$</code>: 跳转到当行行尾</p></li><li><p><code>0</code>: 跳转到当行行首</p></li><li><p><code>gg=G</code>: 格式化代码</p></li><li><p><code>dw</code>：删除单词从光标到单词结束的地方</p></li><li><p><code>x</code>: 删除某个字母</p></li><li><p><code>d0</code>: 删除光标至行首</p></li><li><p><code>v+h/j/k/l+d</code> 或者 <code>v+上/下/左/右+d</code>：删除选中区域</p></li><li><p><code>dd</code>: 剪切整行，可以当删除</p></li><li><p><code>3dd</code>: 从当前行剪切 3 行，可以当删除</p></li></ul><h2 id="2-2-复制、粘贴"><a href="#2-2-复制、粘贴" class="headerlink" title="2.2. 复制、粘贴"></a>2.2. 复制、粘贴</h2><ul><li><code>yy</code>: 复制当前行</li><li><code>3yy</code>: 从当前行复制 3 行</li><li><code>p</code>: 粘贴到当前行的<code>下一行</code></li><li><code>P</code>: 粘贴到当前行的<code>上一行</code></li><li><code>dd</code>: 剪切整行</li><li><code>3dd</code>: 从当前行剪切 3 行</li></ul><h2 id="2-3-查找替换"><a href="#2-3-查找替换" class="headerlink" title="2.3 查找替换"></a>2.3 查找替换</h2><ul><li><code>/ + &#39;要查找的内容&#39; +回车</code>:  查找 , ‘*’或‘n’ 跳转到下一个， ‘N’ 是查看上一个</li><li><code>r + &#39;要替换的字符&#39;</code>：把当前光标字符替换成 ‘要替换的字符’</li><li><code>:s /printf/println</code> : 将当前光标所在行中的<code>第一个</code>printf替换成println</li><li><code>:%s /printf/println</code> : 将每一行中的<code>第一个</code>printf替换成println</li><li><code>:s /printf/println/g</code> ：将这一行的所有printf替换成println</li><li><code>:%s /printf/println/g</code> : 将所有地方的printf替换成println</li><li><code>:1,3s /printf/println/g</code>: 将1-3行的所有printf替换成println</li></ul><h2 id="2-4-其它命令"><a href="#2-4-其它命令" class="headerlink" title="2.4.其它命令"></a>2.4.其它命令</h2><ul><li><code>u</code>: 撤销</li><li><code>ctrl+r</code>: 反撤销</li><li><code>:sp</code>: 上下分屏</li><li><code>:vsp</code>: 左右分屏</li><li><code>ctrl + ww</code> : 切换分屏</li><li><code>wqall</code>: 保存退出所有</li><li><code>3+K或2+K</code>: 跳转到光标所指向的函数声明</li></ul><h1 id="3-gcc-编译的四个步骤"><a href="#3-gcc-编译的四个步骤" class="headerlink" title="3. gcc 编译的四个步骤"></a>3. gcc 编译的四个步骤</h1><p>.c 文件 -&gt; 可执行文件，经历了四个步骤</p><h2 id="3-1-预处理阶段"><a href="#3-1-预处理阶段" class="headerlink" title="3.1 预处理阶段"></a>3.1 预处理阶段</h2><p><code>将所有的宏定义的替换，类似于 java 的 final</code>,展开include的文件 </p><p><code>gcc -E -o hello.i hello.c</code>: 将 hello.c 文件预处理成 hello.i 文件</p><h2 id="3-2-预编译阶段"><a href="#3-2-预编译阶段" class="headerlink" title="3.2 预编译阶段"></a>3.2 预编译阶段</h2><p>在这个阶段，GCC 才会去检测你代码的规范性，语法是否有错误，gcc 会把代码翻译成汇编</p><p><code>gcc -S -o hello.s hello.i</code>:将 hello.i 文件预编译成 hello.i 文件</p><h2 id="3-3-汇编阶段"><a href="#3-3-汇编阶段" class="headerlink" title="3.3 汇编阶段"></a>3.3 汇编阶段</h2><p>把 .s 文件翻译成二进制.o文件（机器的指令）,文本打开的是乱码</p><p><code>gcc -c -o hello.o hello.s</code>:将 hello.s 汇编成 hello.o 文件</p><h3 id="3-4-链接阶段"><a href="#3-4-链接阶段" class="headerlink" title="3.4 链接阶段"></a>3.4 链接阶段</h3><p>计算逻辑地址，合并数据段，有些函数是在另外一个 so 库文件中的。</p><p><code>gcc -o hello hello.o</code>：这个时候就可以执行<code>hello</code>了</p><h1 id="4-动态库和静态库"><a href="#4-动态库和静态库" class="headerlink" title="4.动态库和静态库"></a>4.动态库和静态库</h1><p><code>静态库</code>：其实是内容的拷贝(代码)，运行阶段<code>没有 .a 文件</code>了也是可以执行的。<br><code>动态库</code>：不会拷贝内容，运行阶段起的作用（加载），生成 so 的时候要生成与位置无关的代码，没有 so 不能运行。</p><h2 id="4-1-静态库的生成"><a href="#4-1-静态库的生成" class="headerlink" title="4.1 静态库的生成:"></a>4.1 静态库的生成:</h2><h3 id="4-1-1-将-c-生成-o"><a href="#4-1-1-将-c-生成-o" class="headerlink" title="4.1.1 将 c 生成 .o"></a>4.1.1 将 c 生成 .o</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o  <span class="comment">// 将 add.c 文件输出为 .o文件</span></span><br></pre></td></tr></table></figure><h3 id="4-1-2-使用-ar-工具制作静态库"><a href="#4-1-2-使用-ar-工具制作静态库" class="headerlink" title="4.1.2. 使用 ar 工具制作静态库"></a>4.1.2. 使用 ar 工具制作静态库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libmath.a add.o xxx.o <span class="comment">// 将 add.o 和 xxx.o 文件制作到 libmath.a 中</span></span><br></pre></td></tr></table></figure><h3 id="4-1-3-编译静态库到可执行文件"><a href="#4-1-3-编译静态库到可执行文件" class="headerlink" title="4.1.3. 编译静态库到可执行文件"></a>4.1.3. 编译静态库到可执行文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c libmath.a -o hello <span class="comment">// 将 a.c 和 libmath.a 输出到可执行文件 hello 中</span></span><br></pre></td></tr></table></figure><h2 id="4-2-动态库生成"><a href="#4-2-动态库生成" class="headerlink" title="4.2 动态库生成"></a>4.2 动态库生成</h2><h3 id="4-2-1-将-c-生成-o-（要生成与位置无关的代码）"><a href="#4-2-1-将-c-生成-o-（要生成与位置无关的代码）" class="headerlink" title="4.2.1 将 c 生成 .o （要生成与位置无关的代码）"></a>4.2.1 将 c 生成 .o （要生成与位置无关的代码）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c add.c -o add.o -fPIC  <span class="comment">// // 将 add.c 文件输出为 .o文件 要加 -fPIC</span></span><br></pre></td></tr></table></figure><h3 id="4-2-2-使用-gcc-shared-制作动态库"><a href="#4-2-2-使用-gcc-shared-制作动态库" class="headerlink" title="4.2.2 使用 gcc -shared 制作动态库"></a>4.2.2 使用 gcc -shared 制作动态库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libmath.so add.o xxx.o <span class="comment">// // 将 add.o 和 xxx.o 文件制作到 libmath.so 中</span></span><br></pre></td></tr></table></figure><h3 id="4-2-3-编译动态库到可执行文件，需要指定动态库的名称-l-指定库路径-L"><a href="#4-2-3-编译动态库到可执行文件，需要指定动态库的名称-l-指定库路径-L" class="headerlink" title="4.2.3 编译动态库到可执行文件，需要指定动态库的名称 -l , 指定库路径 -L"></a>4.2.3 编译动态库到可执行文件，需要指定动态库的名称 -l , 指定库路径 -L</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc a.c -o a -lmath -L./   <span class="comment">// libmath.so 要写成math， ./ 代表当前文件夹</span></span><br></pre></td></tr></table></figure><h1 id="5-虚拟内存与物理内存"><a href="#5-虚拟内存与物理内存" class="headerlink" title="5.虚拟内存与物理内存"></a>5.虚拟内存与物理内存</h1><p><code>虚拟内存</code> 是为了缓解<code>物理内存</code>的压力而创建的，他们之间是通过<code>映射</code>来进行的联系</p><p>每个进程都有4G的虚拟地址空间，其中3G用户空间，1G内核空间（linux），每个进程共享内核空间，独立的用户空间：</p><p><img src="/images/74.%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%9B%BE.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;注意：&lt;code&gt;未做说明以下都是在命令模式下进行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;编辑过程中遇到的问题：&lt;/p&gt;
&lt;p&gt;误按了：&lt;code&gt;ctrl + z&lt;/code&gt; ： 可以将一个正在前台执行的命令放到后台，并且暂停&lt;/p&gt;
&lt;p&gt;再次打开就变成了以下这样&lt;/p&gt;
&lt;f
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：02.linux系统-常用命令</title>
    <link href="http://eastup.github.io/73.linux%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://eastup.github.io/73.linux%E7%B3%BB%E7%BB%9F-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-08-02T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:07.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1. 常用快捷键"></a>1. 常用快捷键</h1><ul><li><code>table</code> 补齐</li><li><code>ctrl + a</code> : 光标移动到最前</li><li><code>ctrl + e</code>：光标移动到最后</li><li><code>ctrl + u</code>：清空</li><li><code>上，下键</code>：切换命令</li></ul><h1 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h1><h2 id="2-1-文件基本操作指令"><a href="#2-1-文件基本操作指令" class="headerlink" title="2.1 文件基本操作指令"></a>2.1 文件基本操作指令</h2><ul><li><code>cd xxx</code>：进入到某个目录</li><li><code>cd ..</code>：回退到上一级目录</li><li><code>ls</code> : 当前文件夹下面的所有文件</li><li><code>./date</code> ：执行当前目录下的可执行文件</li></ul><p>linux 系统中所见即文件（驱动）  , bin 目录一些执行文件，home 目录用户， lib 目录常用的 so ，opt 和 proc 是与进程相关的</p><ul><li><code>mkdir xxx</code>：创建文件夹</li><li><code>touch xxx.xxx</code>： 创建文件</li><li><code>ls -l</code> : 打印详细信息</li><li><code>ls -R</code> ：递归文件夹输出</li></ul><h2 id="2-2-文件类型"><a href="#2-2-文件类型" class="headerlink" title="2.2 文件类型"></a>2.2 文件类型</h2><p><code>drwxr-xr-x 1 ubuntu ubuntu 0 Apr 14 20:37 hello.c</code><br>代表：文件权限，硬链接计数，所有者，所属组，大小，时间，文件名</p><ul><li><code>d</code>:表示文件类型；</li><li><code>rwx</code>：表示文件所有者的对该文件所拥有的权限；</li></ul><p><code>-rw-rw-r--：- 文件类型，rw- 所有者可读可写，rw- 同一组用户可读可写，r-- 其他人可读</code></p><p><img src="/images/73.linux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.jpg" alt></p><p>linux 系统文件类型：</p><ul><li>普通文件：-</li><li>目录文件：d</li><li>软连接：l</li><li>字符设备文件：c</li><li>块设备文件：b</li><li>管道文件：p</li><li>套接字：s</li></ul><h2 id="2-3-文件删除、拷贝、读取等"><a href="#2-3-文件删除、拷贝、读取等" class="headerlink" title="2.3 文件删除、拷贝、读取等"></a>2.3 文件删除、拷贝、读取等</h2><ul><li><code>rmdir ‘文件夹’</code> : 只能清空空目录文件夹</li><li><code>rm -r ‘文件夹’</code>：递归清空目录</li><li><code>rm ‘文件’</code>：删除文件</li><li><code>cp &#39;文件&#39; ‘文件夹路径’</code> ： 拷贝文件 -r 递归赋值</li><li><code>cat ‘文件’</code> ：查看文件内容</li><li><code>tac ‘文件’</code>：倒着查看文件</li><li><code>more ‘文件’</code>：每次只查看一页，空格查看下一页</li><li><code>less ‘文件’</code>：与 more 不同地方是, 回车是下一行，空格翻一页，没有百分百，退出 ctrl + c 不行，ESC之后  :q</li><li><code>head -2 ‘文件’</code>：查看前面2行</li><li><code>tail -20 ‘文件’</code>：查看后面20行</li></ul><p>删除文件时<code>rm</code>的参数</p><ul><li>-i 删除前逐一询问确认。</li><li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li><li>-r 将目录及以下之档案亦逐一删除。</li></ul><h1 id="3-用户与用户组"><a href="#3-用户与用户组" class="headerlink" title="3. 用户与用户组"></a>3. 用户与用户组</h1><ul><li>sudo：代表使用 root 权限</li><li><code>sudo su ‘用户’</code>：切换到 root 用户</li><li><code>exit</code> : 退出 当前 用户</li><li><code>whoami</code>：查看当前用户</li></ul><h2 id="3-1-修改用户文件权限"><a href="#3-1-修改用户文件权限" class="headerlink" title="3.1 修改用户文件权限"></a>3.1 修改用户文件权限</h2><p>新建的文件默认是不能执行的，我们需要修改用户文件权限</p><h3 id="3-1-1-文字设定法"><a href="#3-1-1-文字设定法" class="headerlink" title="3.1.1. 文字设定法"></a>3.1.1. 文字设定法</h3><p><code>chmod 用户的标识 +/- 权限 文件名：chmod u+x hello.sh</code><br>用户的标识：u(当前用户) ，g(同组)，o(other)，a(all)</p><h3 id="3-1-2-数字设定法"><a href="#3-1-2-数字设定法" class="headerlink" title="3.1.2. 数字设定法"></a>3.1.2. 数字设定法</h3><p><code>chmod nnn 文件名</code>  ,第一个n所属用户，第二个n所属用户组，第三个n其它用户<br>n = 4+2+1 = r+w+x </p><h2 id="3-2-用户和用户组的创建、修改、删除"><a href="#3-2-用户和用户组的创建、修改、删除" class="headerlink" title="3.2 用户和用户组的创建、修改、删除"></a>3.2 用户和用户组的创建、修改、删除</h2><ul><li><code>sudo adduser &#39;用户&#39;</code>： 创建了一个用户</li><li><code>sudo chown &#39;用户&#39; &#39;文件&#39;</code> ：修改文件的所属用户</li><li><code>sudo chgrp &#39;用户组&#39; &#39;文件&#39;</code> ：修改文件的所属组</li><li><code>sudo chown &#39;用户&#39;:&#39;用户组&#39; &#39;文件&#39;</code>：同时修改文件所属组：所属用户</li><li><code>sudo deluser &#39;用户&#39;</code>：删除用户，同时需要再删除“/home/用户名”的文件夹</li></ul><h1 id="4-搜索查找"><a href="#4-搜索查找" class="headerlink" title="4.搜索查找"></a>4.搜索查找</h1><h2 id="4-1-find-查找文件"><a href="#4-1-find-查找文件" class="headerlink" title="4.1 find 查找文件"></a>4.1 find 查找文件</h2><ul><li><code>find ./ -type ‘文件类型（文件是 -，目录是 d）’</code>（递归）</li><li><code>find ./ -name &#39;*.so&#39;</code> ： 根据文件名去查找</li><li><code>find ./ -maxdepth 1 -name &#39;*.so&#39;</code> ： 根据文件名去查找，只在当前文件夹查找，-maxdepth ：递归的层级</li><li><code>find ./ -maxdepth 1 -ctime -20</code>：将目前目录及其子目录下所有最近 20 天内更新过的文件列出</li></ul><p>再回顾下 文件类型</p><ul><li>d: 目录</li><li>c: 字型装置文件</li><li>b: 区块装置文件</li><li>p: 具名贮列</li><li>f: 一般文件</li><li>l: 符号连结</li><li>s: socket</li></ul><h2 id="4-2-grep-查找内容"><a href="#4-2-grep-查找内容" class="headerlink" title="4.2 grep 查找内容"></a>4.2 grep 查找内容</h2><ul><li><code>grep -r &quot;查询内容&quot; 文件目录</code>：grep -r ‘jaminniubi’ ./ 找当前文件夹中文件内容有jamin 的文件</li><li><code>grep -r -l   &quot;查询内容&quot;</code>  文件目录  ：  #这样只显示包含内容的文件名</li><li><code>ps aux</code>: 类似于任务管理器，把所有的进程信息都列举出来</li><li><code>ps aux | grep ‘内容’</code> : 找到了所有的任务，交给 grep 去执行搜索 ，如果只有一个代表没有找到，两个以上才算有</li></ul><p>| ： 管道 （进程间的通信），相当于 | 前的结果，作为输出给到 | 后</p><p>常用选项：</p><pre><code>　　-e ：开启扩展（Extend）的正则表达式。　　-i ：忽略大小写（ignore case）。　　-v ：反过来（invert），只打印没有匹配的，而匹配的反而不打印。　　-n ：显示行号　　-w ：被匹配的文本只能是单词，而不能是单词中的某一部分，如文本中有liker，而我搜寻的只是like，就可以使用-w选项来避免匹配liker　　-c ：显示总共有多少行被匹配到了，而不是显示被匹配到的内容，注意如果同时使用-cv选项是显示有多少行没有被匹配到。　　-o ：只显示被模式匹配到的字符串。　　--color :将匹配到的内容以颜色高亮显示。　　-A  n：显示匹配到的字符串所在的行及其后n行，after　　-B  n：显示匹配到的字符串所在的行及其前n行，before　　-C  n：显示匹配到的字符串所在的行及其前后各n行，context</code></pre><h1 id="5-软件安装"><a href="#5-软件安装" class="headerlink" title="5.软件安装"></a>5.软件安装</h1><h2 id="5-1-命令行安装"><a href="#5-1-命令行安装" class="headerlink" title="5.1 命令行安装"></a>5.1 命令行安装</h2><ul><li><code>sudo apt-get install tree</code>：tree 是要安装的程序</li><li><code>sudo apt-get update</code>:更新程序</li><li><code>sudo apt-get remove tree</code>:软件卸载</li></ul><h2 id="5-2-压缩包安装"><a href="#5-2-压缩包安装" class="headerlink" title="5.2 压缩包安装"></a>5.2 压缩包安装</h2><p>这种格式一般会采用源代码编译安装，或是解压完直接就可以运行的方式，可以通过查看目录内是否有源代码或是configure文件来确实是不是源代码。</p><ul><li><code>./configure                       //配置</code></li><li><code>make                              //编译</code></li><li><code>make install                      //安装</code></li></ul><h2 id="5-3-源码安装"><a href="#5-3-源码安装" class="headerlink" title="5.3 源码安装"></a>5.3 源码安装</h2><ul><li><code>./configure                       //配置</code></li><li><code>make                              //编译</code></li><li><code>make install                      //安装</code></li></ul><h1 id="6-压缩和解压缩"><a href="#6-压缩和解压缩" class="headerlink" title="6.压缩和解压缩"></a>6.压缩和解压缩</h1><h2 id="6-1-tar"><a href="#6-1-tar" class="headerlink" title="6.1 tar"></a>6.1 tar</h2><p><code>tar -zcvf &#39;压缩到的文件&#39; ‘需要压缩的文件’ ‘需要压缩的文件’</code><br><code>tar -jcvf test.tar.zip a.c file</code><br><code>tar -zxvf test.tar.zip</code> // 解压文件  </p><ul><li><p><code>-zcvf</code>　<code>z:gzip</code> ,　<code>c: create压缩</code>　<code>f: file</code>　<code>v:显示过程</code> <code>x:解压缩</code> </p></li><li><p><code>-jcvf</code>　<code>j:bizp2</code> ,　<code>c: create压缩</code>　<code>f: file</code>　<code>v:显示过程</code> <code>x:解压缩</code></p></li><li><p><code>gzip ‘需要压缩的文件’</code> 只能压缩一个文件</p></li><li><p><code>gunzip a.c.gz</code>：解压文件</p></li></ul><h2 id="6-2-rar和zip"><a href="#6-2-rar和zip" class="headerlink" title="6.2 rar和zip"></a>6.2 rar和zip</h2><ul><li><code>rar a -r test.rar</code> ：rar 压缩</li><li><code>unrar x test.rar</code>：rar 解压缩</li><li><code>zip -r test.zip a.c file</code> ：zip 压缩</li><li><code>unzip test.zip</code>：zip解压缩</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-常用快捷键&quot;&gt;&lt;a href=&quot;#1-常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;1. 常用快捷键&quot;&gt;&lt;/a&gt;1. 常用快捷键&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;table&lt;/code&gt; 补齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctrl 
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>音视频：01.音视频技术-启动篇</title>
    <link href="http://eastup.github.io/72.%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0-%E5%90%AF%E5%8A%A8%E7%AF%87/"/>
    <id>http://eastup.github.io/72.%E9%9F%B3%E8%A7%86%E9%A2%91%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0-%E5%90%AF%E5%8A%A8%E7%AF%87/</id>
    <published>2020-08-01T00:12:43.000Z</published>
    <updated>2020-11-11T07:10:10.876Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-音视频学习"><a href="#1-音视频学习" class="headerlink" title="1. 音视频学习"></a>1. 音视频学习</h1><ul><li>视音频播放器（华为视频，腾讯视频，喜马拉雅，QQ音乐）</li><li>短视频（抖音，小火山，微视）</li><li>视音频的直播（有信，QQ音乐的电台，视频直播）+ OpengGl </li></ul><p><a href="https://blog.csdn.net/leixiaohua1020" target="_blank" rel="noopener">雷霄骅</a></p><p>Android + NDK　　FFmpeg + SurfaceView + AudioTrack </p><h1 id="2-音视频编解码"><a href="#2-音视频编解码" class="headerlink" title="2. 音视频编解码"></a>2. 音视频编解码</h1><p>先来看下视频的播放流程：</p><p><img src="/images/72.%E8%A7%86%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E6%B5%81%E7%A8%8B.png" alt></p><ul><li>RGB：8字节，24字节，32字节（RGBA）</li><li>YUV：Y黑白电视，亮度；U 色度，V 饱和度  ， YUV440，YUV420，YUV444 </li></ul><p>YUV：发现比例可以不一样，为什么可以，人脸对亮度比较敏感，对色度没这么敏感</p><p>YUV444 : Y：U：V 比例 1:1:1，YUV420 比例 2:1:0   </p><p>H264 编解码码的思想，认为每一帧每一帧都有相同的数据，就充分利用这个特性  </p><p>涉计到的算法：熵编码，帧内预测，帧间预测，环形滤波… </p><p>补充：H264码流怎么存？一个一个的 <code>NALU</code> 存起来的，大小是不固定的，一个  <code>NALU</code> 代表的是一帧画面，区分每个 <code>NALU</code> 的办法就是设置两个标志位 </p><p>PCM 采样：麦克风，  </p><ul><li>声道　　　　　: 2声道 （左右声道，立体声） 5point1 环绕声</li><li>采样率　　　　: 48.0 KHz      1秒钟采样多少个点 48*1000 ， 44100HZ 人耳</li><li>位深度　　　　: 16位              16byte 存的   最大值？   8 位   </li></ul><h1 id="3-FFmpeg"><a href="#3-FFmpeg" class="headerlink" title="3. FFmpeg"></a>3. FFmpeg</h1><ul><li><p>ijkplayer ： ffmpeg ， libyuv ， opensl es , 自己代码</p></li><li><p>微视：基于这个 ffmpeg </p></li><li><p>音视频通话：基于 webrtc</p><p>ffmpeg 是一个 c 库，要用你的编译 so , 自己去编译，你可以按需加载，减少so库的体积<br>shell 脚本，cmake 语法，linux ， 买最便宜，ubuntu ，mac 可以不用买，终端 -&gt; shell<br>inux 内核基础，android 底层基于 linux 内核 mmap() 等等  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-音视频学习&quot;&gt;&lt;a href=&quot;#1-音视频学习&quot; class=&quot;headerlink&quot; title=&quot;1. 音视频学习&quot;&gt;&lt;/a&gt;1. 音视频学习&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;视音频播放器（华为视频，腾讯视频，喜马拉雅，QQ音乐）&lt;/li&gt;
&lt;li&gt;短视频（抖
      
    
    </summary>
    
    
      <category term="音视频" scheme="http://eastup.github.io/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://eastup.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：23.实时人脸检测和识别</title>
    <link href="http://eastup.github.io/71.OpenCV-%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E5%92%8C%E8%AF%86%E5%88%AB/"/>
    <id>http://eastup.github.io/71.OpenCV-%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E5%92%8C%E8%AF%86%E5%88%AB/</id>
    <published>2019-04-22T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:55.954Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv71" target="_blank" rel="noopener">NDKPractice项目的opencv71</a></strong></p><h1 id="1-训练人脸样本"><a href="#1-训练人脸样本" class="headerlink" title="1. 训练人脸样本"></a>1. 训练人脸样本</h1><p>三种训练方法：  </p><ul><li>eigenFace 算法 : EigenFaceRecognizer</li><li>FisherFace 算法：FisherFaceRecognizer</li><li>LBPH 算法：LBPHFaceRecognizer</li></ul><p><a href="https://blog.csdn.net/akenseren/article/details/80647276" target="_blank" rel="noopener">网站1</a></p><p><a href="https://www.cnblogs.com/little-monkey/p/8118938.html" target="_blank" rel="noopener">网站2</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Java_com_east_opencv71_FaceDetection_trainingPattern(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    <span class="comment">// 训练样本，这一步是在数据采集做的</span></span><br><span class="line">    <span class="comment">// train it</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Mat&gt; faces;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; labels;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 样本比较少</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">5</span>; ++j) &#123;</span><br><span class="line">            Mat face = imread(format(<span class="string">"/storage/emulated/0/s%d/%d.pgm"</span>, i, j), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (face.empty()) &#123;</span><br><span class="line">                LOGE(<span class="string">"face mat is empty"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 确保大小一致</span></span><br><span class="line">            resize(face, face, Size(<span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">            faces.push_back(face);</span><br><span class="line">            labels.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        Mat face = imread(format(<span class="string">"/storage/emulated/0/face_%d.png"</span>, i), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (face.empty()) &#123;</span><br><span class="line">            LOGE(<span class="string">"face mat is empty"</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resize(face, face, Size(<span class="number">128</span>, <span class="number">128</span>));</span><br><span class="line">        faces.push_back(face);</span><br><span class="line">        labels.push_back(<span class="number">11</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 训练方法</span></span><br><span class="line">    Ptr&lt;BasicFaceRecognizer&gt; model = EigenFaceRecognizer::create();</span><br><span class="line">    <span class="comment">// 采集了八张，同一个人 label 一样</span></span><br><span class="line">    model-&gt;train(faces, labels);</span><br><span class="line">    <span class="comment">// 训练样本是 xml ，本地</span></span><br><span class="line">    model-&gt;save(<span class="string">"/storage/emulated/0/face_darren_pattern.xml"</span>);<span class="comment">// 存的是处理的特征数据</span></span><br><span class="line">    LOGE(<span class="string">"樣本訓練成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-识别人脸"><a href="#2-识别人脸" class="headerlink" title="2. 识别人脸"></a>2. 识别人脸</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Java_com_east_opencv71_FaceDetection_loadPattern(JNIEnv *env, jobject instance,</span><br><span class="line">                                                    jstring patternPath_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *patternPath = env-&gt;GetStringUTFChars(patternPath_, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 加载样本数据，Error:(142, 12) error: no matching member function for call to 'load' 怎么搞？</span></span><br><span class="line">    <span class="comment">// model-&gt;load(patternPath);</span></span><br><span class="line">    <span class="function">FileStorage <span class="title">fs</span><span class="params">(patternPath, FileStorage::READ)</span></span>;</span><br><span class="line">    <span class="comment">// 报错，没有提示</span></span><br><span class="line">    <span class="comment">// CV_Assert(fs.isOpened());</span></span><br><span class="line">    <span class="comment">// 抛个 java 异常</span></span><br><span class="line">    FileNode fn = fs.getFirstTopLevelNode();</span><br><span class="line">    model-&gt;<span class="built_in">read</span>(fn);</span><br><span class="line">    env-&gt;ReleaseStringUTFChars(patternPath_, patternPath);</span><br><span class="line">    LOGE(<span class="string">"训练样本加载成功"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/opencv71&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的opencv71
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：22.实时人脸检测</title>
    <link href="http://eastup.github.io/70.OpenCV-%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/"/>
    <id>http://eastup.github.io/70.OpenCV-%E5%AE%9E%E6%97%B6%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B/</id>
    <published>2019-04-21T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:50.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-相机实时人脸检测"><a href="#1-相机实时人脸检测" class="headerlink" title="1. 相机实时人脸检测"></a>1. 相机实时人脸检测</h1><p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv70" target="_blank" rel="noopener">NDKPractice项目的opencv70</a></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @param 1.1 会采用上采样、下采样、缩放比例</span></span><br><span class="line"><span class="comment">// @param 3 会检测多少次才能判断是个人脸</span></span><br><span class="line"><span class="comment">// @param Size(width/4,height/4) 最小的人脸大小</span></span><br><span class="line"><span class="comment">// @param Size(width,height) 最大的人脸</span></span><br><span class="line">cascadeClassifier.detectMultiScale(gray,faces,<span class="number">1.1</span>,<span class="number">3</span>,<span class="number">0</span>,Size(<span class="built_in">width</span>/<span class="number">4</span>,<span class="built_in">height</span>/<span class="number">4</span>),Size(<span class="built_in">width</span>,<span class="built_in">height</span>));</span><br></pre></td></tr></table></figure><h1 id="2-人脸识别相关：-均值，方差与协方差、特征值与特征向量"><a href="#2-人脸识别相关：-均值，方差与协方差、特征值与特征向量" class="headerlink" title="2. 人脸识别相关： 均值，方差与协方差、特征值与特征向量"></a>2. 人脸识别相关： 均值，方差与协方差、特征值与特征向量</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Mat src = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">50</span>, <span class="number">50</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">70</span>, <span class="number">70</span>);</span><br><span class="line"><span class="comment">// 平均值 ：(50+50+50+...+70) / 9 = 60;</span></span><br><span class="line"><span class="comment">// 标准方差（均方差）：各个数据与平均值之差的平方的和的平均数，再开根号</span></span><br><span class="line"><span class="comment">// ((50-60)的平方 + (50-60)的平方 + (50-60)的平方 + (60-60)的平方... + (70-60)的平方)/9 = 开根号(66.6666666667) = 8.1649658093 </span></span><br><span class="line">Mat mean, stddev; <span class="comment">// mean 平均值，stddev 标准方差</span></span><br><span class="line">meanStdDev(src, mean, stddev);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mean &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; stddev &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========================================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协方差矩阵</span></span><br><span class="line">Mat covar;</span><br><span class="line">calcCovarMatrix(src,covar,mean,COVAR_NORMAL | COVAR_ROWS);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mean &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; covar &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"========================================"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 协方差矩阵再去求特征和特征向量</span></span><br><span class="line">src = (Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">Mat eigenvalues, eigenvectors;</span><br><span class="line">eigen(src, eigenvalues, eigenvectors);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; eigenvalues &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; eigenvectors &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-人脸识别相关：PCA-原理与应用-（降维）"><a href="#3-人脸识别相关：PCA-原理与应用-（降维）" class="headerlink" title="3.人脸识别相关：PCA 原理与应用 （降维）"></a>3.人脸识别相关：PCA 原理与应用 （降维）</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 人脸识别相关：PCA 原理与应用 （降维）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">Mat src = imread(<span class="string">"E:/copy.png"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = src.rows * src.cols;</span><br><span class="line"><span class="function">Mat <span class="title">data</span><span class="params">(<span class="built_in">size</span>,<span class="number">3</span>,CV_8UC1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> row = i / src.cols;</span><br><span class="line"><span class="keyword">int</span> col = i - row * src.cols;</span><br><span class="line"></span><br><span class="line">data.at&lt;uchar&gt;(i, <span class="number">0</span>) = src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line">data.at&lt;uchar&gt;(i, <span class="number">1</span>) = src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line">data.at&lt;uchar&gt;(i, <span class="number">2</span>) = src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终降维的数据</span></span><br><span class="line"><span class="function">PCA <span class="title">pca_analyze</span><span class="params">(data, Mat(), PCA::Flags::DATA_AS_ROW)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pca_analyze.mean &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pca_analyze.eigenvalues &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pca_analyze.eigenvectors &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-相机实时人脸检测&quot;&gt;&lt;a href=&quot;#1-相机实时人脸检测&quot; class=&quot;headerlink&quot; title=&quot;1. 相机实时人脸检测&quot;&gt;&lt;/a&gt;1. 相机实时人脸检测&lt;/h1&gt;&lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://gith
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：21.人脸识别 - HOG 和 LBP 特征检测</title>
    <link href="http://eastup.github.io/69.OpenCV-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%20-%20HOG%20%E5%92%8C%20LBP%20%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/"/>
    <id>http://eastup.github.io/69.OpenCV-%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%20-%20HOG%20%E5%92%8C%20LBP%20%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B/</id>
    <published>2019-04-20T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:45.305Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv69" target="_blank" rel="noopener">NDKPractice项目的opencv69</a></strong></p><p>人脸检测分为以下几步</p><ol><li>特征提取：边缘，角点，点，线，平坦区</li><li>训练样本：正向样，负向样本 （xml文件）</li><li>特征匹配：DDM , detection (发现)  description (描述)  matching (匹配) </li></ol><h1 id="1-HOG-Histogram-of-Oriented-Gradient-特征检测的实现原理"><a href="#1-HOG-Histogram-of-Oriented-Gradient-特征检测的实现原理" class="headerlink" title="1. HOG(Histogram of Oriented Gradient) 特征检测的实现原理"></a>1. HOG(Histogram of Oriented Gradient) 特征检测的实现原理</h1><p><img src="/images/69.hog%E7%89%B9%E5%BE%81.png" alt><br><img src="/images/69.hog%E5%88%86%E7%BD%91%E6%A0%BC%E7%9A%84%E6%A2%AF%E5%BA%A6%E6%96%B9%E5%90%91%E7%9B%B4%E6%96%B9%E5%9B%BE.png" alt><br><img src="/images/69.hog%E5%9D%97%E6%8F%8F%E8%BF%B0%E5%AD%90.png" alt></p><p>HOG特征提取流程可分为5个部分：检测窗口、归一化图像、计算梯度、统计直方图、梯度直方图归一化、得到HOG特征向量，以下介绍下检测窗口</p><h2 id="1-1-检测窗口："><a href="#1-1-检测窗口：" class="headerlink" title="1.1 检测窗口："></a>1.1 检测窗口：</h2><p>HOG通过窗口（window)和块(block)将图像进行分割。通过以细胞(cell)为单位，对图像某一区域的像素值进行数学计算处理。在此先介绍窗口(window)、块(block)和细胞（cell）的概念及之间的联系。</p><ul><li>窗口(window)：将图像按一定大小分割成多个相同的窗口，滑动。</li><li>块（block)：将每个窗口按一定大小分割成多个相同的块，滑动。</li><li>细胞（cell)：将每个窗口按一定大小分割成多个相同的细胞，属于特征提取的单元，静止不动。</li><li>图像(image)-&gt;检测窗口(win)-&gt;图像块(block)-&gt;细胞单元(cell)</li></ul><p><img src="/images/69.hog%E6%A3%80%E6%B5%8B%E7%AA%97%E5%8F%A3.jpg" alt></p><h1 id="2-实现行人检测"><a href="#2-实现行人检测" class="headerlink" title="2. 实现行人检测"></a>2. 实现行人检测</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现行人检测</span></span><br><span class="line"><span class="comment">// 训练样本，直接拿过来用</span></span><br><span class="line">Mat bgr; <span class="comment">// 只能用 bgr 格式的</span></span><br><span class="line">cvtColor(src,bgr,COLOR_BGRA2BGR);</span><br><span class="line">HOGDescriptor descriptor;</span><br><span class="line">descriptor.setSVMDetector(descriptor.getDefaultPeopleDetector());</span><br><span class="line"><span class="built_in">vector</span>&lt;Rect&gt; foundLocations;</span><br><span class="line">descriptor.detectMultiScale(bgr,foundLocations,<span class="number">0</span>,Size(<span class="number">12</span>,<span class="number">12</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; foundLocations.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    rectangle(src,foundLocations[i],Scalar(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>,LINE_AA);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-LBP-（Local-Binary-Patterns）特征介绍"><a href="#3-LBP-（Local-Binary-Patterns）特征介绍" class="headerlink" title="3.LBP （Local Binary Patterns）特征介绍"></a>3.LBP （Local Binary Patterns）特征介绍</h1><p><img src="/images/69.lbp.%E7%89%B9%E5%BE%81.png" alt><br><img src="/images/69.lbp%E8%A1%A8%E8%BE%BE.png" alt></p><h1 id="4-手写-LBP-特征算法实现"><a href="#4-手写-LBP-特征算法实现" class="headerlink" title="4.手写 LBP 特征算法实现"></a>4.手写 LBP 特征算法实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Java_com_east_opencv69_MainActivity_lbpBitmap(JNIEnv *env, jobject thiz, jobject bitmap) &#123;</span><br><span class="line">    <span class="comment">// 自己手写 两套 3*3 考虑步长和角度</span></span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env,bitmap,src);</span><br><span class="line">    Mat gray;</span><br><span class="line">    cvtColor(src,gray,COLOR_BGRA2GRAY);</span><br><span class="line">    <span class="comment">// 3*3 lbp 计算的特征数据</span></span><br><span class="line">    Mat result = Mat::zeros(Size(src.cols - <span class="number">2</span>,src.rows - <span class="number">2</span>),CV_8UC1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有点类似卷积操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; gray.rows - <span class="number">1</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; gray.cols - <span class="number">1</span>; ++col) &#123;</span><br><span class="line">            uchar pixels = gray.at&lt;uchar&gt;(row,col); <span class="comment">// 中心点</span></span><br><span class="line">            <span class="keyword">int</span> rPixels = <span class="number">0</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row<span class="number">-1</span>,col<span class="number">-1</span>)) &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row<span class="number">-1</span>,col)) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row<span class="number">-1</span>,col+<span class="number">1</span>)) &lt;&lt; <span class="number">2</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row,col<span class="number">-1</span>)) &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row,col+<span class="number">1</span>)) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row+<span class="number">1</span>,col<span class="number">-1</span>)) &lt;&lt; <span class="number">6</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row+<span class="number">1</span>,col)) &lt;&lt; <span class="number">5</span>;</span><br><span class="line">            rPixels |= (pixels &lt;= gray.at&lt;uchar&gt;(row+<span class="number">1</span>,col+<span class="number">1</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">            result.at&lt;uchar&gt;(row<span class="number">-1</span>,col<span class="number">-1</span>) = rPixels;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    jobject  resBitmap = cv_helper::createBitmap(env,result.cols,result.rows,src.type());</span><br><span class="line">    cv_helper::mat2bitmap(env,result,resBitmap);</span><br><span class="line">    <span class="keyword">return</span> resBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-haar-特征介绍"><a href="#5-haar-特征介绍" class="headerlink" title="5.haar 特征介绍"></a>5.haar 特征介绍</h1><p><img src="/images/69.Haar%E7%89%B9%E5%BE%81.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/opencv69&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的opencv69
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：20.二维码检测</title>
    <link href="http://eastup.github.io/68.OpenCV-%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%A3%80%E6%B5%8B/"/>
    <id>http://eastup.github.io/68.OpenCV-%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%A3%80%E6%B5%8B/</id>
    <published>2019-04-19T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:34.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-二维码检测"><a href="#1-二维码检测" class="headerlink" title="1.二维码检测"></a>1.二维码检测</h1><p>思路：</p><p><img src="/images/68.%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%A3%80%E6%B5%8B%E6%80%9D%E8%B7%AF.png" alt></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是倾斜的 变换菱形 放正</span></span><br><span class="line"><span class="function">Mat <span class="title">wrapTransfrom</span><span class="params">(<span class="keyword">const</span> Mat &amp;gray,<span class="keyword">const</span> RotatedRect &amp;<span class="built_in">rect</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span> = <span class="built_in">rect</span>.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line"><span class="function">Mat <span class="title">result</span><span class="params">(Size(<span class="built_in">width</span>,<span class="built_in">height</span>),gray.type())</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵怎么获取</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; srcPoints;</span><br><span class="line">Point2f pts[<span class="number">4</span>];</span><br><span class="line"><span class="built_in">rect</span>.points(pts);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">srcPoints.push_back(pts[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;Point&gt; dstPoints;</span><br><span class="line">dstPoints.push_back(Point(<span class="number">0</span>,<span class="number">0</span>));</span><br><span class="line">dstPoints.push_back(Point(<span class="built_in">width</span>, <span class="number">0</span>));</span><br><span class="line">dstPoints.push_back(Point(<span class="built_in">width</span>, <span class="built_in">height</span>));</span><br><span class="line">dstPoints.push_back(Point(<span class="number">0</span>, <span class="built_in">height</span>));</span><br><span class="line"></span><br><span class="line">Mat M = findHomography(srcPoints,dstPoints);</span><br><span class="line">warpPerspective(gray,result,M,result.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isXCorner</span><span class="params">(<span class="keyword">const</span> Mat &amp;qrROI)</span></span>&#123;</span><br><span class="line"><span class="comment">// 四个值</span></span><br><span class="line"><span class="comment">//cb:中心的黑色块数量</span></span><br><span class="line"><span class="comment">//lw:左边的白色块数量</span></span><br><span class="line"><span class="comment">//rw:右边的白色块数量</span></span><br><span class="line"><span class="comment">//lb:左边的黑色块数量</span></span><br><span class="line"><span class="comment">//rb:右边的黑色块数量</span></span><br><span class="line"><span class="keyword">int</span> cb = <span class="number">0</span>, lw = <span class="number">0</span>, rw = <span class="number">0</span>, lb = <span class="number">0</span>, rb = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = qrROI.cols; <span class="comment">//36</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span> = qrROI.rows; <span class="comment">//36</span></span><br><span class="line"><span class="keyword">int</span> cx = <span class="built_in">width</span> / <span class="number">2</span>;  <span class="comment">// 18</span></span><br><span class="line"><span class="keyword">int</span> cy = <span class="built_in">height</span> / <span class="number">2</span>; <span class="comment">// 18</span></span><br><span class="line">uchar pixels = qrROI.at&lt;uchar&gt;(cy, cx);</span><br><span class="line"><span class="keyword">if</span> (pixels == <span class="number">255</span>)&#123; <span class="comment">// 中间肯定是黑色的色块</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求中心黑色</span></span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>, <span class="built_in">end</span> = <span class="number">0</span>, offset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> findleft = <span class="literal">false</span>, findright = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">offset++;</span><br><span class="line"><span class="keyword">if</span> (offset &gt;= cx)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中心点往左边扫</span></span><br><span class="line">pixels = qrROI.at&lt;uchar&gt;(cy, cx - offset);</span><br><span class="line"><span class="keyword">if</span> (!findleft &amp;&amp; pixels == <span class="number">255</span>)&#123;</span><br><span class="line">start = cx - offset; <span class="comment">// 左边白色的像素位置 12</span></span><br><span class="line">findleft = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中心点往右边扫</span></span><br><span class="line">pixels = qrROI.at&lt;uchar&gt;(cy, cx + offset);</span><br><span class="line"><span class="keyword">if</span> (!findright &amp;&amp; pixels == <span class="number">255</span>)&#123;</span><br><span class="line"><span class="built_in">end</span> = cx + offset; <span class="comment">// 右边白色的像素位置  25</span></span><br><span class="line">findright = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (findleft &amp;&amp; findright)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (start == <span class="number">0</span> || <span class="built_in">end</span> == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">cb = <span class="built_in">end</span> - start;</span><br><span class="line"><span class="comment">// 相间的白色</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="built_in">end</span>; col &lt; <span class="built_in">width</span> - <span class="number">1</span>; col++)</span><br><span class="line">&#123;</span><br><span class="line">pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line"><span class="keyword">if</span> (pixels == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">rw++;  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = start; col &gt; <span class="number">0</span>; col--)</span><br><span class="line">&#123;</span><br><span class="line">pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line"><span class="keyword">if</span> (pixels == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">lw++;  <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rw == <span class="number">0</span> || lw == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两边的黑色</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="built_in">end</span>+rw; col &lt; <span class="built_in">width</span> - <span class="number">1</span>; col++)</span><br><span class="line">&#123;</span><br><span class="line">pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line"><span class="keyword">if</span> (pixels == <span class="number">255</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">rb++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = start - lw; col &gt; <span class="number">0</span>; col--)</span><br><span class="line">&#123;</span><br><span class="line">pixels = qrROI.at&lt;uchar&gt;(cy, col);</span><br><span class="line"><span class="keyword">if</span> (pixels == <span class="number">255</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">lb++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rb == <span class="number">0</span> || lb == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sum = cb + lb + rb + lw + rw;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"cx = "</span> &lt;&lt; cx &lt;&lt; <span class="string">",,,cy ="</span> &lt;&lt; cy &lt;&lt; <span class="string">",,,width = "</span> &lt;&lt; <span class="built_in">width</span> &lt;&lt; <span class="string">",,,height ="</span> &lt;&lt; <span class="built_in">height</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"start = "</span> &lt;&lt; start &lt;&lt; <span class="string">",,,end ="</span> &lt;&lt; <span class="built_in">end</span> &lt;&lt; <span class="string">",,,cb ="</span> &lt;&lt; cb &lt;&lt; <span class="string">",,,lw = "</span> &lt;&lt; lw &lt;&lt; <span class="string">",,,rw ="</span> &lt;&lt; rw &lt;&lt; <span class="string">",,,lb ="</span> &lt;&lt; lb &lt;&lt; <span class="string">",,,rb ="</span> &lt;&lt; rb &lt;&lt; <span class="string">",,,sum ="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求比例 3:1:1:1:1</span></span><br><span class="line">cb = (cb / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">lb = (lb / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">rb = (rb / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">lw = (lw / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line">rw = (rw / sum)*<span class="number">7.0</span> + <span class="number">0.5</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"start = "</span> &lt;&lt; start &lt;&lt; <span class="string">",,,end ="</span> &lt;&lt; <span class="built_in">end</span> &lt;&lt; <span class="string">",,,cb ="</span> &lt;&lt; cb &lt;&lt; <span class="string">",,,lw = "</span> &lt;&lt; lw &lt;&lt; <span class="string">",,,rw ="</span> &lt;&lt; rw &lt;&lt; <span class="string">",,,lb ="</span> &lt;&lt; lb &lt;&lt; <span class="string">",,,rb ="</span> &lt;&lt; rb &lt;&lt; <span class="string">",,,sum ="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((cb == <span class="number">3</span> || cb == <span class="number">4</span>) &amp;&amp; (lw == rw) &amp;&amp; (lb == rb) &amp;&amp; (lw == <span class="number">1</span>))&#123;</span><br><span class="line"><span class="comment">// 3:1:1:1:1 或 4:1:1:1:1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最好还是加上</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isYCorner</span><span class="params">(<span class="keyword">const</span> Mat&amp; qrROI)</span></span>&#123;</span><br><span class="line"><span class="comment">// 统计白色像素点和黑色像素点</span></span><br><span class="line"><span class="keyword">int</span> bp = <span class="number">0</span>, wp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">width</span> = qrROI.cols;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span> = qrROI.rows;</span><br><span class="line"><span class="keyword">int</span> cx = <span class="built_in">width</span> / <span class="number">2</span>;  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中心点是黑色</span></span><br><span class="line"><span class="keyword">int</span> pv = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="built_in">height</span>; row++)</span><br><span class="line">&#123;</span><br><span class="line">pv = qrROI.at&lt;uchar&gt;(row, cx);</span><br><span class="line"><span class="keyword">if</span> (pv == <span class="number">0</span>)&#123;</span><br><span class="line">bp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pv == <span class="number">255</span>)&#123;</span><br><span class="line">wp++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bp == <span class="number">0</span> || wp == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (wp * <span class="number">2</span> &gt; bp || bp &gt; <span class="number">4</span> * wp)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/qcode1.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.对图像进行灰度图处理</span></span><br><span class="line">Mat gray;</span><br><span class="line">cvtColor(src,gray,COLOR_BGR2GRAY);</span><br><span class="line"><span class="comment">// 2. 二值化处理</span></span><br><span class="line">threshold(gray,gray,<span class="number">0</span>,<span class="number">255</span>,THRESH_BINARY | THRESH_OTSU);</span><br><span class="line">imshow(<span class="string">"threshold"</span>, gray);</span><br><span class="line"><span class="comment">// 轮廓发现</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;Point&gt;&gt; contours;</span><br><span class="line">findContours(gray,contours,RETR_LIST,CHAIN_APPROX_SIMPLE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; contours.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 过滤面积</span></span><br><span class="line"><span class="keyword">double</span> area = contourArea(contours[i]);</span><br><span class="line"><span class="keyword">if</span> (area &lt; <span class="number">49</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过滤宽高比和宽高大小</span></span><br><span class="line">RotatedRect rRect = minAreaRect(contours[i]);</span><br><span class="line"><span class="keyword">float</span> w = rRect.<span class="built_in">size</span>.<span class="built_in">width</span>;</span><br><span class="line"><span class="keyword">float</span> h = rRect.<span class="built_in">size</span>.<span class="built_in">height</span>;</span><br><span class="line"><span class="keyword">float</span> ratio = <span class="built_in">min</span>(w,h) / <span class="built_in">max</span>(w,h);</span><br><span class="line"><span class="keyword">if</span> (ratio &gt; <span class="number">0.9</span> &amp;&amp; w &lt; gray.cols / <span class="number">2</span> &amp;&amp; h &lt; gray.rows / <span class="number">2</span>)&#123;</span><br><span class="line"><span class="comment">// 去分析，找到满足宽高比的，满足宽高大小的</span></span><br><span class="line">Mat qrROI = wrapTransfrom(gray, rRect);</span><br><span class="line"><span class="keyword">if</span> (isYCorner(qrROI) &amp;&amp; isXCorner(qrROI))&#123;</span><br><span class="line">drawContours(src, contours, i, Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"dstsrc"</span>,src);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-二维码检测&quot;&gt;&lt;a href=&quot;#1-二维码检测&quot; class=&quot;headerlink&quot; title=&quot;1.二维码检测&quot;&gt;&lt;/a&gt;1.二维码检测&lt;/h1&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/68.%E4%BA%8C%E7%BB%B4
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：19.人脸美容效果2-边缘处理</title>
    <link href="http://eastup.github.io/67.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C2-%E8%BE%B9%E7%BC%98%E5%A4%84%E7%90%86/"/>
    <id>http://eastup.github.io/67.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C2-%E8%BE%B9%E7%BC%98%E5%A4%84%E7%90%86/</id>
    <published>2019-04-18T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:28.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-快速边缘保留算法"><a href="#1-快速边缘保留算法" class="headerlink" title="1.快速边缘保留算法"></a>1.快速边缘保留算法</h1><p>先看两张图：</p><p><img src="/images/66.%E5%BF%AB%E9%80%9F%E8%BE%B9%E7%BC%98%E4%BF%9D%E7%95%99%E7%AE%97%E6%B3%95.png" alt></p><p><img src="/images/66.%E5%B1%80%E9%83%A8%E6%96%B9%E5%B7%AE%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC.png" alt></p><p>具体代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 快速边缘保留</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 快速边缘保留</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getBlockSum</span><span class="params">(Mat &amp;sum_mat,<span class="keyword">int</span> x0,<span class="keyword">int</span> y0,<span class="keyword">int</span> x1,<span class="keyword">int</span> y1,<span class="keyword">int</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取四个点的值（因为肯定会超过 255 所以需要用Vec3i 来装）</span></span><br><span class="line">    <span class="keyword">int</span> lt = sum_mat.at&lt;Vec3i&gt;(y0, x0)[ch];</span><br><span class="line">    <span class="keyword">int</span> lb = sum_mat.at&lt;Vec3i&gt;(y1, x0)[ch];</span><br><span class="line">    <span class="keyword">int</span> rt = sum_mat.at&lt;Vec3i&gt;(y0, x1)[ch];</span><br><span class="line">    <span class="keyword">int</span> rb = sum_mat.at&lt;Vec3i&gt;(y1, x1)[ch];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区块的合</span></span><br><span class="line">    <span class="keyword">int</span> sum = rb - lb - rt + lt;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getBlockSqSum</span><span class="params">(Mat &amp;sqsum_mat, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> ch)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 获取四个点的值（因为肯定会超过 255 所以需要用Vec3f 来装）</span></span><br><span class="line">    <span class="keyword">float</span> lt = sqsum_mat.at&lt;Vec3f&gt;(y0, x0)[ch];</span><br><span class="line">    <span class="keyword">float</span> lb = sqsum_mat.at&lt;Vec3f&gt;(y1, x0)[ch];</span><br><span class="line">    <span class="keyword">float</span> rt = sqsum_mat.at&lt;Vec3f&gt;(y0, x1)[ch];</span><br><span class="line">    <span class="keyword">float</span> rb = sqsum_mat.at&lt;Vec3f&gt;(y1, x1)[ch];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 区块的合</span></span><br><span class="line">    <span class="keyword">float</span> sqsum = rb - lb - rt + lt;</span><br><span class="line">    <span class="keyword">return</span> sqsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 积分图的模糊算法 size 模糊的直径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fastBlateralBlur</span><span class="params">(Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> <span class="built_in">size</span>,<span class="keyword">int</span> sigma)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 卷积的 size 必须确保为基数 size % 2 == 1</span></span><br><span class="line">    <span class="comment">// 填充周围，方便计算</span></span><br><span class="line">    Mat mat;</span><br><span class="line">    <span class="keyword">int</span> radius = <span class="built_in">size</span> / <span class="number">2</span>;</span><br><span class="line">    copyMakeBorder(src,mat,radius,radius,radius,radius,BORDER_DEFAULT);</span><br><span class="line">    <span class="comment">// 求积分图</span></span><br><span class="line">    Mat sum_mat, sqsum_mat;</span><br><span class="line">    integral(mat,sum_mat,sqsum_mat,CV_32S,CV_32F);</span><br><span class="line"></span><br><span class="line">    dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">    <span class="keyword">int</span> channels = src.channels();</span><br><span class="line">    <span class="keyword">int</span> area = <span class="built_in">size</span> * <span class="built_in">size</span>;</span><br><span class="line">    <span class="comment">// 求四个点，左上，左下，右上，右下</span></span><br><span class="line">    <span class="keyword">int</span> x0 = <span class="number">0</span>, x1 = <span class="number">0</span>, y0 = <span class="number">0</span>, y1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        y0 = row;</span><br><span class="line">        y1 = y0 + <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            x0 = col;</span><br><span class="line">            x1 = x0 + <span class="built_in">size</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; channels; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 区块的合</span></span><br><span class="line">                <span class="keyword">int</span> sum = getBlockSum(sum_mat,x0,y0,x1,y1,i);</span><br><span class="line">                <span class="keyword">float</span> sqsum = getBlockSqSum(sqsum_mat, x0, y0, x1, y1, i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">float</span> diff_sq = (sqsum - (sum*sum) / area) / area;</span><br><span class="line">                <span class="keyword">float</span> k = diff_sq / (diff_sq + sigma);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> pixels = src.at&lt;Vec3b&gt;(row, col)[i];</span><br><span class="line">                pixels = (<span class="number">1</span> - k)*(sum / area) + k * pixels;</span><br><span class="line"></span><br><span class="line">                dst.at&lt;Vec3b&gt;(row, col)[i] = pixels;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">skinDetect</span><span class="params">(Mat &amp;src, Mat &amp;skinMask)</span></span>&#123;</span><br><span class="line">    skinMask.create(src.<span class="built_in">size</span>(),CV_8UC1);</span><br><span class="line">    <span class="keyword">int</span> rows = src.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = src.cols;</span><br><span class="line"></span><br><span class="line">    Mat ycrcb;</span><br><span class="line">    cvtColor(src,ycrcb,COLOR_BGR2YCrCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            Vec3b pixels = ycrcb.at&lt;Vec3b&gt;(row, col);</span><br><span class="line">            uchar y = pixels[<span class="number">0</span>];</span><br><span class="line">            uchar cr = pixels[<span class="number">1</span>];</span><br><span class="line">            uchar cb = pixels[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (y&gt;<span class="number">80</span> &amp;&amp; <span class="number">85</span> &lt; cb &lt; <span class="number">135</span> &amp;&amp; <span class="number">135</span> &lt; cr &lt; <span class="number">180</span>)&#123;</span><br><span class="line">                <span class="comment">// 255 代表人脸区域</span></span><br><span class="line">                skinMask.at&lt;uchar&gt;(row,col) = <span class="number">255</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                skinMask.at&lt;uchar&gt;(row, col) = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fuseSkin</span><span class="params">(Mat &amp;src,Mat &amp;blur_mat, Mat &amp;dst, Mat &amp;skinMask)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 融合</span></span><br><span class="line">    dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">    <span class="comment">// 处理一些区域，平滑点(所以有些地方的数值就不是0 或者 255了)</span></span><br><span class="line">    GaussianBlur(skinMask, skinMask, Size(<span class="number">3</span>, <span class="number">3</span>), <span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    Mat skinMask_f;</span><br><span class="line">    skinMask.convertTo(skinMask_f, CV_32F);</span><br><span class="line"></span><br><span class="line">    normalize(skinMask_f, skinMask_f, <span class="number">0.0</span>, <span class="number">1.0</span>, NORM_MINMAX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rows = src.rows;</span><br><span class="line">    <span class="keyword">int</span> cols = src.cols;</span><br><span class="line">    <span class="keyword">int</span> ch = src.channels();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; row++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; col++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 有的区域还是有可能不够平滑</span></span><br><span class="line">            <span class="comment">/*uchar mask_pixels = skinMask.at&lt;uchar&gt;(row, col);</span></span><br><span class="line"><span class="comment">            // 皮肤位置</span></span><br><span class="line"><span class="comment">            if (mask_pixels == 255)&#123;</span></span><br><span class="line"><span class="comment">                dst.at&lt;Vec3b&gt;(row, col) = blur_mat.at&lt;Vec3b&gt;(row,col);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            else&#123;</span></span><br><span class="line"><span class="comment">                dst.at&lt;Vec3b&gt;(row, col) = src.at&lt;Vec3b&gt;(row, col);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// src ，通过指针去获取， 指针 -&gt; Vec3b -&gt; 获取</span></span><br><span class="line">            uchar b_src = src.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line">            uchar g_src = src.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line">            uchar r_src = src.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// blur_mat</span></span><br><span class="line">            uchar b_blur = blur_mat.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>];</span><br><span class="line">            uchar g_blur = blur_mat.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>];</span><br><span class="line">            uchar r_blur = blur_mat.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">float</span> k = skinMask_f.at&lt;<span class="keyword">float</span>&gt;(row, col); <span class="comment">// k == 1的时候，人脸区域需要取b_blur，否则取b_src</span></span><br><span class="line"></span><br><span class="line">            dst.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = b_blur*k + (<span class="number">1</span> - k)*b_src;</span><br><span class="line">            dst.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = g_blur*k + (<span class="number">1</span> - k)*g_src;</span><br><span class="line">            dst.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = r_blur*k + (<span class="number">1</span> - k)*r_src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高斯（模糊），计算高斯卷积核，卷积操作，考虑像素之间的差值（更好的保留图像的边缘）</span></span><br><span class="line"></span><br><span class="line">    Mat blur_mat;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">12</span>; <span class="comment">// size == 10001 时 time = 1 秒</span></span><br><span class="line">    fastBlateralBlur(src, blur_mat, <span class="built_in">size</span>, <span class="built_in">size</span>*<span class="built_in">size</span>);</span><br><span class="line">    imshow(<span class="string">"fastBlateralBlur"</span>, blur_mat);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 皮肤区域检测</span></span><br><span class="line">    Mat skinMask;</span><br><span class="line">    skinDetect(src, skinMask);</span><br><span class="line">    imshow(<span class="string">"skinDetect"</span>, skinMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//皮肤区域融合</span></span><br><span class="line">    Mat fuseDst;</span><br><span class="line">    fuseSkin(src, blur_mat, fuseDst, skinMask);</span><br><span class="line">    imshow(<span class="string">"fuseSkin"</span>, fuseDst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边缘的提升（可有可无）</span></span><br><span class="line">    Mat cannyMask;</span><br><span class="line">    Canny(src,cannyMask,<span class="number">150</span>,<span class="number">300</span>,<span class="number">3</span>,<span class="literal">false</span>);</span><br><span class="line">    imshow(<span class="string">"cannyMask"</span>, cannyMask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于 &amp; 运算</span></span><br><span class="line">    bitwise_and(src,src,fuseDst,cannyMask);</span><br><span class="line">    imshow(<span class="string">"bitwise_and"</span>, fuseDst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 稍微提升一下对比度（亮度）</span></span><br><span class="line">    add(fuseDst,Scalar(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),fuseDst);</span><br><span class="line">    imshow(<span class="string">"add"</span>, fuseDst);</span><br><span class="line"></span><br><span class="line">    waitKey(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-快速边缘保留算法&quot;&gt;&lt;a href=&quot;#1-快速边缘保留算法&quot; class=&quot;headerlink&quot; title=&quot;1.快速边缘保留算法&quot;&gt;&lt;/a&gt;1.快速边缘保留算法&lt;/h1&gt;&lt;p&gt;先看两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/66.%E5
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：18.人脸美容效果-积分图</title>
    <link href="http://eastup.github.io/66.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C-%E7%A7%AF%E5%88%86%E5%9B%BE/"/>
    <id>http://eastup.github.io/66.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C-%E7%A7%AF%E5%88%86%E5%9B%BE/</id>
    <published>2019-04-17T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:23.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-双边滤波美容"><a href="#1-双边滤波美容" class="headerlink" title="1. 双边滤波美容"></a>1. 双边滤波美容</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line">Mat dst;</span><br><span class="line">bilateralFilter(src,dst,<span class="number">0</span>,<span class="number">100</span>,<span class="number">5</span>);</span><br><span class="line">imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-卷积模糊算法，时间复杂度分析"><a href="#2-卷积模糊算法，时间复杂度分析" class="headerlink" title="2.卷积模糊算法，时间复杂度分析"></a>2.卷积模糊算法，时间复杂度分析</h1><p><code>时间复杂度 = src.rows * src.cols * size * size</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯（模糊），计算高斯卷积核，卷积操作，考虑像素之间的差值（更好的保留图像的边缘）</span></span><br><span class="line"></span><br><span class="line">Mat dst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">10000</span>;</span><br><span class="line">Mat kernel = Mat::ones(<span class="built_in">size</span>, <span class="built_in">size</span>, CV_32FC1) / (<span class="built_in">size</span> * <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> st = clock();</span><br><span class="line">filter2D(src,dst,src.depth(),kernel);</span><br><span class="line"><span class="keyword">long</span> et = clock();</span><br><span class="line"><span class="keyword">double</span> time = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;((et - st) / CLOCKS_PER_SEC);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"time = "</span> &lt;&lt; time &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//时间复杂度 = src.rows * src.cols * size * size</span></span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-积分图算法介绍"><a href="#3-积分图算法介绍" class="headerlink" title="3. 积分图算法介绍"></a>3. 积分图算法介绍</h1><p>看图更明白些：</p><p><img src="/images/66.%E7%A7%AF%E5%88%86%E5%9B%BE%E8%AE%A1%E7%AE%97.png" alt></p><h1 id="4-使用积分图算法对卷积模糊进行优化"><a href="#4-使用积分图算法对卷积模糊进行优化" class="headerlink" title="4. 使用积分图算法对卷积模糊进行优化"></a>4. 使用积分图算法对卷积模糊进行优化</h1><p>使用到的 api</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @param sum ：积分和表</span></span><br><span class="line"><span class="comment">// @param sqsum ：平方和表</span></span><br><span class="line"><span class="comment">// @param sdepth ：积分和表的深度</span></span><br><span class="line"><span class="comment">// @param sqdepth ：平方和表的深度 如果是：CV_32F，计算的时候就以 float 计算</span></span><br><span class="line">CV_EXPORTS_AS(integral2) <span class="function"><span class="keyword">void</span> <span class="title">integral</span><span class="params">( InputArray src, OutputArray sum,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        OutputArray sqsum, <span class="keyword">int</span> sdepth = <span class="number">-1</span>, <span class="keyword">int</span> sqdepth = <span class="number">-1</span> )</span></span>;</span><br></pre></td></tr></table></figure><p><img src="/images/66.%E7%A7%AF%E5%88%86%E5%9B%BE%E7%9A%84%E6%A8%A1%E7%B3%8A%E7%AE%97%E6%B3%95.png" alt></p><p><code>Vec3b:vector&lt;uchar, 3&gt; 不能超过 255</code></p><p><code>Vec3i:vector&lt;int, 3&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">meanBlur</span><span class="params">(Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> <span class="built_in">size</span>)</span></span>&#123;</span><br><span class="line"><span class="comment">// 卷积的 size 必须确保为基数 size % 2 == 1</span></span><br><span class="line"><span class="comment">// 填充周围，方便计算</span></span><br><span class="line">Mat mat;</span><br><span class="line"><span class="keyword">int</span> radius = <span class="built_in">size</span> / <span class="number">2</span>;</span><br><span class="line">copyMakeBorder(src,mat,radius,radius,radius,radius,BORDER_DEFAULT);</span><br><span class="line"><span class="comment">// 求积分图</span></span><br><span class="line">Mat sum_mat, sqsum_mat;</span><br><span class="line">integral(mat,sum_mat,sqsum_mat,CV_32S,CV_32S);</span><br><span class="line"></span><br><span class="line">dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line"><span class="keyword">int</span> channels = src.channels();</span><br><span class="line"><span class="keyword">int</span> area = <span class="built_in">size</span> * <span class="built_in">size</span>;</span><br><span class="line"><span class="comment">// 求四个点，左上，左下，右上，右下</span></span><br><span class="line"><span class="keyword">int</span> x0 = <span class="number">0</span>, x1 = <span class="number">0</span>, y0 = <span class="number">0</span>, y1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">&#123;</span><br><span class="line">y0 = row;</span><br><span class="line">y1 = y0 + <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">&#123;</span><br><span class="line">x0 = col;</span><br><span class="line">x1 = x0 + <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; channels; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取四个点的值</span></span><br><span class="line"><span class="keyword">int</span> lt = sum_mat.at&lt;Vec3i&gt;(y0, x0)[i];</span><br><span class="line"><span class="keyword">int</span> lb = sum_mat.at&lt;Vec3i&gt;(y1, x0)[i];</span><br><span class="line"><span class="keyword">int</span> rt = sum_mat.at&lt;Vec3i&gt;(y0, x1)[i];</span><br><span class="line"><span class="keyword">int</span> rb = sum_mat.at&lt;Vec3i&gt;(y1, x1)[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区块的合</span></span><br><span class="line"><span class="keyword">int</span> sum = rb - lb - rt + lt;</span><br><span class="line">dst.at&lt;Vec3b&gt;(row, col)[i] = sum / area;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/meirong.jpg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯（模糊），计算高斯卷积核，卷积操作，考虑像素之间的差值（更好的保留图像的边缘）</span></span><br><span class="line"></span><br><span class="line">Mat dst;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">15</span>; <span class="comment">// size == 10001 时 time = 1 秒</span></span><br><span class="line"><span class="keyword">long</span> st = clock();</span><br><span class="line">meanBlur(src,dst,<span class="built_in">size</span>);</span><br><span class="line"><span class="keyword">long</span> et = clock();</span><br><span class="line"><span class="keyword">double</span> time = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;((et - st) / CLOCKS_PER_SEC);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"time = "</span> &lt;&lt; time &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"dst"</span>, dst);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-快速边缘保留算法"><a href="#5-快速边缘保留算法" class="headerlink" title="5.快速边缘保留算法"></a>5.快速边缘保留算法</h1><p>先看两张图：</p><p><img src="/images/66.%E5%BF%AB%E9%80%9F%E8%BE%B9%E7%BC%98%E4%BF%9D%E7%95%99%E7%AE%97%E6%B3%95.png" alt></p><p><img src="/images/66.%E5%B1%80%E9%83%A8%E6%96%B9%E5%B7%AE%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC.png" alt></p><p>具体的请看<a href="https://github.com/EastUp/CPractice/blob/master/markdown/67.OpenCV-%E4%BA%BA%E8%84%B8%E7%BE%8E%E5%AE%B9%E6%95%88%E6%9E%9C2-%E8%BE%B9%E7%BC%98%E5%A4%84%E7%90%86.md" target="_blank" rel="noopener">67.人脸美容效果2-边缘处理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-双边滤波美容&quot;&gt;&lt;a href=&quot;#1-双边滤波美容&quot; class=&quot;headerlink&quot; title=&quot;1. 双边滤波美容&quot;&gt;&lt;/a&gt;1. 双边滤波美容&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cl
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：17.手写直方图和直方均衡</title>
    <link href="http://eastup.github.io/65.OpenCV-%E6%89%8B%E5%86%99%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%92%8C%E7%9B%B4%E6%96%B9%E5%9D%87%E8%A1%A1/"/>
    <id>http://eastup.github.io/65.OpenCV-%E6%89%8B%E5%86%99%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%92%8C%E7%9B%B4%E6%96%B9%E5%9D%87%E8%A1%A1/</id>
    <published>2019-04-16T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:17.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-亮度增强-线性方式"><a href="#1-亮度增强-线性方式" class="headerlink" title="1.亮度增强(线性方式)"></a>1.亮度增强(线性方式)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"src"</span>,src);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; src.channels() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">Mat dst = src.clone();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">&#123;</span><br><span class="line">Vec3b pixels = src.at&lt;Vec3b&gt;(row,col);</span><br><span class="line">dst.at&lt;Vec3b&gt;(row, col)[<span class="number">0</span>] = saturate_cast&lt;uchar&gt;(pixels[<span class="number">0</span>] + <span class="number">30</span>);</span><br><span class="line">dst.at&lt;Vec3b&gt;(row, col)[<span class="number">1</span>] = saturate_cast&lt;uchar&gt;(pixels[<span class="number">1</span>] + <span class="number">30</span>);</span><br><span class="line">dst.at&lt;Vec3b&gt;(row, col)[<span class="number">2</span>] = saturate_cast&lt;uchar&gt;(pixels[<span class="number">2</span>] + <span class="number">30</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"dst"</span>,dst);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-直方均衡，提升对比度"><a href="#2-直方均衡，提升对比度" class="headerlink" title="2.直方均衡，提升对比度"></a>2.直方均衡，提升对比度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">Mat hsv;</span><br><span class="line">cvtColor(src,hsv,COLOR_BGR2HSV);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Mat&gt; hsv_s;</span><br><span class="line">split(hsv,hsv_s);</span><br><span class="line"></span><br><span class="line">equalizeHist(hsv_s[<span class="number">2</span>],hsv_s[<span class="number">2</span>]);</span><br><span class="line">merge(hsv_s,hsv);</span><br><span class="line">cvtColor(hsv,src,COLOR_HSV2BGR);</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"dst"</span>,src);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-手写直方图计算源码"><a href="#3-手写直方图计算源码" class="headerlink" title="3. 手写直方图计算源码"></a>3. 手写直方图计算源码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写直方图计算源码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcHist</span><span class="params">(<span class="keyword">const</span> Mat &amp;mat,Mat &amp;hist)</span></span>&#123;</span><br><span class="line"><span class="comment">// int 存</span></span><br><span class="line">hist.create(<span class="number">1</span>, <span class="number">256</span>, CV_32S);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hist.cols; i++)</span><br><span class="line">&#123;</span><br><span class="line">hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, i) = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; mat.rows; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; mat.cols; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 灰度等级的角标</span></span><br><span class="line"><span class="keyword">int</span> index = mat.at&lt;uchar&gt;(row, col);</span><br><span class="line">hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, index) += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">normalize</span><span class="params">(<span class="keyword">const</span> Mat &amp;src, Mat &amp;dst, <span class="keyword">int</span> n_max)</span></span>&#123;</span><br><span class="line"><span class="comment">// 0 ~ n_max;</span></span><br><span class="line"><span class="keyword">int</span> max_value = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> value = src.at&lt;<span class="keyword">int</span>&gt;(row, col);</span><br><span class="line">max_value = <span class="built_in">max</span>(value, max_value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> value = src.at&lt;<span class="keyword">int</span>&gt;(row, col);</span><br><span class="line">dst.at&lt;<span class="keyword">int</span>&gt;(row, col) = <span class="number">1.0</span> * value / max_value * n_max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 手写直方图计算源码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">Mat gray;</span><br><span class="line">cvtColor(src,gray,COLOR_BGR2GRAY);</span><br><span class="line">imshow(<span class="string">"gray"</span>,gray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// hist 没有宽高，是生成了一个空的数组</span></span><br><span class="line">Mat hist;</span><br><span class="line">calcHist(gray,hist);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hist &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画直方图，归一化</span></span><br><span class="line">normalize(hist,hist,<span class="number">255</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hist &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 画直方图</span></span><br><span class="line"><span class="keyword">int</span> bin_w = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> grad = <span class="number">256</span>;</span><br><span class="line"><span class="function">Mat <span class="title">hist_mat</span><span class="params">(grad,bin_w * <span class="number">256</span>,CV_8UC3)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grad; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">Point <span class="title">start</span><span class="params">(i*bin_w, hist_mat.rows)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">end</span><span class="params">(i*bin_w, hist_mat.rows - hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>,i))</span></span>;</span><br><span class="line"><span class="built_in">line</span>(hist_mat, start, <span class="built_in">end</span>, Scalar(<span class="number">255</span>, <span class="number">0</span>, <span class="number">255</span>), bin_w, LINE_AA);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"hist_mat"</span>,hist_mat);</span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-手写直方图均衡"><a href="#4-手写直方图均衡" class="headerlink" title="4. 手写直方图均衡"></a>4. 手写直方图均衡</h1><p>假设有如下图像：</p><p><img src="/images/65.1.jpg" alt></p><p>得图像的统计信息如下图所示，并根据统计信息完成灰度值映射:  </p><p><img src="/images/65.2.jpg" alt></p><p>映射后的图像如下所示：  </p><p><img src="/images/65.3.jpg" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4.1 直方图的统计</span></span><br><span class="line"><span class="comment">// 4.2 计算直方图中像素的概率</span></span><br><span class="line"><span class="comment">// 4.3 生成一张映射表(255 * 累加概率)</span></span><br><span class="line"><span class="comment">// 4.4 从映射表中查找赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">equalizeHist</span><span class="params">(Mat &amp;src,Mat &amp;dst)</span></span>&#123;</span><br><span class="line">Mat hist;</span><br><span class="line"><span class="comment">// 1.直方图的统计</span></span><br><span class="line">calcHist(src,hist);</span><br><span class="line"><span class="comment">// 2.计算直方图中像素的概率</span></span><br><span class="line"><span class="function">Mat <span class="title">prob_mat</span><span class="params">(hist.<span class="built_in">size</span>(),CV_32FC1)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> image_size = src.rows * src.cols; <span class="comment">// 这个就是总的次数，因为每个像素值都算一次</span></span><br><span class="line"><span class="comment">/*float image_size = 0;</span></span><br><span class="line"><span class="comment">for (int i = 0; i &lt; hist.cols; i++)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">image_size += hist.at&lt;int&gt;(0, i);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hist.cols; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> times = hist.at&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, i);</span><br><span class="line"><span class="keyword">float</span> prob = times / image_size;</span><br><span class="line">prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) = prob;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. 计算累加概率 256 （可读）</span></span><br><span class="line"><span class="keyword">float</span> prob_sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hist.cols; i++)</span><br><span class="line">&#123;</span><br><span class="line">prob_sum += prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i);</span><br><span class="line">prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) = prob_sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成映射表</span></span><br><span class="line"><span class="function">Mat <span class="title">map</span><span class="params">(hist.<span class="built_in">size</span>(), CV_32FC1)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prob_mat.cols; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">map</span>.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i) = <span class="number">255</span> * prob_mat.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, i); <span class="comment">// 255 * 概率</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst.create(src.<span class="built_in">size</span>(), src.type());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; col++)</span><br><span class="line">&#123;</span><br><span class="line">uchar pixels = src.at&lt;uchar&gt;(row, col);</span><br><span class="line">dst.at&lt;uchar&gt;(row, col) = <span class="built_in">map</span>.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>,pixels);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">Mat src = imread(<span class="string">"E:/2_05.jpg"</span>);</span><br><span class="line"><span class="keyword">if</span> (!src.data)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"read error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">imshow(<span class="string">"src"</span>, src);</span><br><span class="line"></span><br><span class="line">Mat gray;</span><br><span class="line">cvtColor(src, gray, COLOR_BGR2GRAY);</span><br><span class="line">imshow(<span class="string">"gray"</span>, gray);</span><br><span class="line">equalizeHist(gray,gray);</span><br><span class="line">imshow(<span class="string">"dst"</span>,gray);</span><br><span class="line"></span><br><span class="line"><span class="comment">//vector&lt;Mat&gt; channels;</span></span><br><span class="line"><span class="comment">//split(src,channels);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat blue = channels.at(0);</span></span><br><span class="line"><span class="comment">//Mat green = channels.at(0);</span></span><br><span class="line"><span class="comment">//Mat red = channels.at(0);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//equalizeHist(blue, blue);</span></span><br><span class="line"><span class="comment">//equalizeHist(green, green);</span></span><br><span class="line"><span class="comment">//equalizeHist(red, red);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mat dst;</span></span><br><span class="line"><span class="comment">//merge(channels, dst);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//imshow("dst", dst);</span></span><br><span class="line"></span><br><span class="line">waitKey(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-亮度增强-线性方式&quot;&gt;&lt;a href=&quot;#1-亮度增强-线性方式&quot; class=&quot;headerlink&quot; title=&quot;1.亮度增强(线性方式)&quot;&gt;&lt;/a&gt;1.亮度增强(线性方式)&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;tabl
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：16.封装 java 层 sdk 模型</title>
    <link href="http://eastup.github.io/64.OpenCV-%E5%B0%81%E8%A3%85%20java%20%E5%B1%82%20sdk%20%E6%A8%A1%E5%9E%8B/"/>
    <id>http://eastup.github.io/64.OpenCV-%E5%B0%81%E8%A3%85%20java%20%E5%B1%82%20sdk%20%E6%A8%A1%E5%9E%8B/</id>
    <published>2019-04-15T00:12:43.000Z</published>
    <updated>2020-11-11T07:09:07.104Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv64" target="_blank" rel="noopener">NDKPractice项目的opencv64</a></strong></p><p>小的需求：<code>优化下Bitmap加载图片的源码（严格控制下内存）</code></p><h1 id="1-苏宁体育面试题讲解（一面）"><a href="#1-苏宁体育面试题讲解（一面）" class="headerlink" title="1. 苏宁体育面试题讲解（一面）"></a>1. 苏宁体育面试题讲解（一面）</h1><ul><li>HashMap 的实现，如何判断超出了原存储空间，超出了如何扩容，如果存入 key 相同，值如何存入。（之前手写过）</li><li>你所了解的设计模式，谈谈你对工厂设计模式的理解，单例设计模式如何避免内存泄露</li><li>事件分发机制</li><li>二叉树找最大</li><li>Activity 的启动模式，几种模式具体的应用。</li><li>静态方法存储在哪儿，堆和栈的垃圾回收机制</li></ul><p>面试考两点：1.<code>基础牢不牢</code>　2.<code>能不能搞定目前的项目</code></p><h1 id="2-NDK-学到什么程度"><a href="#2-NDK-学到什么程度" class="headerlink" title="2. NDK 学到什么程度"></a>2. NDK 学到什么程度</h1><p>c/c++ 少不了，基础，进阶，linux内核，shell脚本，cmake语法<br>opencv,ffmpeg<br>android开发：c/c++工程师开发（精通），java 工程师(精通)，native 和 java 层互通 NDK 开发(熟悉c/c++,熟悉android)  </p><ul><li>知道：有这么个东西，模糊  </li><li>熟悉：知道这个东西，讲明白，项目中也能直接用上  </li><li>精通：知道这个东西，讲明白，项目中也能直接用，知道原理（四种启动模式，怎么解析，怎么压栈弹栈，声明周期怎么调用）    </li></ul><p>读：第三方的源码，opencv，ffmpeg,openGL,android native.<br>写：那么多套路    </p><p>部门：引擎部门（.so库，java的sdk）有专门的 c/c++ 工程师，android 应用层开发</p><h1 id="3-如何封装-java-层-sdk-模型"><a href="#3-如何封装-java-层-sdk-模型" class="headerlink" title="3.如何封装 java 层 sdk 模型"></a>3.如何封装 java 层 sdk 模型</h1><p>假设我对一张图片做操作  </p><ul><li>掩膜操作</li><li>模糊操作</li><li>又来一个关于 filter2D 的操作</li></ul><p>规则考虑周到</p><ul><li>细节拆分</li><li>尽量不要改 native 层的代码，可以改 java 层的（<code>针对上面的需求可以把 filter2D 方法提到 java 层</code>）</li><li>思考：时间空间复杂度</li></ul><h1 id="4-动手封装OpenCV的Mat-java-对象"><a href="#4-动手封装OpenCV的Mat-java-对象" class="headerlink" title="4.动手封装OpenCV的Mat.java 对象"></a>4.动手封装OpenCV的Mat.java 对象</h1><p>filter2D -&gt; Mat  </p><p>Java层的Mat.java 对应 native 层的 Mat.cpp  </p><p>Java层写 Mat.java -&gt; Bitmap.java, Bitmap.java -&gt; Mat.java</p><h1 id="5-NDK异常处理需要注意的地方"><a href="#5-NDK异常处理需要注意的地方" class="headerlink" title="5.NDK异常处理需要注意的地方"></a>5.NDK异常处理需要注意的地方</h1><p>在前面有篇博客讲过 NDK 中的异常处理</p><h1 id="6-java和C-的回收机制"><a href="#6-java和C-的回收机制" class="headerlink" title="6.java和C++的回收机制"></a>6.java和C++的回收机制</h1><p>java的 GC 会调用 <code>finalize</code> 方法。</p><p>c 中需要自己回收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/opencv64&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的opencv64
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
      <category term="面试" scheme="http://eastup.github.io/categories/OpenCV/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="http://eastup.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV：15.图片的几何变换</title>
    <link href="http://eastup.github.io/63.OpenCV-%E5%9B%BE%E7%89%87%E7%9A%84%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/"/>
    <id>http://eastup.github.io/63.OpenCV-%E5%9B%BE%E7%89%87%E7%9A%84%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2/</id>
    <published>2019-04-14T00:12:43.000Z</published>
    <updated>2020-11-11T07:08:58.827Z</updated>
    
    <content type="html"><![CDATA[<p>具体代码请看：<strong><a href="https://github.com/EastUp/NDKPractice/tree/master/opencv63" target="_blank" rel="noopener">NDKPractice项目的opencv63</a></strong></p><h1 id="1-图片旋转"><a href="#1-图片旋转" class="headerlink" title="1. 图片旋转"></a>1. 图片旋转</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Java_com_east_opencv63_OpenCvUtils_rotation(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res_w = src.rows; <span class="comment">// 图片的宽</span></span><br><span class="line">    <span class="keyword">int</span> res_h = src.cols; <span class="comment">// 图片的高</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(res_h, res_w, src.type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理输出图像的下半部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; res_h; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; res_w; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (src.type() == CV_8UC4)</span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col) = src.at&lt;Vec4b&gt;(src.rows - col, row);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC2)</span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col) = src.at&lt;Vec3b&gt;(src.rows - col, row);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC1)</span><br><span class="line">                res.at&lt;uchar&gt;(row, col) = src.at&lt;uchar&gt;(src.rows - col, row);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的bitmap 宽是原来的高，高是原来的宽</span></span><br><span class="line">    jobject newBitmap = bitmap_util::create_bitmap(env, res_w, res_h, res.type());</span><br><span class="line">    cv_helper::mat2bitmap(env, res, newBitmap);</span><br><span class="line">    <span class="keyword">return</span> newBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-矩阵仿射变换"><a href="#2-矩阵仿射变换" class="headerlink" title="2. 矩阵仿射变换"></a>2. 矩阵仿射变换</h1><p>使用到的 api </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// center 旋转中心点  angle 逆时针 scale 缩放比例</span></span><br><span class="line"><span class="function">Mat <span class="title">getRotationMatrix2D</span><span class="params">(Point2f center, <span class="keyword">double</span> angle, <span class="keyword">double</span> scale)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 图像仿射变换的 用到的 api</span></span></span><br><span class="line"><span class="function">CV_EXPORTS_W <span class="keyword">void</span> <span class="title">warpAffine</span><span class="params">( InputArray src, OutputArray dst,</span></span></span><br><span class="line"><span class="function"><span class="params">                              InputArray M, Size dsize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> flags = INTER_LINEAR,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> borderMode = BORDER_CONSTANT,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> Scalar&amp; borderValue = Scalar())</span></span>;</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片仿射变换</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_east_opencv63_OpenCvUtils_warpAffine(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(src.<span class="built_in">size</span>(), src.type())</span></span>;</span><br><span class="line">    <span class="comment">/*Mat M(2,3,CV_32FC1);</span></span><br><span class="line"><span class="comment">    // 这几个值应该怎么确定？</span></span><br><span class="line"><span class="comment">    // [a0,a1,a2]     两个矩阵    [a0,a1]    [a2]       =     [ x ]     *     [a0,a1]    +   [a2]    =   a0*x+b0*x + a2</span></span><br><span class="line"><span class="comment">    // [b0,b1,b2]                 [b0,b1]    [b2]             [ y ]           [b0,b1]        [b2]    =   b1*y+b1*y + b2</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(0,0) = 1;// a0</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(0,1) = 0;// a1</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(0,2) = 0;// a2</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(1,0) = 0; // b1</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(1,1) = 1; // b2</span></span><br><span class="line"><span class="comment">    M.at&lt;float&gt;(1,2) = 0;*/</span> <span class="comment">//b3</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Point2f <span class="title">center</span><span class="params">(src.cols / <span class="number">2</span>, src.rows / <span class="number">2</span>)</span></span>;</span><br><span class="line">    Mat M = getRotationMatrix2D(center, <span class="number">45</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    warpAffine(src, res, M, src.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    cv_helper::mat2bitmap(env, res, bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-reSize-图片缩放"><a href="#3-reSize-图片缩放" class="headerlink" title="3. reSize() 图片缩放"></a>3. reSize() 图片缩放</h1><ul><li>INTER_NEAREST - 最近邻插值</li><li>INTER_LINEAR - 线性插值（默认值）</li><li>INTER_AREA - 区域插值（利用像素区域关系的重采样插值）</li><li>INTER_CUBIC –三次样条插值（超过4×4像素邻域内的双三次插值）</li><li>INTER_LANCZOS4 -Lanczos插值（超过8×8像素邻域的Lanczos插值）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片缩放</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_east_opencv63_OpenCvUtils_resize(JNIEnv *env, jclass clazz, jobject bitmap, jint <span class="built_in">width</span>,</span><br><span class="line">                                          jint <span class="built_in">height</span>) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line">    <span class="function">Mat <span class="title">res</span><span class="params">(<span class="built_in">height</span>, <span class="built_in">width</span>, src.type())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> src_w = src.cols;</span><br><span class="line">    <span class="keyword">float</span> src_h = src.rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="built_in">height</span>; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="built_in">width</span>; ++col) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> src_row = row * (src_h / <span class="built_in">height</span>);</span><br><span class="line">            <span class="keyword">int</span> src_col = col * (src_w / <span class="built_in">width</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (src.type() == CV_8UC4)</span><br><span class="line">                res.at&lt;Vec4b&gt;(row, col) = src.at&lt;Vec4b&gt;(src_row, src_col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC2)</span><br><span class="line">                res.at&lt;Vec3b&gt;(row, col) = src.at&lt;Vec3b&gt;(src_row, src_col);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (src.type() == CV_8UC1)</span><br><span class="line">                res.at&lt;uchar&gt;(row, col) = src.at&lt;uchar&gt;(src_row, src_col);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    jobject newBitmap = bitmap_util::create_bitmap(env, <span class="built_in">width</span>, <span class="built_in">height</span>, res.type());</span><br><span class="line">    cv_helper::mat2bitmap(env, res, newBitmap);</span><br><span class="line">    <span class="keyword">return</span> newBitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-remap-重映射-自己实现"><a href="#4-remap-重映射-自己实现" class="headerlink" title="4.remap 重映射  (自己实现)"></a>4.remap 重映射  (自己实现)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remap</span><span class="params">(Mat &amp;src,Mat &amp;res,Mat &amp;matX,Mat &amp;matY)</span></span>&#123;</span><br><span class="line">    res.create(src.<span class="built_in">size</span>(),src.type());</span><br><span class="line">    <span class="keyword">int</span> res_w = res.cols;</span><br><span class="line">    <span class="keyword">int</span> res_h = res.rows;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; res_h; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; res_w; ++col) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = matX.at&lt;<span class="keyword">float</span>&gt;(row,col);</span><br><span class="line">            <span class="keyword">int</span> y = matY.at&lt;<span class="keyword">float</span>&gt;(row,col);</span><br><span class="line">            res.at&lt;Vec4b&gt;(row,col) = src.at&lt;Vec4b&gt;(y,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 手写 Remap 重映射</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_east_opencv63_OpenCvUtils_reMap(JNIEnv *env, jclass clazz, jobject bitmap) &#123;</span><br><span class="line">    Mat src;</span><br><span class="line">    cv_helper::bitmap2mat(env, bitmap, src);</span><br><span class="line">    Mat res;</span><br><span class="line"></span><br><span class="line">    <span class="function">Mat <span class="title">matX</span><span class="params">(src.<span class="built_in">size</span>(), CV_32F)</span></span>;</span><br><span class="line">    <span class="function">Mat <span class="title">matY</span><span class="params">(src.<span class="built_in">size</span>(), CV_32F)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; src.rows; ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; src.cols; ++col) &#123;</span><br><span class="line">            matX.at&lt;<span class="keyword">float</span>&gt;(row, col) = src.cols - col;</span><br><span class="line">            matY.at&lt;<span class="keyword">float</span>&gt;(row, col) = src.rows - row;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remap(src, res, matX, matY);</span><br><span class="line">    cv_helper::mat2bitmap(env,res,bitmap);</span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;具体代码请看：&lt;strong&gt;&lt;a href=&quot;https://github.com/EastUp/NDKPractice/tree/master/opencv63&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NDKPractice项目的opencv63
      
    
    </summary>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/categories/OpenCV/"/>
    
    
      <category term="OpenCV" scheme="http://eastup.github.io/tags/OpenCV/"/>
    
  </entry>
  
</feed>
